/*
 * This file was generated by:
 * D:\P3D\1.9GIT\built_x64_buffered\bin\interrogate -fnames -string -refcount -assert -python-native -SD:\P3D\1.9GIT\built_x64_buffered\include/parser-inc -SD:\P3D\1.9GIT\built_x64_buffered\include/ -IGPUCommand -ILightSystem -IStaticGeometry -srcdir . -oc InterrogateWrapper.cpp -od Interrogate.in -module RSNative -library RSNative -nomangle -DINTERROGATE -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__inline -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -DWIN64_VC -DWIN64 -D_WIN64 -D_MSC_VER=1600 -D"__declspec(param)=" -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall .\config_rsnative.h .\GPUCommand\GPUCommand.h .\GPUCommand\GPUCommandList.h .\LightSystem\IESDataset.h .\LightSystem\InternalLightManager.h .\LightSystem\PointerSlotStorage.h .\LightSystem\PSSMCameraRig.h .\LightSystem\PSSMHelper.h .\LightSystem\RPLight.h .\LightSystem\RPPointLight.h .\LightSystem\RPSpotLight.h .\LightSystem\ShadowAtlas.h .\LightSystem\ShadowManager.h .\LightSystem\ShadowSource.h .\LightSystem\TagStateManager.h .\StaticGeometry\common.h .\StaticGeometry\MeshSplitter.h .\StaticGeometry\SGDataset.h .\StaticGeometry\SGNode.h .\StaticGeometry\SGRenderCallback.h .\StaticGeometry\SGRenderNode.h .\StaticGeometry\SGTriangleStrip.h .\StaticGeometry\StaticGeometryHandler.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_RSNative
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "./GPUCommand/GPUCommand.h"
#include "./GPUCommand/GPUCommandList.h"
#include "./LightSystem/IESDataset.h"
#include "./LightSystem/InternalLightManager.h"
#include "./LightSystem/PSSMCameraRig.h"
#include "./LightSystem/PSSMHelper.h"
#include "./LightSystem/PointerSlotStorage.h"
#include "./LightSystem/RPLight.h"
#include "./LightSystem/RPPointLight.h"
#include "./LightSystem/RPSpotLight.h"
#include "./LightSystem/ShadowAtlas.h"
#include "./LightSystem/ShadowManager.h"
#include "./LightSystem/ShadowSource.h"
#include "./LightSystem/TagStateManager.h"
#include "./StaticGeometry/MeshSplitter.h"
#include "./StaticGeometry/SGDataset.h"
#include "./StaticGeometry/SGNode.h"
#include "./StaticGeometry/SGRenderCallback.h"
#include "./StaticGeometry/SGRenderNode.h"
#include "./StaticGeometry/SGTriangleStrip.h"
#include "./StaticGeometry/StaticGeometryHandler.h"
#include "./StaticGeometry/common.h"
#include "./config_rsnative.h"
#include "GPUCommand.h"
#include "GPUCommandList.h"
#include "PointerSlotStorage.h"
#include "RPLight.h"
#include "ShadowAtlas.h"
#include "ShadowManager.h"
#include "ShadowSource.h"
#include "boundingBox.h"
#include "callbackData.h"
#include "callbackObject.h"
#include "camera.h"
#include "common.h"
#include "configVariableDouble.h"
#include "configVariableInt.h"
#include "configVariableString.h"
#include "datagramIterator.h"
#include "filename.h"
#include "geom.h"
#include "geomPrimitive.h"
#include "geomVertexReader.h"
#include <list>
#include "luse.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "pStatCollector.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "pointerToArray.h"
#include "pta_float.h"
#include "pvector.h"
#include <queue>
#include "referenceCount.h"
#include "renderState.h"
#include "shader.h"
#include "texture.h"
#include "typeHandle.h"
#include <vector>

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

//********************************************************************
//*** prototypes for .. Global
//********************************************************************
//********************************************************************
//*** prototypes for .. GPUCommand
//********************************************************************
typedef GPUCommand GPUCommand_localtype;
Define_Module_Class(RSNative, GPUCommand, GPUCommand_localtype, GPUCommand);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GPUCommand = &Dtool_GPUCommand;
static void Dtool_PyModuleClassInit_GPUCommand(PyObject *module);
bool Dtool_ConstCoerce_GPUCommand(PyObject *args, GPUCommand const *&coerced, bool &manage);
bool Dtool_Coerce_GPUCommand(PyObject *args, GPUCommand *&coerced, bool &manage);

//********************************************************************
//*** prototypes for .. GPUCommandList
//********************************************************************
typedef GPUCommandList GPUCommandList_localtype;
Define_Module_Class(RSNative, GPUCommandList, GPUCommandList_localtype, GPUCommandList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GPUCommandList = &Dtool_GPUCommandList;
static void Dtool_PyModuleClassInit_GPUCommandList(PyObject *module);

//********************************************************************
//*** prototypes for .. RPLight
//********************************************************************
typedef RPLight RPLight_localtype;
Define_Module_ClassRef(RSNative, RPLight, RPLight_localtype, RPLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RPLight = &Dtool_RPLight;
static void Dtool_PyModuleClassInit_RPLight(PyObject *module);

//********************************************************************
//*** prototypes for .. ShadowManager
//********************************************************************
typedef ShadowManager ShadowManager_localtype;
Define_Module_ClassRef(RSNative, ShadowManager, ShadowManager_localtype, ShadowManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShadowManager = &Dtool_ShadowManager;
static void Dtool_PyModuleClassInit_ShadowManager(PyObject *module);

//********************************************************************
//*** prototypes for .. TagStateManager
//********************************************************************
typedef TagStateManager TagStateManager_localtype;
Define_Module_Class(RSNative, TagStateManager, TagStateManager_localtype, TagStateManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TagStateManager = &Dtool_TagStateManager;
static void Dtool_PyModuleClassInit_TagStateManager(PyObject *module);
bool Dtool_ConstCoerce_TagStateManager(PyObject *args, TagStateManager const *&coerced, bool &manage);
bool Dtool_Coerce_TagStateManager(PyObject *args, TagStateManager *&coerced, bool &manage);

//********************************************************************
//*** prototypes for .. IESDataset
//********************************************************************
typedef IESDataset IESDataset_localtype;
Define_Module_Class(RSNative, IESDataset, IESDataset_localtype, IESDataset);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IESDataset = &Dtool_IESDataset;
static void Dtool_PyModuleClassInit_IESDataset(PyObject *module);

//********************************************************************
//*** prototypes for .. ShadowAtlas
//********************************************************************
typedef ShadowAtlas ShadowAtlas_localtype;
Define_Module_Class(RSNative, ShadowAtlas, ShadowAtlas_localtype, ShadowAtlas);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShadowAtlas = &Dtool_ShadowAtlas;
static void Dtool_PyModuleClassInit_ShadowAtlas(PyObject *module);
bool Dtool_ConstCoerce_ShadowAtlas(PyObject *args, ShadowAtlas const *&coerced, bool &manage);
bool Dtool_Coerce_ShadowAtlas(PyObject *args, ShadowAtlas *&coerced, bool &manage);

//********************************************************************
//*** prototypes for .. InternalLightManager
//********************************************************************
typedef InternalLightManager InternalLightManager_localtype;
Define_Module_Class(RSNative, InternalLightManager, InternalLightManager_localtype, InternalLightManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InternalLightManager = &Dtool_InternalLightManager;
static void Dtool_PyModuleClassInit_InternalLightManager(PyObject *module);

//********************************************************************
//*** prototypes for .. PSSMCameraRig
//********************************************************************
typedef PSSMCameraRig PSSMCameraRig_localtype;
Define_Module_Class(RSNative, PSSMCameraRig, PSSMCameraRig_localtype, PSSMCameraRig);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PSSMCameraRig = &Dtool_PSSMCameraRig;
static void Dtool_PyModuleClassInit_PSSMCameraRig(PyObject *module);
bool Dtool_ConstCoerce_PSSMCameraRig(PyObject *args, PSSMCameraRig const *&coerced, bool &manage);
bool Dtool_Coerce_PSSMCameraRig(PyObject *args, PSSMCameraRig *&coerced, bool &manage);

//********************************************************************
//*** prototypes for .. RPPointLight
//********************************************************************
typedef RPPointLight RPPointLight_localtype;
Define_Module_ClassRef(RSNative, RPPointLight, RPPointLight_localtype, RPPointLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RPPointLight = &Dtool_RPPointLight;
static void Dtool_PyModuleClassInit_RPPointLight(PyObject *module);

//********************************************************************
//*** prototypes for .. RPSpotLight
//********************************************************************
typedef RPSpotLight RPSpotLight_localtype;
Define_Module_ClassRef(RSNative, RPSpotLight, RPSpotLight_localtype, RPSpotLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RPSpotLight = &Dtool_RPSpotLight;
static void Dtool_PyModuleClassInit_RPSpotLight(PyObject *module);

//********************************************************************
//*** prototypes for .. MeshSplitterWriter
//********************************************************************
typedef MeshSplitterWriter MeshSplitterWriter_localtype;
Define_Module_Class(RSNative, MeshSplitterWriter, MeshSplitterWriter_localtype, MeshSplitterWriter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MeshSplitterWriter = &Dtool_MeshSplitterWriter;
static void Dtool_PyModuleClassInit_MeshSplitterWriter(PyObject *module);

//********************************************************************
//*** prototypes for .. SGNode
//********************************************************************
typedef SGNode SGNode_localtype;
Define_Module_ClassRef(RSNative, SGNode, SGNode_localtype, SGNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SGNode = &Dtool_SGNode;
static void Dtool_PyModuleClassInit_SGNode(PyObject *module);
bool Dtool_ConstCoerce_SGNode(PyObject *args, CPT(SGNode) &coerced);
bool Dtool_Coerce_SGNode(PyObject *args, PT(SGNode) &coerced);

//********************************************************************
//*** prototypes for .. SGRenderNode
//********************************************************************
typedef SGRenderNode SGRenderNode_localtype;
Define_Module_ClassRef(RSNative, SGRenderNode, SGRenderNode_localtype, SGRenderNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SGRenderNode = &Dtool_SGRenderNode;
static void Dtool_PyModuleClassInit_SGRenderNode(PyObject *module);
bool Dtool_ConstCoerce_SGRenderNode(PyObject *args, CPT(SGRenderNode) &coerced);
bool Dtool_Coerce_SGRenderNode(PyObject *args, PT(SGRenderNode) &coerced);

//********************************************************************
//*** prototypes for .. StaticGeometryHandler
//********************************************************************
typedef StaticGeometryHandler StaticGeometryHandler_localtype;
Define_Module_Class(RSNative, StaticGeometryHandler, StaticGeometryHandler_localtype, StaticGeometryHandler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StaticGeometryHandler = &Dtool_StaticGeometryHandler;
static void Dtool_PyModuleClassInit_StaticGeometryHandler(PyObject *module);

//********************************************************************
//*** prototypes for .. External Objects
//********************************************************************
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// PointerToArray< unsigned char >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PointerToArray_unsigned_char;
inline static PointerToArray< unsigned char > *Dtool_Coerce_PointerToArray_unsigned_char(PyObject *args, PointerToArray< unsigned char > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_unsigned_char != NULL, NULL);
  nassertr(Dtool_Ptr_PointerToArray_unsigned_char->_Dtool_Coerce != NULL, NULL);
  return ((PointerToArray< unsigned char > *(*)(PyObject *, PointerToArray< unsigned char > &))Dtool_Ptr_PointerToArray_unsigned_char->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_unsigned_char;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_unsigned_char = &Dtool_PointerToArray_unsigned_char;
extern PointerToArray< unsigned char > *Dtool_Coerce_PointerToArray_unsigned_char(PyObject *args, PointerToArray< unsigned char > &coerced);
#endif
// LVecBase3i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3i;
inline static LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  nassertr(Dtool_Ptr_LVecBase3i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3i *(*)(PyObject *, LVecBase3i &))Dtool_Ptr_LVecBase3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
extern LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix4f;
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// PointerToArray< float >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PointerToArray_float;
inline static PointerToArray< float > *Dtool_Coerce_PointerToArray_float(PyObject *args, PointerToArray< float > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_float != NULL, NULL);
  nassertr(Dtool_Ptr_PointerToArray_float->_Dtool_Coerce != NULL, NULL);
  return ((PointerToArray< float > *(*)(PyObject *, PointerToArray< float > &))Dtool_Ptr_PointerToArray_float->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_float;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_float = &Dtool_PointerToArray_float;
extern PointerToArray< float > *Dtool_Coerce_PointerToArray_float(PyObject *args, PointerToArray< float > &coerced);
#endif
// LVecBase4i
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4i;
inline static LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced) {
  nassertr(Dtool_Ptr_LVecBase4i != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4i->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4i *(*)(PyObject *, LVecBase4i &))Dtool_Ptr_LVecBase4i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4i = &Dtool_LVecBase4i;
extern LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced);
#endif
// LMatrix3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LMatrix3f;
inline static LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  nassertr(Dtool_Ptr_LMatrix3f != NULL, NULL);
  nassertr(Dtool_Ptr_LMatrix3f->_Dtool_Coerce != NULL, NULL);
  return ((LMatrix3f *(*)(PyObject *, LMatrix3f &))Dtool_Ptr_LMatrix3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
extern LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// Texture
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Texture;
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// BitMask< PN_uint32, 32 >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_BitMask_PN_uint32_32;
inline static BitMask< PN_uint32, 32 > *Dtool_Coerce_BitMask_PN_uint32_32(PyObject *args, BitMask< PN_uint32, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_PN_uint32_32 != NULL, NULL);
  nassertr(Dtool_Ptr_BitMask_PN_uint32_32->_Dtool_Coerce != NULL, NULL);
  return ((BitMask< PN_uint32, 32 > *(*)(PyObject *, BitMask< PN_uint32, 32 > &))Dtool_Ptr_BitMask_PN_uint32_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_PN_uint32_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_PN_uint32_32 = &Dtool_BitMask_PN_uint32_32;
extern BitMask< PN_uint32, 32 > *Dtool_Coerce_BitMask_PN_uint32_32(PyObject *args, BitMask< PN_uint32, 32 > &coerced);
#endif
// Geom
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Geom;
#else
extern struct Dtool_PyTypedObject Dtool_Geom;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Geom = &Dtool_Geom;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// PointerToArray< UnalignedLMatrix4f >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PointerToArray_UnalignedLMatrix4f;
inline static PointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(PyObject *args, PointerToArray< UnalignedLMatrix4f > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_UnalignedLMatrix4f != NULL, NULL);
  nassertr(Dtool_Ptr_PointerToArray_UnalignedLMatrix4f->_Dtool_Coerce != NULL, NULL);
  return ((PointerToArray< UnalignedLMatrix4f > *(*)(PyObject *, PointerToArray< UnalignedLMatrix4f > &))Dtool_Ptr_PointerToArray_UnalignedLMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLMatrix4f = &Dtool_PointerToArray_UnalignedLMatrix4f;
extern PointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(PyObject *args, PointerToArray< UnalignedLMatrix4f > &coerced);
#endif
// PointerToArray< LVecBase2f >
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PointerToArray_LVecBase2f;
inline static PointerToArray< LVecBase2f > *Dtool_Coerce_PointerToArray_LVecBase2f(PyObject *args, PointerToArray< LVecBase2f > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_LVecBase2f != NULL, NULL);
  nassertr(Dtool_Ptr_PointerToArray_LVecBase2f->_Dtool_Coerce != NULL, NULL);
  return ((PointerToArray< LVecBase2f > *(*)(PyObject *, PointerToArray< LVecBase2f > &))Dtool_Ptr_PointerToArray_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase2f = &Dtool_PointerToArray_LVecBase2f;
extern PointerToArray< LVecBase2f > *Dtool_Coerce_PointerToArray_LVecBase2f(PyObject *args, PointerToArray< LVecBase2f > &coerced);
#endif
// Shader
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Shader;
inline static bool Dtool_ConstCoerce_Shader(PyObject *args, CPT(Shader) &coerced) {
  nassertr(Dtool_Ptr_Shader != NULL, false);
  nassertr(Dtool_Ptr_Shader->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(Shader) &))Dtool_Ptr_Shader->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_Shader(PyObject *args, PT(Shader) &coerced) {
  nassertr(Dtool_Ptr_Shader != NULL, false);
  nassertr(Dtool_Ptr_Shader->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(Shader) &))Dtool_Ptr_Shader->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Shader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Shader = &Dtool_Shader;
extern bool Dtool_ConstCoerce_Shader(PyObject *args, CPT(Shader) &coerced);
extern bool Dtool_Coerce_Shader(PyObject *args, PT(Shader) &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// Camera
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Camera;
#else
extern struct Dtool_PyTypedObject Dtool_Camera;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Camera = &Dtool_Camera;
#endif
// GraphicsOutput
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GraphicsOutput;
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsOutput;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutput = &Dtool_GraphicsOutput;
#endif

//********************************************************************
//*** Functions for .. Global
//********************************************************************
//********************************************************************
//*** Functions for .. GPUCommand
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void GPUCommand::push_int(int v)
 *******************************************************************/
static PyObject *Dtool_GPUCommand_push_int_4(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_int")) {
    return NULL;
  }
  // 1-inline void GPUCommand::push_int(int v)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).push_int((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_int(const GPUCommand self, int v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_int_4_comment =
  "C++ Interface:\n"
  "push_int(const GPUCommand self, int v)\n"
  "\n"
  "/**\n"
  " * @brief Appends an integer to the GPUCommand.\n"
  " * @details This adds an integer to the back of the GPUCommand. Depending on the\n"
  " *   setting in convert_int_to_float, this will either just convert the int to a\n"
  " *   float by casting it, or just do a bitwise copy.\n"
  " *\n"
  " * @param v The integer to append.\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_int_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GPUCommand::push_float(float v)
 *******************************************************************/
static PyObject *Dtool_GPUCommand_push_float_5(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_float")) {
    return NULL;
  }
  // 1-inline void GPUCommand::push_float(float v)
  if (PyNumber_Check(arg)) {
    (*local_this).push_float((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_float(const GPUCommand self, float v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_float_5_comment =
  "C++ Interface:\n"
  "push_float(const GPUCommand self, float v)\n"
  "\n"
  "/**\n"
  " * @brief Appends a float to the GPUCommand.\n"
  " * @details This adds an integer to the back of the GPUCommand. Its used by all\n"
  " *   other push_xxx methods, and simply stores the value, then increments the write\n"
  " *   pointer. When the amount of floats exceeds the capacity of the GPUCommand,\n"
  " *   an error will be printed, and the method returns without doing anything else.\n"
  " *\n"
  " * @param v The float to append.\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_float_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GPUCommand::push_vec3(LVecBase3f const &v)
 * inline void GPUCommand::push_vec3(LVecBase3i const &v)
 *******************************************************************/
static PyObject *Dtool_GPUCommand_push_vec3_6(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_vec3")) {
    return NULL;
  }
  {
    // -2 inline void GPUCommand::push_vec3(LVecBase3i const &v)
    LVecBase3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3i, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).push_vec3(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec3(LVecBase3f const &v)
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).push_vec3(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec3(LVecBase3i const &v)
    LVecBase3i arg_local;
    LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).push_vec3(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec3(LVecBase3f const &v)
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).push_vec3(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_vec3(const GPUCommand self, const LVecBase3i v)\n"
      "push_vec3(const GPUCommand self, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_vec3_6_comment =
  "C++ Interface:\n"
  "push_vec3(const GPUCommand self, const LVecBase3i v)\n"
  "push_vec3(const GPUCommand self, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * @brief Appends a 3-component floating point vector to the GPUCommand.\n"
  " * @details This appends a 3-component floating point vector to the command.\n"
  " *   It basically just calls push_float() for every component, in the order\n"
  " *   x, y, z, which causes the vector to occupy the space of 3 floats.\n"
  " *\n"
  " * @param v Int-Vector to append.\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Appends a 3-component integer vector to the GPUCommand.\n"
  " * @details This appends a 3-component integer vector to the command.\n"
  " *   It basically just calls push_int() for every component, in the order\n"
  " *   x, y, z, which causes the vector to occupy the space of 3 floats.\n"
  " *\n"
  " * @param v Int-Vector to append.\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_vec3_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GPUCommand::push_vec4(LVecBase4f const &v)
 * inline void GPUCommand::push_vec4(LVecBase4i const &v)
 *******************************************************************/
static PyObject *Dtool_GPUCommand_push_vec4_7(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_vec4")) {
    return NULL;
  }
  {
    // -2 inline void GPUCommand::push_vec4(LVecBase4f const &v)
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).push_vec4(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec4(LVecBase4i const &v)
    LVecBase4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).push_vec4(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec4(LVecBase4f const &v)
    LVecBase4f arg_local;
    LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).push_vec4(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec4(LVecBase4i const &v)
    LVecBase4i arg_local;
    LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).push_vec4(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_vec4(const GPUCommand self, const LVecBase4f v)\n"
      "push_vec4(const GPUCommand self, const LVecBase4i v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_vec4_7_comment =
  "C++ Interface:\n"
  "push_vec4(const GPUCommand self, const LVecBase4f v)\n"
  "push_vec4(const GPUCommand self, const LVecBase4i v)\n"
  "\n"
  "/**\n"
  " * @brief Appends a 4-component floating point vector to the GPUCommand.\n"
  " * @details This appends a 4-component floating point vector to the command.\n"
  " *   It basically just calls push_float() for every component, in the order\n"
  " *   x, y, z, which causes the vector to occupy the space of 3 floats.\n"
  " *\n"
  " * @param v Int-Vector to append.\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Appends a 4-component integer vector to the GPUCommand.\n"
  " * @details This appends a 4-component integer vector to the command.\n"
  " *   It basically just calls push_int() for every component, in the order\n"
  " *   x, y, z, w, which causes the vector to occupy the space of 4 floats.\n"
  " *\n"
  " * @param v Int-Vector to append.\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_vec4_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GPUCommand::push_mat3(LMatrix3f const &v)
 *******************************************************************/
static PyObject *Dtool_GPUCommand_push_mat3_8(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_mat3")) {
    return NULL;
  }
  // 1-inline void GPUCommand::push_mat3(LMatrix3f const &v)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GPUCommand.push_mat3", "LMatrix3f");
  }
  (*local_this).push_mat3(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_mat3(const GPUCommand self, const LMatrix3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_mat3_8_comment =
  "C++ Interface:\n"
  "push_mat3(const GPUCommand self, const LMatrix3f v)\n"
  "\n"
  "/**\n"
  " * @brief Appends a floating point 3x3 matrix to the GPUCommand.\n"
  " * @details This appends a floating point 3x3 matrix to the GPUCommand, by\n"
  " *   pushing all components in row-order to the command. This occupies a space of\n"
  " *   9 floats.\n"
  " *\n"
  " * @param v Matrix to append\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_mat3_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void GPUCommand::push_mat4(LMatrix4f const &v)
 *******************************************************************/
static PyObject *Dtool_GPUCommand_push_mat4_9(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_mat4")) {
    return NULL;
  }
  // 1-inline void GPUCommand::push_mat4(LMatrix4f const &v)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GPUCommand.push_mat4", "LMatrix4f");
  }
  (*local_this).push_mat4(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_mat4(const GPUCommand self, const LMatrix4f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_mat4_9_comment =
  "C++ Interface:\n"
  "push_mat4(const GPUCommand self, const LMatrix4f v)\n"
  "\n"
  "/**\n"
  " * @brief Appends a floating point 4x4 matrix to the GPUCommand.\n"
  " * @details This appends a floating point 4x4 matrix to the GPUCommand, by\n"
  " *   pushing all components in row-order to the command. This occupies a space of\n"
  " *   16 floats.\n"
  " *\n"
  " * @param v Matrix to append\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_mat4_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool GPUCommand::get_uses_integer_packing(void)
 *******************************************************************/
static PyObject *Dtool_GPUCommand_get_uses_integer_packing_10(PyObject *, PyObject *) {
  // 1-static inline bool GPUCommand::get_uses_integer_packing(void)
  bool return_value = GPUCommand::get_uses_integer_packing();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_get_uses_integer_packing_10_comment =
  "C++ Interface:\n"
  "get_uses_integer_packing()\n"
  "\n"
  "/**\n"
  " * @brief Returns whether integers are packed as floats.\n"
  " * @details This returns how integer are packed into the data stream. If the\n"
  " *   returned value is true, then integers are packed using their binary\n"
  " *   representation converted to floating point format. If the returned value\n"
  " *   is false, then integers are packed by simply casting them to float,\n"
  " *   e.g. val = (float)i;\n"
  " * @return The integer representation flag\n"
  " */";
#else
static const char *Dtool_GPUCommand_get_uses_integer_packing_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GPUCommand::write_to(PTA_uchar const &dest, std::size_t command_index)
 *******************************************************************/
static PyObject *Dtool_GPUCommand_write_to_11(PyObject *self, PyObject *args, PyObject *kwds) {
  GPUCommand *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.write_to")) {
    return NULL;
  }
  // 1-void GPUCommand::write_to(PTA_uchar const &dest, std::size_t command_index)
  PyObject *param1;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"dest", "command_index", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "On:write_to", (char **)keyword_list, &param1, &param2)) {
    PointerToArray< unsigned char > param1_local;
    PTA_uchar const *param1_this = Dtool_Coerce_PointerToArray_unsigned_char(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GPUCommand.write_to", "PointerToArray");
    }
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    (*local_this).write_to(*param1_this, (std::size_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_to(const GPUCommand self, const PointerToArray dest, int command_index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_write_to_11_comment =
  "C++ Interface:\n"
  "write_to(const GPUCommand self, const PointerToArray dest, int command_index)\n";
#else
static const char *Dtool_GPUCommand_write_to_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void GPUCommand::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_GPUCommand_write_12(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GPUCommand, (void **)&local_this)) {
    return NULL;
  }
  // 1-void GPUCommand::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "GPUCommand.write", false, true);
  if (arg_this != NULL) {
    (*(const GPUCommand*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(GPUCommand self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_write_12_comment =
  "C++ Interface:\n"
  "write(GPUCommand self, ostream out)\n";
#else
static const char *Dtool_GPUCommand_write_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GPUCommand::GPUCommand(GPUCommand::CommandType command_type)
 *******************************************************************/
static int Dtool_Init_GPUCommand(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GPUCommand() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "command_type");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'command_type' (pos 1) not found");
    return -1;
  }
  // 1-GPUCommand::GPUCommand(GPUCommand::CommandType command_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    GPUCommand *return_value = new GPUCommand((GPUCommand::CommandType)arg_val);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GPUCommand, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GPUCommand(int command_type)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_GPUCommand(PyObject *args, GPUCommand const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_GPUCommand, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-GPUCommand::GPUCommand(GPUCommand::CommandType command_type)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      GPUCommand *return_value = new GPUCommand((GPUCommand::CommandType)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_GPUCommand(PyObject *args, GPUCommand *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_GPUCommand, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-GPUCommand::GPUCommand(GPUCommand::CommandType command_type)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      GPUCommand *return_value = new GPUCommand((GPUCommand::CommandType)arg_val);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_GPUCommand(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_GPUCommand) {
    printf("GPUCommand ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  GPUCommand *local_this = (GPUCommand *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_GPUCommand) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_GPUCommand(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_GPUCommand) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. GPUCommandList
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void GPUCommandList::add_command(GPUCommand const &cmd)
 *******************************************************************/
static PyObject *Dtool_GPUCommandList_add_command_16(PyObject *self, PyObject *arg) {
  GPUCommandList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommandList, (void **)&local_this, "GPUCommandList.add_command")) {
    return NULL;
  }
  // 1-void GPUCommandList::add_command(GPUCommand const &cmd)
  GPUCommand const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_GPUCommand(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GPUCommandList.add_command", "GPUCommand");
  }
  (*local_this).add_command(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_command(const GPUCommandList self, const GPUCommand cmd)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommandList_add_command_16_comment =
  "C++ Interface:\n"
  "add_command(const GPUCommandList self, const GPUCommand cmd)\n";
#else
static const char *Dtool_GPUCommandList_add_command_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * std::size_t GPUCommandList::get_num_commands(void)
 *******************************************************************/
static PyObject *Dtool_GPUCommandList_get_num_commands_17(PyObject *self, PyObject *) {
  GPUCommandList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommandList, (void **)&local_this, "GPUCommandList.get_num_commands")) {
    return NULL;
  }
  // 1-std::size_t GPUCommandList::get_num_commands(void)
  std::size_t return_value = (*local_this).get_num_commands();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyLongOrInt_FromSize_t(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GPUCommandList_get_num_commands_17_comment =
  "C++ Interface:\n"
  "get_num_commands(const GPUCommandList self)\n";
#else
static const char *Dtool_GPUCommandList_get_num_commands_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * std::size_t GPUCommandList::write_commands_to(PTA_uchar const &dest, std::size_t limit = 32)
 *******************************************************************/
static PyObject *Dtool_GPUCommandList_write_commands_to_18(PyObject *self, PyObject *args, PyObject *kwds) {
  GPUCommandList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommandList, (void **)&local_this, "GPUCommandList.write_commands_to")) {
    return NULL;
  }
  // 1-std::size_t GPUCommandList::write_commands_to(PTA_uchar const &dest, std::size_t limit = 32)
  PyObject *param1;
  Py_ssize_t param2 = 32;
  static const char *keyword_list[] = {"dest", "limit", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|n:write_commands_to", (char **)keyword_list, &param1, &param2)) {
    PointerToArray< unsigned char > param1_local;
    PTA_uchar const *param1_this = Dtool_Coerce_PointerToArray_unsigned_char(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GPUCommandList.write_commands_to", "PointerToArray");
    }
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    std::size_t return_value = (*local_this).write_commands_to(*param1_this, (std::size_t)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return PyLongOrInt_FromSize_t(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_commands_to(const GPUCommandList self, const PointerToArray dest, int limit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommandList_write_commands_to_18_comment =
  "C++ Interface:\n"
  "write_commands_to(const GPUCommandList self, const PointerToArray dest, int limit)\n";
#else
static const char *Dtool_GPUCommandList_write_commands_to_18_comment = NULL;
#endif

PyObject *Dtool_GPUCommandList_num_commands_Getter(PyObject *self, void *) {
  GPUCommandList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommandList, (void **)&local_this, "GPUCommandList.num_commands")) {
    return NULL;
  }

  // 1-std::size_t GPUCommandList::get_num_commands(void)
  std::size_t return_value = (*local_this).get_num_commands();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyLongOrInt_FromSize_t(return_value);
}

/******************************************************************
 * Python type method wrapper for
 * GPUCommandList::GPUCommandList(void)
 * inline GPUCommandList::GPUCommandList(GPUCommandList const &) = default
 *******************************************************************/
static int Dtool_Init_GPUCommandList(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-GPUCommandList::GPUCommandList(void)
      GPUCommandList *return_value = new GPUCommandList();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GPUCommandList, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline GPUCommandList::GPUCommandList(GPUCommandList const &) = default
      GPUCommandList const *arg_this = (GPUCommandList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GPUCommandList, 0, "GPUCommandList.GPUCommandList", true, true);
      if (arg_this != NULL) {
        GPUCommandList *return_value = new GPUCommandList(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GPUCommandList, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GPUCommandList() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GPUCommandList()\n"
      "GPUCommandList(const GPUCommandList param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GPUCommandList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_GPUCommandList) {
    printf("GPUCommandList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  GPUCommandList *local_this = (GPUCommandList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_GPUCommandList) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_GPUCommandList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_GPUCommandList) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. RPLight
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void RPLight::set_pos(LVecBase3f const &pos)
 * inline void RPLight::set_pos(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_RPLight_set_pos_26(PyObject *self, PyObject *args, PyObject *kwds) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_pos")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-inline void RPLight::set_pos(LVecBase3f const &pos)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "RPLight.set_pos", "LVecBase3f");
      }
      (*local_this).set_pos(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void RPLight::set_pos(float x, float y, float z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_pos((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const RPLight self, const LVecBase3f pos)\n"
      "set_pos(const RPLight self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_pos_26_comment =
  "C++ Interface:\n"
  "set_pos(const RPLight self, const LVecBase3f pos)\n"
  "set_pos(const RPLight self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * @brief Sets the position of the light\n"
  " * @details This sets the position of the light in world space. It will cause\n"
  " *   the light to get invalidated, and resubmitted to the GPU.\n"
  " *\n"
  " * @param pos Position in world space\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the position of the light\n"
  " * @details @copydetails RPLight::set_pos(const LVecBase3f &pos)\n"
  " *\n"
  " * @param x X-component of the position\n"
  " * @param y Y-component of the position\n"
  " * @param z Z-component of the position\n"
  " */";
#else
static const char *Dtool_RPLight_set_pos_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &RPLight::get_pos(void) const
 *******************************************************************/
static PyObject *Dtool_RPLight_get_pos_27(PyObject *self, PyObject *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f const &RPLight::get_pos(void) const
  LVecBase3f const *return_value = &((*(const RPLight*)local_this).get_pos());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_pos_27_comment =
  "C++ Interface:\n"
  "get_pos(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the position of the light\n"
  " * @details This returns the position of the light previously set with\n"
  " *   RPLight::set_pos(). The returned position is in world space.\n"
  " * @return Light-position\n"
  " */";
#else
static const char *Dtool_RPLight_get_pos_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPLight::set_color(LVecBase3f const &color)
 * inline void RPLight::set_color(float r, float g, float b)
 *******************************************************************/
static PyObject *Dtool_RPLight_set_color_30(PyObject *self, PyObject *args, PyObject *kwds) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_color")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "color");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'color' (pos 1) not found");
      }
      // 1-inline void RPLight::set_color(LVecBase3f const &color)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "RPLight.set_color", "LVecBase3f");
      }
      (*local_this).set_color(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void RPLight::set_color(float r, float g, float b)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"r", "g", "b", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_color", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_color((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const RPLight self, const LVecBase3f color)\n"
      "set_color(const RPLight self, float r, float g, float b)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_color_30_comment =
  "C++ Interface:\n"
  "set_color(const RPLight self, const LVecBase3f color)\n"
  "set_color(const RPLight self, float r, float g, float b)\n"
  "\n"
  "/**\n"
  " * @brief Sets the lights color\n"
  " * @details This sets the lights color. The color should not include the brightness\n"
  " *   of the light, you should control that with the lumens. The color specifies\n"
  " *   the lights \"tint\" and will get multiplied with its specular and diffuse\n"
  " *   contribution.\n"
  " *\n"
  " *   The color will be normalized by dividing by the colors luminance. Setting\n"
  " *   higher values than 1.0 will have no effect.\n"
  " *\n"
  " * @param color Light color\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the lights color\n"
  " * @details @copydetails RPLight::set_color(const LVecBase3f &color)\n"
  " *\n"
  " * @param r Red-component of the color\n"
  " * @param g Green-component of the color\n"
  " * @param b Blue-component of the color\n"
  " */";
#else
static const char *Dtool_RPLight_set_color_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &RPLight::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_RPLight_get_color_31(PyObject *self, PyObject *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f const &RPLight::get_color(void) const
  LVecBase3f const *return_value = &((*(const RPLight*)local_this).get_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_color_31_comment =
  "C++ Interface:\n"
  "get_color(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the lights color\n"
  " * @details This returns the light color, previously set with RPLight::set_color.\n"
  " *   This does not include the lumens of the light. It might differ from what\n"
  " *   was set with set_color, because the color is normalized by dividing it\n"
  " *   by its luminance.\n"
  " * @return Light-color\n"
  " */";
#else
static const char *Dtool_RPLight_get_color_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void RPLight::set_color_from_temperature(float temperature)
 *******************************************************************/
static PyObject *Dtool_RPLight_set_color_from_temperature_33(PyObject *self, PyObject *arg) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_color_from_temperature")) {
    return NULL;
  }
  // 1-void RPLight::set_color_from_temperature(float temperature)
  if (PyNumber_Check(arg)) {
    (*local_this).set_color_from_temperature((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_from_temperature(const RPLight self, float temperature)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_color_from_temperature_33_comment =
  "C++ Interface:\n"
  "set_color_from_temperature(const RPLight self, float temperature)\n";
#else
static const char *Dtool_RPLight_set_color_from_temperature_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPLight::set_lumens(float lumens)
 *******************************************************************/
static PyObject *Dtool_RPLight_set_lumens_34(PyObject *self, PyObject *arg) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_lumens")) {
    return NULL;
  }
  // 1-inline void RPLight::set_lumens(float lumens)
  if (PyNumber_Check(arg)) {
    (*local_this).set_lumens((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lumens(const RPLight self, float lumens)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_lumens_34_comment =
  "C++ Interface:\n"
  "set_lumens(const RPLight self, float lumens)\n"
  "\n"
  "/**\n"
  " * @brief Sets the lumens of the light\n"
  " * @details This sets the lumens of the light, which can be seen as the brightness\n"
  " *   of the light. It will get multiplied with the normalized color.\n"
  " *\n"
  " * @param lumens Lumens of the light\n"
  " */";
#else
static const char *Dtool_RPLight_set_lumens_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RPLight::get_lumens(void) const
 *******************************************************************/
static PyObject *Dtool_RPLight_get_lumens_35(PyObject *self, PyObject *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float RPLight::get_lumens(void) const
  float return_value = (*(const RPLight*)local_this).get_lumens();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyFloat_FromDouble(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_lumens_35_comment =
  "C++ Interface:\n"
  "get_lumens(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the lumens of the light\n"
  " * @details This returns the lumens of the light, previously set with\n"
  " *   RPLight::set_lumens.\n"
  " *\n"
  " * @return Lumens of the light\n"
  " */";
#else
static const char *Dtool_RPLight_get_lumens_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline RPLight::LightType RPLight::get_light_type(void) const
 *******************************************************************/
static PyObject *Dtool_RPLight_get_light_type_38(PyObject *self, PyObject *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline RPLight::LightType RPLight::get_light_type(void) const
  RPLight::LightType return_value = (*(const RPLight*)local_this).get_light_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyLongOrInt_FromLong(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_light_type_38_comment =
  "C++ Interface:\n"
  "get_light_type(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the type of the light\n"
  " * @details This returns the internal type of the light, which was specified\n"
  " *   in the lights constructor. This can be used to distinguish between light\n"
  " *   types.\n"
  " * @return Type of the light\n"
  " */";
#else
static const char *Dtool_RPLight_get_light_type_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPLight::set_casts_shadows(bool flag = true)
 *******************************************************************/
static PyObject *Dtool_RPLight_set_casts_shadows_40(PyObject *self, PyObject *args, PyObject *kwds) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_casts_shadows")) {
    return NULL;
  }
  // 1-inline void RPLight::set_casts_shadows(bool flag = true)
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"flag", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:set_casts_shadows", (char **)keyword_list, &param1)) {
    (*local_this).set_casts_shadows((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_casts_shadows(const RPLight self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_casts_shadows_40_comment =
  "C++ Interface:\n"
  "set_casts_shadows(const RPLight self, bool flag)\n"
  "\n"
  "/**\n"
  " * @brief Controls whether the light casts shadows\n"
  " * @details This sets whether the light casts shadows. You can not change this\n"
  " *   while the light is attached. When flag is set to true, the light will be\n"
  " *   setup to cast shadows, spawning shadow sources based on the lights type.\n"
  " *   If the flag is set to false, the light will be inddicated to cast no shadows.\n"
  " *\n"
  " * @param flag Whether the light casts shadows\n"
  " */";
#else
static const char *Dtool_RPLight_set_casts_shadows_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RPLight::get_casts_shadows(void) const
 *******************************************************************/
static PyObject *Dtool_RPLight_get_casts_shadows_41(PyObject *self, PyObject *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RPLight::get_casts_shadows(void) const
  bool return_value = (*(const RPLight*)local_this).get_casts_shadows();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_casts_shadows_41_comment =
  "C++ Interface:\n"
  "get_casts_shadows(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the light casts shadows\n"
  " * @details This returns whether the light casts shadows, the returned value\n"
  " *   is the one previously set with RPLight::set_casts_shadows.\n"
  " *\n"
  " * @return true if the light casts shadows, false otherwise\n"
  " */";
#else
static const char *Dtool_RPLight_get_casts_shadows_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPLight::set_shadow_map_resolution(std::size_t resolution)
 *******************************************************************/
static PyObject *Dtool_RPLight_set_shadow_map_resolution_44(PyObject *self, PyObject *arg) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_shadow_map_resolution")) {
    return NULL;
  }
  // 1-inline void RPLight::set_shadow_map_resolution(std::size_t resolution)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:set_shadow_map_resolution", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_shadow_map_resolution((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_map_resolution(const RPLight self, int resolution)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_shadow_map_resolution_44_comment =
  "C++ Interface:\n"
  "set_shadow_map_resolution(const RPLight self, int resolution)\n"
  "\n"
  "/**\n"
  " * @brief Sets the lights shadow map resolution\n"
  " * @details This sets the lights shadow map resolution. This has no effect\n"
  " *   when the light is not told to cast shadows (Use RPLight::set_casts_shadows).\n"
  " *\n"
  " *   When calling this on a light with multiple shadow sources (e.g. PointLight),\n"
  " *   this controls the resolution of each source. If the light has 6 shadow sources,\n"
  " *   and you use a resolution of 512x512, the lights shadow map will occur a\n"
  " *   space of 6 * 512x512 maps in the shadow atlas.\n"
  " *\n"
  " * @param resolution Resolution of the shadow map in pixels\n"
  " */";
#else
static const char *Dtool_RPLight_set_shadow_map_resolution_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline std::size_t RPLight::get_shadow_map_resolution(void) const
 *******************************************************************/
static PyObject *Dtool_RPLight_get_shadow_map_resolution_45(PyObject *self, PyObject *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t RPLight::get_shadow_map_resolution(void) const
  std::size_t return_value = (*(const RPLight*)local_this).get_shadow_map_resolution();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyLongOrInt_FromSize_t(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_shadow_map_resolution_45_comment =
  "C++ Interface:\n"
  "get_shadow_map_resolution(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the shadow map resolution\n"
  " * @details This returns the shadow map resolution of each source of the light.\n"
  " *   If the light is not setup to cast shadows, this value is meaningless.\n"
  " *   The returned value is the one previously set with RPLight::set_shadow_map_resolution.\n"
  " *\n"
  " * @return Shadow map resolution in pixels\n"
  " */";
#else
static const char *Dtool_RPLight_get_shadow_map_resolution_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPLight::set_ies_profile(int profile)
 *******************************************************************/
static PyObject *Dtool_RPLight_set_ies_profile_47(PyObject *self, PyObject *arg) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_ies_profile")) {
    return NULL;
  }
  // 1-inline void RPLight::set_ies_profile(int profile)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_ies_profile((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ies_profile(const RPLight self, int profile)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_ies_profile_47_comment =
  "C++ Interface:\n"
  "set_ies_profile(const RPLight self, int profile)\n"
  "\n"
  "/**\n"
  " * @brief Sets the ies profile\n"
  " * @details This sets the ies profile of the light. The parameter should be a\n"
  " *   handle previously returned by RenderPipeline.load_ies_profile. Using a\n"
  " *   value of -1 indicates no ies profile.\n"
  " *\n"
  " *   Notice that for ies profiles which cover a whole range, you should use\n"
  " *   PointLights, whereas for ies profiles which only cover the lower hemisphere\n"
  " *   you should use SpotLights for the best performance.\n"
  " *\n"
  " * @param profile IES Profile handle\n"
  " */";
#else
static const char *Dtool_RPLight_set_ies_profile_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int RPLight::get_ies_profile(void) const
 *******************************************************************/
static PyObject *Dtool_RPLight_get_ies_profile_48(PyObject *self, PyObject *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int RPLight::get_ies_profile(void) const
  int return_value = (*(const RPLight*)local_this).get_ies_profile();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyLongOrInt_FromLong(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_ies_profile_48_comment =
  "C++ Interface:\n"
  "get_ies_profile(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the lights ies profile\n"
  " * @details This returns the ies profile of a light, previously set with\n"
  " *   RPLight::set_ies_profile. In case no ies profile was set, returns -1.\n"
  " *\n"
  " * @return IES Profile handle\n"
  " */";
#else
static const char *Dtool_RPLight_get_ies_profile_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool RPLight::has_ies_profile(void) const
 *******************************************************************/
static PyObject *Dtool_RPLight_has_ies_profile_49(PyObject *self, PyObject *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool RPLight::has_ies_profile(void) const
  bool return_value = (*(const RPLight*)local_this).has_ies_profile();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_has_ies_profile_49_comment =
  "C++ Interface:\n"
  "has_ies_profile(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the light has an ies profile assigned\n"
  " * @details This returns whether the light has an ies profile assigned,\n"
  " *   previously done with RPLight::set_ies_profile.\n"
  " *\n"
  " * @return true if the light has an ies profile assigned, false otherwise\n"
  " */";
#else
static const char *Dtool_RPLight_has_ies_profile_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPLight::clear_ies_profile(void)
 *******************************************************************/
static PyObject *Dtool_RPLight_clear_ies_profile_50(PyObject *self, PyObject *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.clear_ies_profile")) {
    return NULL;
  }
  // 1-inline void RPLight::clear_ies_profile(void)
  (*local_this).clear_ies_profile();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RPLight_clear_ies_profile_50_comment =
  "C++ Interface:\n"
  "clear_ies_profile(const RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Clears the ies profile\n"
  " * @details This clears the ies profile of the light, telling it to no longer\n"
  " *   use an ies profile, and instead use the default attenuation.\n"
  " */";
#else
static const char *Dtool_RPLight_clear_ies_profile_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPLight::set_near_plane(float near_plane)
 *******************************************************************/
static PyObject *Dtool_RPLight_set_near_plane_53(PyObject *self, PyObject *arg) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_near_plane")) {
    return NULL;
  }
  // 1-inline void RPLight::set_near_plane(float near_plane)
  if (PyNumber_Check(arg)) {
    (*local_this).set_near_plane((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_near_plane(const RPLight self, float near_plane)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_near_plane_53_comment =
  "C++ Interface:\n"
  "set_near_plane(const RPLight self, float near_plane)\n"
  "\n"
  "/**\n"
  " * @brief Sets the near plane of the light\n"
  " * @details This sets the near plane of all shadow sources of the light. It has\n"
  " *   no effects if the light does not cast shadows. This prevents artifacts from\n"
  " *   objects near to the light. It behaves like Lens::set_near_plane.\n"
  " *\n"
  " *   It can also help increasing shadow map precision, low near planes will\n"
  " *   cause the precision to suffer. Try setting the near plane as big as possible.\n"
  " *\n"
  " *   If a negative or zero near plane is passed, an assertion is thrown.\n"
  " *\n"
  " * @param near_plane Near-plane\n"
  " */";
#else
static const char *Dtool_RPLight_set_near_plane_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RPLight::get_near_plane(void) const
 *******************************************************************/
static PyObject *Dtool_RPLight_get_near_plane_54(PyObject *self, PyObject *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float RPLight::get_near_plane(void) const
  float return_value = (*(const RPLight*)local_this).get_near_plane();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyFloat_FromDouble(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_near_plane_54_comment =
  "C++ Interface:\n"
  "get_near_plane(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the near plane of the light\n"
  " * @details This returns the lights near plane, previously set with\n"
  " *   RPLight::set_near_plane. If the light does not cast shadows, this value\n"
  " *   is meaningless.\n"
  " *\n"
  " * @return Near-plane\n"
  " */";
#else
static const char *Dtool_RPLight_get_near_plane_54_comment = NULL;
#endif

PyObject *Dtool_RPLight_pos_Getter(PyObject *self, void *) {
  const RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3f const &RPLight::get_pos(void) const
  LVecBase3f const *return_value = &((*(const RPLight*)local_this).get_pos());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

int Dtool_RPLight_pos_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.pos")) {
    return -1;
  }

  // 1-inline void RPLight::set_pos(LVecBase3f const &pos)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "RPLight.set_pos", "LVecBase3f");
    return -1;
  }
  (*local_this).set_pos(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pos(const RPLight self, const LVecBase3f pos)\n");
  }
  return -1;
}

PyObject *Dtool_RPLight_color_Getter(PyObject *self, void *) {
  const RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3f const &RPLight::get_color(void) const
  LVecBase3f const *return_value = &((*(const RPLight*)local_this).get_color());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

int Dtool_RPLight_color_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.color")) {
    return -1;
  }

  // 1-inline void RPLight::set_color(LVecBase3f const &color)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "RPLight.set_color", "LVecBase3f");
    return -1;
  }
  (*local_this).set_color(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_color(const RPLight self, const LVecBase3f color)\n");
  }
  return -1;
}

PyObject *Dtool_RPLight_lumens_Getter(PyObject *self, void *) {
  const RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float RPLight::get_lumens(void) const
  float return_value = (*(const RPLight*)local_this).get_lumens();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyFloat_FromDouble(return_value);
}

int Dtool_RPLight_lumens_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.lumens")) {
    return -1;
  }

  // 1-inline void RPLight::set_lumens(float lumens)
  if (PyNumber_Check(arg)) {
    (*local_this).set_lumens((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lumens(const RPLight self, float lumens)\n");
  }
  return -1;
}

PyObject *Dtool_RPLight_light_type_Getter(PyObject *self, void *) {
  const RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline RPLight::LightType RPLight::get_light_type(void) const
  RPLight::LightType return_value = (*(const RPLight*)local_this).get_light_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyLongOrInt_FromLong(return_value);
}

PyObject *Dtool_RPLight_casts_shadows_Getter(PyObject *self, void *) {
  const RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool RPLight::get_casts_shadows(void) const
  bool return_value = (*(const RPLight*)local_this).get_casts_shadows();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyBool_FromLong(return_value);
}

int Dtool_RPLight_casts_shadows_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.casts_shadows")) {
    return -1;
  }

  // 1-inline void RPLight::set_casts_shadows(bool flag)
  (*local_this).set_casts_shadows((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_casts_shadows(const RPLight self, bool flag)\n");
  }
  return -1;
}

PyObject *Dtool_RPLight_shadow_map_resolution_Getter(PyObject *self, void *) {
  const RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::size_t RPLight::get_shadow_map_resolution(void) const
  std::size_t return_value = (*(const RPLight*)local_this).get_shadow_map_resolution();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyLongOrInt_FromSize_t(return_value);
}

int Dtool_RPLight_shadow_map_resolution_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.shadow_map_resolution")) {
    return -1;
  }

  // 1-inline void RPLight::set_shadow_map_resolution(std::size_t resolution)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:set_shadow_map_resolution", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      PyErr_Format(PyExc_OverflowError,
                   "can't convert negative value %zd to size_t",
                   param1);
      return -1;
    }
#endif
    (*local_this).set_shadow_map_resolution((std::size_t)param1);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow_map_resolution(const RPLight self, int resolution)\n");
  }
  return -1;
}

PyObject *Dtool_RPLight_ies_profile_Getter(PyObject *self, void *) {
  const RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_ies_profile()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int RPLight::get_ies_profile(void) const
  int return_value = (*(const RPLight*)local_this).get_ies_profile();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyLongOrInt_FromLong(return_value);
}

int Dtool_RPLight_ies_profile_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.ies_profile")) {
    return -1;
  }

  if (arg == Py_None) {
    local_this->clear_ies_profile();
    return 0;
  }
  // 1-inline void RPLight::set_ies_profile(int profile)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_ies_profile((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_ies_profile(const RPLight self, int profile)\n");
  }
  return -1;
}

PyObject *Dtool_RPLight_near_plane_Getter(PyObject *self, void *) {
  const RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float RPLight::get_near_plane(void) const
  float return_value = (*(const RPLight*)local_this).get_near_plane();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyFloat_FromDouble(return_value);
}

int Dtool_RPLight_near_plane_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.near_plane")) {
    return -1;
  }

  // 1-inline void RPLight::set_near_plane(float near_plane)
  if (PyNumber_Check(arg)) {
    (*local_this).set_near_plane((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_near_plane(const RPLight self, float near_plane)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RPLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_RPLight) {
    printf("RPLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  RPLight *local_this = (RPLight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_RPLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_RPLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_RPLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RPLight*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. ShadowManager
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ShadowManager::set_max_updates(std::size_t max_updates)
 *******************************************************************/
static PyObject *Dtool_ShadowManager_set_max_updates_58(PyObject *self, PyObject *arg) {
  ShadowManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.set_max_updates")) {
    return NULL;
  }
  // 1-inline void ShadowManager::set_max_updates(std::size_t max_updates)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:set_max_updates", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_max_updates((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_updates(const ShadowManager self, int max_updates)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_set_max_updates_58_comment =
  "C++ Interface:\n"
  "set_max_updates(const ShadowManager self, int max_updates)\n"
  "\n"
  "/**\n"
  " * @brief Sets the maximum amount of updates per frame.\n"
  " * @details This controls the maximum amount of updated ShadowSources per frame.\n"
  " *   The ShadowManager will take the first <max_updates> ShadowSources, and\n"
  " *   generate shadow maps for them every frame. If there are more ShadowSources\n"
  " *   waiting to get updated than available updates, the sources are sorted by\n"
  " *   priority, and the update of the less important sources is delayed to the\n"
  " *   next frame.\n"
  " *\n"
  " *   If the update count is set too low, and there are a lot of ShadowSources\n"
  " *   waiting to get updated, artifacts will occur, and there might be ShadowSources\n"
  " *   which never get updated, due to low priority.\n"
  " *\n"
  " *   If an update count of 0 is passed, no updates will happen. This also means\n"
  " *   that there are no shadows. This is not recommended.\n"
  " *\n"
  " *   If an update count < 0 is passed, undefined behaviour occurs.\n"
  " *\n"
  " *   This method has to get called before ShadowManager::init, otherwise an\n"
  " *   assertion will get triggered.\n"
  " *\n"
  " * @param max_updates Maximum amoumt of updates\n"
  " */";
#else
static const char *Dtool_ShadowManager_set_max_updates_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ShadowManager::set_atlas_size(std::size_t atlas_size)
 *******************************************************************/
static PyObject *Dtool_ShadowManager_set_atlas_size_59(PyObject *self, PyObject *arg) {
  ShadowManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.set_atlas_size")) {
    return NULL;
  }
  // 1-inline void ShadowManager::set_atlas_size(std::size_t atlas_size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:set_atlas_size", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_atlas_size((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_atlas_size(const ShadowManager self, int atlas_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_set_atlas_size_59_comment =
  "C++ Interface:\n"
  "set_atlas_size(const ShadowManager self, int atlas_size)\n"
  "\n"
  "/**\n"
  " * @brief Sets the shadow atlas size\n"
  " * @details This sets the desired shadow atlas size. It should be big enough\n"
  " *   to store all important shadow sources, with some buffer, because the shadow\n"
  " *   maps usually won't be fitted perfectly, so gaps can occur.\n"
  " *\n"
  " *   This has to get called before calling ShadowManager::init. When calling this\n"
  " *   method after initialization, an assertion will get triggered.\n"
  " *\n"
  " * @param atlas_size Size of the shadow atlas in pixels\n"
  " */";
#else
static const char *Dtool_ShadowManager_set_atlas_size_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ShadowManager::set_scene(NodePath scene_parent)
 *******************************************************************/
static PyObject *Dtool_ShadowManager_set_scene_60(PyObject *self, PyObject *arg) {
  ShadowManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.set_scene")) {
    return NULL;
  }
  // 1-inline void ShadowManager::set_scene(NodePath scene_parent)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ShadowManager.set_scene", true, true);
  if (arg_this != NULL) {
    (*local_this).set_scene(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scene(const ShadowManager self, NodePath scene_parent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_set_scene_60_comment =
  "C++ Interface:\n"
  "set_scene(const ShadowManager self, NodePath scene_parent)\n"
  "\n"
  "/**\n"
  " * @brief Sets the target scene\n"
  " * @details This sets the target scene for rendering shadows. All shadow cameras\n"
  " *   will be parented to this scene to render shadows.\n"
  " *\n"
  " *   Usually the scene will be ShowBase.render. If the scene is an empty or\n"
  " *   invalid NodePath, an assertion will be triggered.\n"
  " *\n"
  " *   This method has to get called before calling ShadowManager::init, or an\n"
  " *   assertion will get triggered.\n"
  " *\n"
  " * @param scene_parent The target scene\n"
  " */";
#else
static const char *Dtool_ShadowManager_set_scene_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ShadowManager::set_tag_state_manager(TagStateManager *tag_mgr)
 *******************************************************************/
static PyObject *Dtool_ShadowManager_set_tag_state_manager_61(PyObject *self, PyObject *arg) {
  ShadowManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.set_tag_state_manager")) {
    return NULL;
  }
  // 1-inline void ShadowManager::set_tag_state_manager(TagStateManager *tag_mgr)
  TagStateManager *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_TagStateManager(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ShadowManager.set_tag_state_manager", "TagStateManager");
  }
  (*local_this).set_tag_state_manager(arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tag_state_manager(const ShadowManager self, TagStateManager tag_mgr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_set_tag_state_manager_61_comment =
  "C++ Interface:\n"
  "set_tag_state_manager(const ShadowManager self, TagStateManager tag_mgr)\n"
  "\n"
  "/**\n"
  " * @brief Sets the handle to the TagStageManager.\n"
  " * @details This sets the handle to the TagStateManager used by the pipeline.\n"
  " *   Usually this is RenderPipeline.get_tag_mgr().\n"
  " *\n"
  " *   This has to get called before ShadowManager::init, otherwise an assertion\n"
  " *   will get triggered.\n"
  " *\n"
  " * @param tag_mgr [description]\n"
  " */";
#else
static const char *Dtool_ShadowManager_set_tag_state_manager_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ShadowManager::set_atlas_graphics_output(GraphicsOutput *graphics_output)
 *******************************************************************/
static PyObject *Dtool_ShadowManager_set_atlas_graphics_output_62(PyObject *self, PyObject *arg) {
  ShadowManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.set_atlas_graphics_output")) {
    return NULL;
  }
  // 1-inline void ShadowManager::set_atlas_graphics_output(GraphicsOutput *graphics_output)
  GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 1, "ShadowManager.set_atlas_graphics_output", false, true);
  if (arg_this != NULL) {
    (*local_this).set_atlas_graphics_output(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_atlas_graphics_output(const ShadowManager self, GraphicsOutput graphics_output)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_set_atlas_graphics_output_62_comment =
  "C++ Interface:\n"
  "set_atlas_graphics_output(const ShadowManager self, GraphicsOutput graphics_output)\n"
  "\n"
  "/**\n"
  " * @brief Sets the handle to the Shadow targets output\n"
  " * @details This sets the handle to the GraphicsOutput of the shadow atlas.\n"
  " *   Usually this is RenderTarget.get_internal_buffer(), whereas the RenderTarget\n"
  " *   is the target of the ShadowStage.\n"
  " *\n"
  " *   This is used for creating display regions and attaching cameras to them,\n"
  " *   for performing shadow updates.\n"
  " *\n"
  " *   This has to get called before ShadowManager::init, otherwise an assertion\n"
  " *   will be triggered.\n"
  " *\n"
  " * @param graphics_output [description]\n"
  " */";
#else
static const char *Dtool_ShadowManager_set_atlas_graphics_output_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline std::size_t ShadowManager::get_atlas_size(void) const
 *******************************************************************/
static PyObject *Dtool_ShadowManager_get_atlas_size_63(PyObject *self, PyObject *) {
  ShadowManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShadowManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ShadowManager::get_atlas_size(void) const
  std::size_t return_value = (*(const ShadowManager*)local_this).get_atlas_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyLongOrInt_FromSize_t(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_get_atlas_size_63_comment =
  "C++ Interface:\n"
  "get_atlas_size(ShadowManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the shadow atlas size.\n"
  " * @details This returns the shadow atlas size previously set with\n"
  " *   ShadowManager::set_atlas_size.\n"
  " * @return Shadow atlas size in pixels\n"
  " */";
#else
static const char *Dtool_ShadowManager_get_atlas_size_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline std::size_t ShadowManager::get_num_update_slots_left(void) const
 *******************************************************************/
static PyObject *Dtool_ShadowManager_get_num_update_slots_left_64(PyObject *self, PyObject *) {
  ShadowManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShadowManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ShadowManager::get_num_update_slots_left(void) const
  std::size_t return_value = (*(const ShadowManager*)local_this).get_num_update_slots_left();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyLongOrInt_FromSize_t(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_get_num_update_slots_left_64_comment =
  "C++ Interface:\n"
  "get_num_update_slots_left(ShadowManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns how many update slots are left.\n"
  " * @details This returns how many update slots are left. You can assume the\n"
  " *   next n calls to add_update will succeed, whereas n is the value returned\n"
  " *   by this function.\n"
  " * @return Number of update slots left.\n"
  " */";
#else
static const char *Dtool_ShadowManager_get_num_update_slots_left_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ShadowManager::init(void)
 *******************************************************************/
static PyObject *Dtool_ShadowManager_init_65(PyObject *self, PyObject *) {
  ShadowManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.init")) {
    return NULL;
  }
  // 1-void ShadowManager::init(void)
  (*local_this).init();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_init_65_comment =
  "C++ Interface:\n"
  "init(const ShadowManager self)\n";
#else
static const char *Dtool_ShadowManager_init_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ShadowManager::update(void)
 *******************************************************************/
static PyObject *Dtool_ShadowManager_update_66(PyObject *self, PyObject *) {
  ShadowManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.update")) {
    return NULL;
  }
  // 1-void ShadowManager::update(void)
  (*local_this).update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_update_66_comment =
  "C++ Interface:\n"
  "update(const ShadowManager self)\n";
#else
static const char *Dtool_ShadowManager_update_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ShadowManager::ShadowManager(void)
 * inline ShadowManager::ShadowManager(ShadowManager const &) = default
 *******************************************************************/
static int Dtool_Init_ShadowManager(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ShadowManager::ShadowManager(void)
      ShadowManager *return_value = new ShadowManager();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShadowManager, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline ShadowManager::ShadowManager(ShadowManager const &) = default
      ShadowManager const *arg_this = (ShadowManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShadowManager, 0, "ShadowManager.ShadowManager", true, true);
      if (arg_this != NULL) {
        ShadowManager *return_value = new ShadowManager(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShadowManager, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ShadowManager() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShadowManager()\n"
      "ShadowManager(const ShadowManager param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ShadowManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ShadowManager) {
    printf("ShadowManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ShadowManager *local_this = (ShadowManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ShadowManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ShadowManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ShadowManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShadowManager*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. TagStateManager
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline BitMask32 TagStateManager::get_gbuffer_mask(void)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_get_gbuffer_mask_70(PyObject *, PyObject *) {
  // 1-static inline BitMask32 TagStateManager::get_gbuffer_mask(void)
  BitMask32 *return_value = new BitMask32(TagStateManager::get_gbuffer_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_PN_uint32_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_get_gbuffer_mask_70_comment =
  "C++ Interface:\n"
  "get_gbuffer_mask()\n"
  "\n"
  "/**\n"
  " * @brief Returns the bitmask used for rendering the default scene geometry.\n"
  " * @details This returns the bitmask which will be used for normal rendering.\n"
  " * @return Default bitmask\n"
  " */";
#else
static const char *Dtool_TagStateManager_get_gbuffer_mask_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask32 TagStateManager::get_voxelize_mask(void)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_get_voxelize_mask_71(PyObject *, PyObject *) {
  // 1-static inline BitMask32 TagStateManager::get_voxelize_mask(void)
  BitMask32 *return_value = new BitMask32(TagStateManager::get_voxelize_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_PN_uint32_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_get_voxelize_mask_71_comment =
  "C++ Interface:\n"
  "get_voxelize_mask()\n"
  "\n"
  "/**\n"
  " * @brief Returns the bitmask used for voxelization.\n"
  " * @details This returns the bitmask which will be used when voxelizing the scene.\n"
  " *   This is for example used for the Global Illumination.\n"
  " * @return Voxelize bitmask\n"
  " */";
#else
static const char *Dtool_TagStateManager_get_voxelize_mask_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask32 TagStateManager::get_shadow_mask(void)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_get_shadow_mask_72(PyObject *, PyObject *) {
  // 1-static inline BitMask32 TagStateManager::get_shadow_mask(void)
  BitMask32 *return_value = new BitMask32(TagStateManager::get_shadow_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_PN_uint32_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_get_shadow_mask_72_comment =
  "C++ Interface:\n"
  "get_shadow_mask()\n"
  "\n"
  "/**\n"
  " * @brief Returns the bitmask used for rendering shadows.\n"
  " * @details This returns the bitmask which will be used whenever rendering\n"
  " *   shadows, e.g. PSSM or regular shadow rendering.\n"
  " * @return Shadow bitmask\n"
  " */";
#else
static const char *Dtool_TagStateManager_get_shadow_mask_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline BitMask32 TagStateManager::get_envmap_mask(void)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_get_envmap_mask_73(PyObject *, PyObject *) {
  // 1-static inline BitMask32 TagStateManager::get_envmap_mask(void)
  BitMask32 *return_value = new BitMask32(TagStateManager::get_envmap_mask());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_PN_uint32_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_get_envmap_mask_73_comment =
  "C++ Interface:\n"
  "get_envmap_mask()\n"
  "\n"
  "/**\n"
  " * @brief Returns the bitmask used for environment maps.\n"
  " * @details This returns the bitmask which will be used when rendering environment\n"
  " *   cubemaps.\n"
  " * @return Environment bitmask\n"
  " */";
#else
static const char *Dtool_TagStateManager_get_envmap_mask_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TagStateManager::apply_shadow_state(NodePath np, Shader *shader, std::string const &name, int sort)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_apply_shadow_state_74(PyObject *self, PyObject *args, PyObject *kwds) {
  TagStateManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.apply_shadow_state")) {
    return NULL;
  }
  // 1-inline void TagStateManager::apply_shadow_state(NodePath np, Shader *shader, std::string const &name, int sort)
  PyObject *param1;
  PyObject *param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  int param4;
  static const char *keyword_list[] = {"np", "shader", "name", "sort", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#i:apply_shadow_state", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len, &param4)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "TagStateManager.apply_shadow_state", true, true);
    PT(Shader) param2_this;
    if (!Dtool_Coerce_Shader(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TagStateManager.apply_shadow_state", "Shader");
    }
    if (param1_this != NULL) {
      (*local_this).apply_shadow_state(*param1_this, MOVE(param2_this), std::string(param3_str, param3_len), (int)param4);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_shadow_state(const TagStateManager self, NodePath np, Shader shader, str name, int sort)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_apply_shadow_state_74_comment =
  "C++ Interface:\n"
  "apply_shadow_state(const TagStateManager self, NodePath np, Shader shader, str name, int sort)\n"
  "\n"
  "/**\n"
  " * @brief Applies a given shadow state to a NodePath\n"
  " * @details This applies a shader to the given NodePath which is used when the\n"
  " *   NodePath is rendered by any registered shadow camera to render shadows.\n"
  " *   It also disables color write (since its not required for shadows).\n"
  " *\n"
  " * @param np The nodepath to apply the shader to\n"
  " * @param shader A handle to the shader to apply\n"
  " * @param name Name of the state, should be a unique identifier\n"
  " * @param sort Determines the sort with which the shader will be applied.\n"
  " */";
#else
static const char *Dtool_TagStateManager_apply_shadow_state_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TagStateManager::apply_voxelize_state(NodePath np, Shader *shader, std::string const &name, int sort)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_apply_voxelize_state_75(PyObject *self, PyObject *args, PyObject *kwds) {
  TagStateManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.apply_voxelize_state")) {
    return NULL;
  }
  // 1-inline void TagStateManager::apply_voxelize_state(NodePath np, Shader *shader, std::string const &name, int sort)
  PyObject *param1;
  PyObject *param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  int param4;
  static const char *keyword_list[] = {"np", "shader", "name", "sort", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#i:apply_voxelize_state", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len, &param4)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "TagStateManager.apply_voxelize_state", true, true);
    PT(Shader) param2_this;
    if (!Dtool_Coerce_Shader(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TagStateManager.apply_voxelize_state", "Shader");
    }
    if (param1_this != NULL) {
      (*local_this).apply_voxelize_state(*param1_this, MOVE(param2_this), std::string(param3_str, param3_len), (int)param4);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_voxelize_state(const TagStateManager self, NodePath np, Shader shader, str name, int sort)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_apply_voxelize_state_75_comment =
  "C++ Interface:\n"
  "apply_voxelize_state(const TagStateManager self, NodePath np, Shader shader, str name, int sort)\n"
  "\n"
  "/**\n"
  " * @brief Applies a given voxelize state to a NodePath\n"
  " * @details This applies a shader to the given NodePath which is used when the\n"
  " *   NodePath is rendered by any registered voxelization camera to voxelize the\n"
  " *   scene. It also disables color write (since its not required for voxelization).\n"
  " *\n"
  " * @param np The nodepath to apply the shader to\n"
  " * @param shader A handle to the shader to apply\n"
  " * @param name Name of the state, should be a unique identifier\n"
  " * @param sort Determines the sort with which the shader will be applied.\n"
  " */";
#else
static const char *Dtool_TagStateManager_apply_voxelize_state_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TagStateManager::apply_envmap_state(NodePath np, Shader *shader, std::string const &name, int sort)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_apply_envmap_state_76(PyObject *self, PyObject *args, PyObject *kwds) {
  TagStateManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.apply_envmap_state")) {
    return NULL;
  }
  // 1-inline void TagStateManager::apply_envmap_state(NodePath np, Shader *shader, std::string const &name, int sort)
  PyObject *param1;
  PyObject *param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  int param4;
  static const char *keyword_list[] = {"np", "shader", "name", "sort", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#i:apply_envmap_state", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len, &param4)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "TagStateManager.apply_envmap_state", true, true);
    PT(Shader) param2_this;
    if (!Dtool_Coerce_Shader(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TagStateManager.apply_envmap_state", "Shader");
    }
    if (param1_this != NULL) {
      (*local_this).apply_envmap_state(*param1_this, MOVE(param2_this), std::string(param3_str, param3_len), (int)param4);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_envmap_state(const TagStateManager self, NodePath np, Shader shader, str name, int sort)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_apply_envmap_state_76_comment =
  "C++ Interface:\n"
  "apply_envmap_state(const TagStateManager self, NodePath np, Shader shader, str name, int sort)\n"
  "\n"
  "/**\n"
  " * @brief Applies a given environment state to a NodePath\n"
  " * @details This applies a shader to the given NodePath which is used when the\n"
  " *   NodePath is rendered by any registered environment camera to render an\n"
  " *   environment map.\n"
  " *\n"
  " * @param np The nodepath to apply the shader to\n"
  " * @param shader A handle to the shader to apply\n"
  " * @param name Name of the state, should be a unique identifier\n"
  " * @param sort Determines the sort with which the shader will be applied.\n"
  " */";
#else
static const char *Dtool_TagStateManager_apply_envmap_state_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void TagStateManager::cleanup_states(void)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_cleanup_states_77(PyObject *self, PyObject *) {
  TagStateManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.cleanup_states")) {
    return NULL;
  }
  // 1-void TagStateManager::cleanup_states(void)
  (*local_this).cleanup_states();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_cleanup_states_77_comment =
  "C++ Interface:\n"
  "cleanup_states(const TagStateManager self)\n";
#else
static const char *Dtool_TagStateManager_cleanup_states_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TagStateManager::register_shadow_camera(Camera *source)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_register_shadow_camera_78(PyObject *self, PyObject *arg) {
  TagStateManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.register_shadow_camera")) {
    return NULL;
  }
  // 1-inline void TagStateManager::register_shadow_camera(Camera *source)
  Camera *arg_this = (Camera *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Camera, 1, "TagStateManager.register_shadow_camera", false, true);
  if (arg_this != NULL) {
    (*local_this).register_shadow_camera(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_shadow_camera(const TagStateManager self, Camera source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_register_shadow_camera_78_comment =
  "C++ Interface:\n"
  "register_shadow_camera(const TagStateManager self, Camera source)\n"
  "\n"
  "/**\n"
  " * @brief Registers a new camera which renders shadows\n"
  " * @details This registers a new camera which will be used to render shadows\n"
  " *   somewhere else. The TagStateManager will keep track of the camera and\n"
  " *   applies all registered states onto the camera with Camera::set_tag_state.\n"
  " *   It also applies the shadow camera mask (TagStateManager::get_shadow_mask)\n"
  " *   to the camera, and sets an initial state to disable color write.\n"
  " *\n"
  " * @param source Camera which will be used to render shadows\n"
  " */";
#else
static const char *Dtool_TagStateManager_register_shadow_camera_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TagStateManager::unregister_shadow_camera(Camera *source)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_unregister_shadow_camera_79(PyObject *self, PyObject *arg) {
  TagStateManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.unregister_shadow_camera")) {
    return NULL;
  }
  // 1-inline void TagStateManager::unregister_shadow_camera(Camera *source)
  Camera *arg_this = (Camera *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Camera, 1, "TagStateManager.unregister_shadow_camera", false, true);
  if (arg_this != NULL) {
    (*local_this).unregister_shadow_camera(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unregister_shadow_camera(const TagStateManager self, Camera source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_unregister_shadow_camera_79_comment =
  "C++ Interface:\n"
  "unregister_shadow_camera(const TagStateManager self, Camera source)\n"
  "\n"
  "/**\n"
  " * @brief Unregisters a camera from the list of shadow cameras\n"
  " * @details This unregisters a camera from the list of shadows cameras. It also\n"
  " *   resets all tag states of the camera, and also its initial state.\n"
  " *\n"
  " * @param source Camera to unregister\n"
  " */";
#else
static const char *Dtool_TagStateManager_unregister_shadow_camera_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TagStateManager::register_voxelize_camera(Camera *source)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_register_voxelize_camera_80(PyObject *self, PyObject *arg) {
  TagStateManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.register_voxelize_camera")) {
    return NULL;
  }
  // 1-inline void TagStateManager::register_voxelize_camera(Camera *source)
  Camera *arg_this = (Camera *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Camera, 1, "TagStateManager.register_voxelize_camera", false, true);
  if (arg_this != NULL) {
    (*local_this).register_voxelize_camera(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_voxelize_camera(const TagStateManager self, Camera source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_register_voxelize_camera_80_comment =
  "C++ Interface:\n"
  "register_voxelize_camera(const TagStateManager self, Camera source)\n"
  "\n"
  "/**\n"
  " * @brief Registers a new camera for voxelization\n"
  " * @details This registers a new camera which will be used to voxelize the scene\n"
  " *   somewhere else. The TagStateManager will keep track of the camera and\n"
  " *   applies all registered states onto the camera with Camera::set_tag_state.\n"
  " *   It also applies the voxelize camera mask (TagStateManager::get_voxelize_mask)\n"
  " *   to the camera, and sets an initial state to disable color write.\n"
  " *\n"
  " * @param source Camera which will be used to render shadows\n"
  " */";
#else
static const char *Dtool_TagStateManager_register_voxelize_camera_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TagStateManager::unregister_voxelize_camera(Camera *source)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_unregister_voxelize_camera_81(PyObject *self, PyObject *arg) {
  TagStateManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.unregister_voxelize_camera")) {
    return NULL;
  }
  // 1-inline void TagStateManager::unregister_voxelize_camera(Camera *source)
  Camera *arg_this = (Camera *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Camera, 1, "TagStateManager.unregister_voxelize_camera", false, true);
  if (arg_this != NULL) {
    (*local_this).unregister_voxelize_camera(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unregister_voxelize_camera(const TagStateManager self, Camera source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_unregister_voxelize_camera_81_comment =
  "C++ Interface:\n"
  "unregister_voxelize_camera(const TagStateManager self, Camera source)\n"
  "\n"
  "/**\n"
  " * @brief Unregisters a camera from the list of voxelization cameras\n"
  " * @details This unregisters a camera from the list of voxelization cameras. It also\n"
  " *   resets all tag states of the camera, and also its initial state.\n"
  " *\n"
  " * @param source Camera to unregister\n"
  " */";
#else
static const char *Dtool_TagStateManager_unregister_voxelize_camera_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TagStateManager::register_envmap_camera(Camera *source)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_register_envmap_camera_82(PyObject *self, PyObject *arg) {
  TagStateManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.register_envmap_camera")) {
    return NULL;
  }
  // 1-inline void TagStateManager::register_envmap_camera(Camera *source)
  Camera *arg_this = (Camera *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Camera, 1, "TagStateManager.register_envmap_camera", false, true);
  if (arg_this != NULL) {
    (*local_this).register_envmap_camera(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_envmap_camera(const TagStateManager self, Camera source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_register_envmap_camera_82_comment =
  "C++ Interface:\n"
  "register_envmap_camera(const TagStateManager self, Camera source)\n"
  "\n"
  "/**\n"
  " * @brief Registers a new camera for environment map\n"
  " * @details This registers a new camera which will be used when rendering environment\n"
  " *   map. The TagStateManager will keep track of the camera and applies all registered\n"
  " *   tates onto the camera with Camera::set_tag_state.\n"
  " *   It also applies the envmap camera mask (TagStateManager::get_envmap_mask)\n"
  " *   to the camera.\n"
  " *\n"
  " * @param source Camera which will be used to render shadows\n"
  " */";
#else
static const char *Dtool_TagStateManager_register_envmap_camera_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void TagStateManager::unregister_envmap_camera(Camera *source)
 *******************************************************************/
static PyObject *Dtool_TagStateManager_unregister_envmap_camera_83(PyObject *self, PyObject *arg) {
  TagStateManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.unregister_envmap_camera")) {
    return NULL;
  }
  // 1-inline void TagStateManager::unregister_envmap_camera(Camera *source)
  Camera *arg_this = (Camera *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Camera, 1, "TagStateManager.unregister_envmap_camera", false, true);
  if (arg_this != NULL) {
    (*local_this).unregister_envmap_camera(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unregister_envmap_camera(const TagStateManager self, Camera source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_unregister_envmap_camera_83_comment =
  "C++ Interface:\n"
  "unregister_envmap_camera(const TagStateManager self, Camera source)\n"
  "\n"
  "/**\n"
  " * @brief Unregisters a camera from the list of environment map cameras\n"
  " * @details This unregisters a camera from the list of environment map cameras. It also\n"
  " *   resets all tag states of the camera, and also its initial state.\n"
  " *\n"
  " * @param source Camera to unregister\n"
  " */";
#else
static const char *Dtool_TagStateManager_unregister_envmap_camera_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TagStateManager::TagStateManager(NodePath main_cam_node)
 * inline TagStateManager::TagStateManager(TagStateManager const &) = default
 *******************************************************************/
static int Dtool_Init_TagStateManager(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TagStateManager() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline TagStateManager::TagStateManager(TagStateManager const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:TagStateManager", (char **)keyword_list, &param0)) {
      TagStateManager const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TagStateManager, (void **)&param0_this);
      if (param0_this != NULL) {
        TagStateManager *return_value = new TagStateManager(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TagStateManager, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 TagStateManager::TagStateManager(NodePath main_cam_node)
    PyObject *param0;
    static const char *keyword_list[] = {"main_cam_node", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:TagStateManager", (char **)keyword_list, &param0)) {
      NodePath *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_NodePath, (void **)&param0_this);
      if (param0_this != NULL) {
        TagStateManager *return_value = new TagStateManager(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TagStateManager, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline TagStateManager::TagStateManager(TagStateManager const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:TagStateManager", (char **)keyword_list, &param0)) {
      TagStateManager const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_TagStateManager(param0, param0_this, param0_manage)) {
        TagStateManager *return_value = new TagStateManager(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TagStateManager, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: TagStateManager::TagStateManager(NodePath main_cam_node)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TagStateManager(const TagStateManager param0)\n"
      "TagStateManager(NodePath main_cam_node)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_TagStateManager(PyObject *args, TagStateManager const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TagStateManager, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-TagStateManager::TagStateManager(NodePath main_cam_node)
    NodePath *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      TagStateManager *return_value = new TagStateManager(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_TagStateManager(PyObject *args, TagStateManager *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TagStateManager, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-TagStateManager::TagStateManager(NodePath main_cam_node)
    NodePath *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_NodePath, (void **)&arg_this);
    if (arg_this != NULL) {
      TagStateManager *return_value = new TagStateManager(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_TagStateManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TagStateManager) {
    printf("TagStateManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TagStateManager *local_this = (TagStateManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TagStateManager) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TagStateManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TagStateManager) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. IESDataset
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void IESDataset::set_vertical_angles(PTA_float const &vertical_angles)
 *******************************************************************/
static PyObject *Dtool_IESDataset_set_vertical_angles_86(PyObject *self, PyObject *arg) {
  IESDataset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IESDataset, (void **)&local_this, "IESDataset.set_vertical_angles")) {
    return NULL;
  }
  // 1-void IESDataset::set_vertical_angles(PTA_float const &vertical_angles)
  PointerToArray< float > arg_local;
  PTA_float const *arg_this = Dtool_Coerce_PointerToArray_float(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "IESDataset.set_vertical_angles", "PointerToArray");
  }
  (*local_this).set_vertical_angles(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertical_angles(const IESDataset self, const PointerToArray vertical_angles)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_IESDataset_set_vertical_angles_86_comment =
  "C++ Interface:\n"
  "set_vertical_angles(const IESDataset self, const PointerToArray vertical_angles)\n";
#else
static const char *Dtool_IESDataset_set_vertical_angles_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void IESDataset::set_horizontal_angles(PTA_float const &horizontal_angles)
 *******************************************************************/
static PyObject *Dtool_IESDataset_set_horizontal_angles_87(PyObject *self, PyObject *arg) {
  IESDataset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IESDataset, (void **)&local_this, "IESDataset.set_horizontal_angles")) {
    return NULL;
  }
  // 1-void IESDataset::set_horizontal_angles(PTA_float const &horizontal_angles)
  PointerToArray< float > arg_local;
  PTA_float const *arg_this = Dtool_Coerce_PointerToArray_float(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "IESDataset.set_horizontal_angles", "PointerToArray");
  }
  (*local_this).set_horizontal_angles(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_horizontal_angles(const IESDataset self, const PointerToArray horizontal_angles)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_IESDataset_set_horizontal_angles_87_comment =
  "C++ Interface:\n"
  "set_horizontal_angles(const IESDataset self, const PointerToArray horizontal_angles)\n";
#else
static const char *Dtool_IESDataset_set_horizontal_angles_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void IESDataset::set_candela_values(PTA_float const &candela_values)
 *******************************************************************/
static PyObject *Dtool_IESDataset_set_candela_values_88(PyObject *self, PyObject *arg) {
  IESDataset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IESDataset, (void **)&local_this, "IESDataset.set_candela_values")) {
    return NULL;
  }
  // 1-void IESDataset::set_candela_values(PTA_float const &candela_values)
  PointerToArray< float > arg_local;
  PTA_float const *arg_this = Dtool_Coerce_PointerToArray_float(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "IESDataset.set_candela_values", "PointerToArray");
  }
  (*local_this).set_candela_values(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_candela_values(const IESDataset self, const PointerToArray candela_values)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_IESDataset_set_candela_values_88_comment =
  "C++ Interface:\n"
  "set_candela_values(const IESDataset self, const PointerToArray candela_values)\n";
#else
static const char *Dtool_IESDataset_set_candela_values_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void IESDataset::generate_dataset_texture_into(Texture *dest_tex, std::size_t z) const
 *******************************************************************/
static PyObject *Dtool_IESDataset_generate_dataset_texture_into_89(PyObject *self, PyObject *args, PyObject *kwds) {
  IESDataset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IESDataset, (void **)&local_this)) {
    return NULL;
  }
  // 1-void IESDataset::generate_dataset_texture_into(Texture *dest_tex, std::size_t z) const
  PyObject *param1;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"dest_tex", "z", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "On:generate_dataset_texture_into", (char **)keyword_list, &param1, &param2)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "IESDataset.generate_dataset_texture_into", false, true);
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const IESDataset*)local_this).generate_dataset_texture_into(param1_this, (std::size_t)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generate_dataset_texture_into(IESDataset self, Texture dest_tex, int z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_IESDataset_generate_dataset_texture_into_89_comment =
  "C++ Interface:\n"
  "generate_dataset_texture_into(IESDataset self, Texture dest_tex, int z)\n";
#else
static const char *Dtool_IESDataset_generate_dataset_texture_into_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * IESDataset::IESDataset(void)
 * inline IESDataset::IESDataset(IESDataset const &) = default
 *******************************************************************/
static int Dtool_Init_IESDataset(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-IESDataset::IESDataset(void)
      IESDataset *return_value = new IESDataset();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IESDataset, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline IESDataset::IESDataset(IESDataset const &) = default
      IESDataset const *arg_this = (IESDataset *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_IESDataset, 0, "IESDataset.IESDataset", true, true);
      if (arg_this != NULL) {
        IESDataset *return_value = new IESDataset(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IESDataset, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "IESDataset() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IESDataset()\n"
      "IESDataset(const IESDataset param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_IESDataset(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_IESDataset) {
    printf("IESDataset ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  IESDataset *local_this = (IESDataset *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_IESDataset) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_IESDataset(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_IESDataset) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. ShadowAtlas
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline ShadowAtlas::ShadowAtlas(ShadowAtlas const &) = default
 * ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size = 32)
 *******************************************************************/
static int Dtool_Init_ShadowAtlas(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size = 32)
    Py_ssize_t param0;
    Py_ssize_t param1 = 32;
    static const char *keyword_list[] = {"size", "tile_size", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "n|n:ShadowAtlas", (char **)keyword_list, &param0, &param1)) {
#ifndef NDEBUG
      if (param0 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param0);
        return -1;
      }
#endif
#ifndef NDEBUG
      if (param1 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param1);
        return -1;
      }
#endif
      ShadowAtlas *return_value = new ShadowAtlas((std::size_t)param0, (std::size_t)param1);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShadowAtlas, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size = 32)
  {
    // -2 inline ShadowAtlas::ShadowAtlas(ShadowAtlas const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ShadowAtlas", (char **)keyword_list, &param0)) {
      ShadowAtlas const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_ShadowAtlas(param0, param0_this, param0_manage)) {
        ShadowAtlas *return_value = new ShadowAtlas(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShadowAtlas, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShadowAtlas(int size, int tile_size)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ShadowAtlas(PyObject *args, ShadowAtlas const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ShadowAtlas, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size)
    Py_ssize_t param0;
    if (PyArg_Parse(arg, "n:ShadowAtlas", &param0)) {
#ifndef NDEBUG
      if (param0 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param0);
        return false;
      }
#endif
      ShadowAtlas *return_value = new ShadowAtlas((std::size_t)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size)
      Py_ssize_t param0;
      Py_ssize_t param1;
      if (PyArg_ParseTuple(args, "nn:ShadowAtlas", &param0, &param1)) {
#ifndef NDEBUG
        if (param0 < 0) {
          PyErr_Format(PyExc_OverflowError,
                       "can't convert negative value %zd to size_t",
                       param0);
          return false;
        }
#endif
#ifndef NDEBUG
        if (param1 < 0) {
          PyErr_Format(PyExc_OverflowError,
                       "can't convert negative value %zd to size_t",
                       param1);
          return false;
        }
#endif
        ShadowAtlas *return_value = new ShadowAtlas((std::size_t)param0, (std::size_t)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ShadowAtlas(PyObject *args, ShadowAtlas *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ShadowAtlas, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size)
    Py_ssize_t param0;
    if (PyArg_Parse(arg, "n:ShadowAtlas", &param0)) {
#ifndef NDEBUG
      if (param0 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param0);
        return false;
      }
#endif
      ShadowAtlas *return_value = new ShadowAtlas((std::size_t)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size)
      Py_ssize_t param0;
      Py_ssize_t param1;
      if (PyArg_ParseTuple(args, "nn:ShadowAtlas", &param0, &param1)) {
#ifndef NDEBUG
        if (param0 < 0) {
          PyErr_Format(PyExc_OverflowError,
                       "can't convert negative value %zd to size_t",
                       param0);
          return false;
        }
#endif
#ifndef NDEBUG
        if (param1 < 0) {
          PyErr_Format(PyExc_OverflowError,
                       "can't convert negative value %zd to size_t",
                       param1);
          return false;
        }
#endif
        ShadowAtlas *return_value = new ShadowAtlas((std::size_t)param0, (std::size_t)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ShadowAtlas(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ShadowAtlas) {
    printf("ShadowAtlas ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ShadowAtlas *local_this = (ShadowAtlas *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ShadowAtlas) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ShadowAtlas(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ShadowAtlas) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. InternalLightManager
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void InternalLightManager::add_light(PointerTo< RPLight > light)
 *******************************************************************/
static PyObject *Dtool_InternalLightManager_add_light_96(PyObject *self, PyObject *arg) {
  InternalLightManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.add_light")) {
    return NULL;
  }
  // 1-void InternalLightManager::add_light(PointerTo< RPLight > light)
  RPLight *arg_this = (RPLight *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RPLight, 1, "InternalLightManager.add_light", false, true);
  if (arg_this != NULL) {
    (*local_this).add_light(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_light(const InternalLightManager self, RPLight light)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_add_light_96_comment =
  "C++ Interface:\n"
  "add_light(const InternalLightManager self, RPLight light)\n";
#else
static const char *Dtool_InternalLightManager_add_light_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void InternalLightManager::remove_light(PointerTo< RPLight > light)
 *******************************************************************/
static PyObject *Dtool_InternalLightManager_remove_light_97(PyObject *self, PyObject *arg) {
  InternalLightManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.remove_light")) {
    return NULL;
  }
  // 1-void InternalLightManager::remove_light(PointerTo< RPLight > light)
  RPLight *arg_this = (RPLight *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RPLight, 1, "InternalLightManager.remove_light", false, true);
  if (arg_this != NULL) {
    (*local_this).remove_light(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_light(const InternalLightManager self, RPLight light)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_remove_light_97_comment =
  "C++ Interface:\n"
  "remove_light(const InternalLightManager self, RPLight light)\n";
#else
static const char *Dtool_InternalLightManager_remove_light_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void InternalLightManager::update(void)
 *******************************************************************/
static PyObject *Dtool_InternalLightManager_update_98(PyObject *self, PyObject *) {
  InternalLightManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.update")) {
    return NULL;
  }
  // 1-void InternalLightManager::update(void)
  (*local_this).update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_update_98_comment =
  "C++ Interface:\n"
  "update(const InternalLightManager self)\n";
#else
static const char *Dtool_InternalLightManager_update_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int InternalLightManager::get_max_light_index(void) const
 *******************************************************************/
static PyObject *Dtool_InternalLightManager_get_max_light_index_99(PyObject *self, PyObject *) {
  InternalLightManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalLightManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int InternalLightManager::get_max_light_index(void) const
  int return_value = (*(const InternalLightManager*)local_this).get_max_light_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyLongOrInt_FromLong(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_get_max_light_index_99_comment =
  "C++ Interface:\n"
  "get_max_light_index(InternalLightManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the maximum light index\n"
  " * @details This returns the maximum light index (also called slot). Any lights\n"
  " *   after that slot are guaranteed to be zero-lights. This is useful when\n"
  " *   iterating over the list of lights, because iteration can be stopped when\n"
  " *   the maximum light index is reached.\n"
  " *\n"
  " *   The maximum light index points to the last slot which is used. If no lights\n"
  " *   are attached, -1 is returned. If one light is attached at slot 0, the index\n"
  " *   is 0, if two are attached at the slots 0 and 1, the index is 1, and so on.\n"
  " *\n"
  " *   If, for example, two lights are attached at the slots 2 and 5, then the\n"
  " *   index will be 5. Keep in mind that the max-index is not an indicator for\n"
  " *   how many lights are attached. Also, zero lights still may occur when iterating\n"
  " *   over the light lists\n"
  " *\n"
  " * @return Maximum light index\n"
  " */";
#else
static const char *Dtool_InternalLightManager_get_max_light_index_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline std::size_t InternalLightManager::get_num_lights(void) const
 *******************************************************************/
static PyObject *Dtool_InternalLightManager_get_num_lights_100(PyObject *self, PyObject *) {
  InternalLightManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalLightManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t InternalLightManager::get_num_lights(void) const
  std::size_t return_value = (*(const InternalLightManager*)local_this).get_num_lights();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyLongOrInt_FromSize_t(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_get_num_lights_100_comment =
  "C++ Interface:\n"
  "get_num_lights(InternalLightManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the amount of stored lights.\n"
  " * @details This returns the amount of stored lights. This behaves unlike\n"
  " *   InternalLightManager::get_max_light_index, and instead returns the true\n"
  " *   amount of lights, which is completely unrelated to the amount of used slots.\n"
  " *\n"
  " * @return Amount of stored lights\n"
  " */";
#else
static const char *Dtool_InternalLightManager_get_num_lights_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline std::size_t InternalLightManager::get_num_shadow_sources(void) const
 *******************************************************************/
static PyObject *Dtool_InternalLightManager_get_num_shadow_sources_101(PyObject *self, PyObject *) {
  InternalLightManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalLightManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t InternalLightManager::get_num_shadow_sources(void) const
  std::size_t return_value = (*(const InternalLightManager*)local_this).get_num_shadow_sources();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyLongOrInt_FromSize_t(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_get_num_shadow_sources_101_comment =
  "C++ Interface:\n"
  "get_num_shadow_sources(InternalLightManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the amount of shadow sources.\n"
  " * @details This returns the total amount of stored shadow sources. This does\n"
  " *   not denote the amount of updated sources, but instead takes into account\n"
  " *   all sources, even those out of frustum.\n"
  " * @return Amount of shadow sources.\n"
  " */";
#else
static const char *Dtool_InternalLightManager_get_num_shadow_sources_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void InternalLightManager::set_command_list(GPUCommandList *cmd_list)
 *******************************************************************/
static PyObject *Dtool_InternalLightManager_set_command_list_102(PyObject *self, PyObject *arg) {
  InternalLightManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.set_command_list")) {
    return NULL;
  }
  // 1-inline void InternalLightManager::set_command_list(GPUCommandList *cmd_list)
  GPUCommandList *arg_this = (GPUCommandList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GPUCommandList, 1, "InternalLightManager.set_command_list", false, true);
  if (arg_this != NULL) {
    (*local_this).set_command_list(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_command_list(const InternalLightManager self, GPUCommandList cmd_list)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_set_command_list_102_comment =
  "C++ Interface:\n"
  "set_command_list(const InternalLightManager self, GPUCommandList cmd_list)\n"
  "\n"
  "/**\n"
  " * @brief Sets a handle to the command list\n"
  " * @details This sets a handle to the global GPUCommandList. This is required to\n"
  " *   emit GPUCommands, which are used for attaching and detaching lights, as well\n"
  " *   as shadow source updates.\n"
  " *\n"
  " *   The cmd_list should be a handle to a GPUCommandList handle, and will be\n"
  " *   stored somewhere on the python side most likely. The light manager does not\n"
  " *   keep a reference to it, so the python side should make sure to keep one.\n"
  " *\n"
  " *   Be sure to call this before the InternalLightManager::update() method is\n"
  " *   called, otherwise an assertion will get triggered.\n"
  " *\n"
  " * @param cmd_list The GPUCommandList instance\n"
  " */";
#else
static const char *Dtool_InternalLightManager_set_command_list_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void InternalLightManager::set_shadow_manager(ShadowManager *mgr)
 *******************************************************************/
static PyObject *Dtool_InternalLightManager_set_shadow_manager_103(PyObject *self, PyObject *arg) {
  InternalLightManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.set_shadow_manager")) {
    return NULL;
  }
  // 1-inline void InternalLightManager::set_shadow_manager(ShadowManager *mgr)
  ShadowManager *arg_this = (ShadowManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShadowManager, 1, "InternalLightManager.set_shadow_manager", false, true);
  if (arg_this != NULL) {
    (*local_this).set_shadow_manager(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_manager(const InternalLightManager self, ShadowManager mgr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_set_shadow_manager_103_comment =
  "C++ Interface:\n"
  "set_shadow_manager(const InternalLightManager self, ShadowManager mgr)\n"
  "\n"
  "/**\n"
  " * @brief Sets the handle to the shadow manager\n"
  " * @details This sets the handle to the global shadow manager. It is usually\n"
  " *   constructed on the python side, so we need to get a handle to it.\n"
  " *\n"
  " *   The manager should be a handle to a ShadowManager instance, and will be\n"
  " *   stored somewhere on the python side most likely. The light manager does not\n"
  " *   keep a reference to it, so the python side should make sure to keep one.\n"
  " *\n"
  " *   Be sure to call this before the InternalLightManager::update() method is\n"
  " *   called, otherwise an assertion will get triggered.\n"
  " *\n"
  " * @param mgr The ShadowManager instance\n"
  " */";
#else
static const char *Dtool_InternalLightManager_set_shadow_manager_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * InternalLightManager::InternalLightManager(void)
 * inline InternalLightManager::InternalLightManager(InternalLightManager const &) = default
 *******************************************************************/
static int Dtool_Init_InternalLightManager(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-InternalLightManager::InternalLightManager(void)
      InternalLightManager *return_value = new InternalLightManager();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InternalLightManager, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline InternalLightManager::InternalLightManager(InternalLightManager const &) = default
      InternalLightManager const *arg_this = (InternalLightManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InternalLightManager, 0, "InternalLightManager.InternalLightManager", true, true);
      if (arg_this != NULL) {
        InternalLightManager *return_value = new InternalLightManager(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InternalLightManager, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "InternalLightManager() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "InternalLightManager()\n"
      "InternalLightManager(const InternalLightManager param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_InternalLightManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_InternalLightManager) {
    printf("InternalLightManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  InternalLightManager *local_this = (InternalLightManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_InternalLightManager) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_InternalLightManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_InternalLightManager) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. PSSMCameraRig
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PSSMCameraRig::set_pssm_distance(float distance)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_set_pssm_distance_108(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_pssm_distance")) {
    return NULL;
  }
  // 1-inline void PSSMCameraRig::set_pssm_distance(float distance)
  if (PyNumber_Check(arg)) {
    (*local_this).set_pssm_distance((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pssm_distance(const PSSMCameraRig self, float distance)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_pssm_distance_108_comment =
  "C++ Interface:\n"
  "set_pssm_distance(const PSSMCameraRig self, float distance)\n"
  "\n"
  "/**\n"
  " * @brief Sets the maximum pssm distance.\n"
  " * @details This sets the maximum distance in world space until which shadows\n"
  " *   are rendered. After this distance, no shadows will be rendered.\n"
  " *\n"
  " *   If the distance is below zero, an assertion is triggered.\n"
  " *\n"
  " * @param distance Maximum distance in world space\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_pssm_distance_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PSSMCameraRig::set_sun_distance(float distance)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_set_sun_distance_109(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_sun_distance")) {
    return NULL;
  }
  // 1-inline void PSSMCameraRig::set_sun_distance(float distance)
  if (PyNumber_Check(arg)) {
    (*local_this).set_sun_distance((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sun_distance(const PSSMCameraRig self, float distance)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_sun_distance_109_comment =
  "C++ Interface:\n"
  "set_sun_distance(const PSSMCameraRig self, float distance)\n"
  "\n"
  "/**\n"
  " * @brief Sets the suns distance\n"
  " * @details This sets the distance the cameras will have from the cameras frustum.\n"
  " *   This prevents far objects from having no shadows, which can occur when these\n"
  " *   objects are between the cameras frustum and the sun, but not inside of the\n"
  " *   cameras frustum. Setting the sun distance high enough will move the cameras\n"
  " *   away from the camera frustum, being able to cover those distant objects too.\n"
  " *\n"
  " *   If the sun distance is set too high, artifacts will occur due to the reduced\n"
  " *   range of depth. If a value below zero is passed, an assertion will get\n"
  " *   triggered.\n"
  " *\n"
  " * @param distance The sun distance\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_sun_distance_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PSSMCameraRig::set_use_fixed_film_size(bool flag)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_set_use_fixed_film_size_110(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_use_fixed_film_size")) {
    return NULL;
  }
  // 1-inline void PSSMCameraRig::set_use_fixed_film_size(bool flag)
  (*local_this).set_use_fixed_film_size((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_fixed_film_size(const PSSMCameraRig self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_use_fixed_film_size_110_comment =
  "C++ Interface:\n"
  "set_use_fixed_film_size(const PSSMCameraRig self, bool flag)\n"
  "\n"
  "/**\n"
  " * @brief Sets whether to use a fixed film size\n"
  " * @details This controls if a fixed film size should be used. This will cause\n"
  " *   the camera rig to cache the current film size, and only change it in case\n"
  " *   it gets too small. This provides less flickering when moving, because the\n"
  " *   film size will stay roughly constant. However, to prevent the cached film\n"
  " *   size getting too big, one should call PSSMCameraRig::reset_film_size\n"
  " *   once in a while, otherwise there might be a lot of wasted space.\n"
  " *\n"
  " * @param flag Whether to use a fixed film size\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_use_fixed_film_size_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PSSMCameraRig::set_resolution(std::size_t resolution)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_set_resolution_111(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_resolution")) {
    return NULL;
  }
  // 1-inline void PSSMCameraRig::set_resolution(std::size_t resolution)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:set_resolution", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_resolution((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_resolution(const PSSMCameraRig self, int resolution)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_resolution_111_comment =
  "C++ Interface:\n"
  "set_resolution(const PSSMCameraRig self, int resolution)\n"
  "\n"
  "/**\n"
  " * @brief Sets the resolution of each split\n"
  " * @details This sets the resolution of each split. Currently it is equal for\n"
  " *   each split. This is required when using PSSMCameraRig::set_use_stable_csm,\n"
  " *   to compute how bix a texel is.\n"
  " *\n"
  " *   It has to match the y-resolution of the pssm shadow map. If an invalid\n"
  " *   resolution is triggered, an assertion is thrown.\n"
  " *\n"
  " * @param resolution The resolution of each split.\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_resolution_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PSSMCameraRig::set_use_stable_csm(bool flag)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_set_use_stable_csm_112(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_use_stable_csm")) {
    return NULL;
  }
  // 1-inline void PSSMCameraRig::set_use_stable_csm(bool flag)
  (*local_this).set_use_stable_csm((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_stable_csm(const PSSMCameraRig self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_use_stable_csm_112_comment =
  "C++ Interface:\n"
  "set_use_stable_csm(const PSSMCameraRig self, bool flag)\n"
  "\n"
  "/**\n"
  " * @brief Sets whether to use stable CSM snapping.\n"
  " * @details This option controls if stable CSM snapping should be used. When the\n"
  " *   option is enabled, all splits will snap to their texels, so that when moving,\n"
  " *   no flickering will occur. However, this only works when the splits do not\n"
  " *   change their film size, rotation and angle.\n"
  " *\n"
  " * @param flag Whether to use stable CSM snapping\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_use_stable_csm_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PSSMCameraRig::set_logarithmic_factor(float factor)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_set_logarithmic_factor_113(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_logarithmic_factor")) {
    return NULL;
  }
  // 1-inline void PSSMCameraRig::set_logarithmic_factor(float factor)
  if (PyNumber_Check(arg)) {
    (*local_this).set_logarithmic_factor((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_logarithmic_factor(const PSSMCameraRig self, float factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_logarithmic_factor_113_comment =
  "C++ Interface:\n"
  "set_logarithmic_factor(const PSSMCameraRig self, float factor)\n"
  "\n"
  "/**\n"
  " * @brief Sets the logarithmic factor\n"
  " * @details This sets the logarithmic factor, which is the core of the algorithm.\n"
  " *   PSSM splits the camera frustum based on a linear and a logarithmic factor.\n"
  " *   While a linear factor provides a good distribution, it often is not applicable\n"
  " *   for wider distances. A logarithmic distribution provides a better distribution\n"
  " *   at distance, but suffers from splitting in the near areas.\n"
  " *\n"
  " *   The logarithmic factor mixes the logarithmic and linear split distribution,\n"
  " *   to get the best of both. A greater factor will make the distribution more\n"
  " *   logarithmic, while a smaller factor will make it more linear.\n"
  " *\n"
  " *   If the factor is below zero, an ssertion is triggered.\n"
  " *\n"
  " * @param factor The logarithmic factor\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_logarithmic_factor_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PSSMCameraRig::set_border_bias(float bias)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_set_border_bias_114(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_border_bias")) {
    return NULL;
  }
  // 1-inline void PSSMCameraRig::set_border_bias(float bias)
  if (PyNumber_Check(arg)) {
    (*local_this).set_border_bias((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_border_bias(const PSSMCameraRig self, float bias)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_border_bias_114_comment =
  "C++ Interface:\n"
  "set_border_bias(const PSSMCameraRig self, float bias)\n"
  "\n"
  "/**\n"
  " * @brief Sets the border bias for each split\n"
  " * @details This sets the border bias for every split. This increases each\n"
  " *   splits frustum by multiplying it by (1 + bias), and helps reducing artifacts\n"
  " *   at the borders of the splits. Artifacts can occur when the bias is too low,\n"
  " *   because then the filtering will go over the bounds of the split, producing\n"
  " *   invalid results.\n"
  " *\n"
  " *   If the bias is below zero, an assertion is thrown.\n"
  " *\n"
  " * @param bias Border bias\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_border_bias_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PSSMCameraRig::update(NodePath cam_node, LVecBase3f const &light_vector)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_update_115(PyObject *self, PyObject *args, PyObject *kwds) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.update")) {
    return NULL;
  }
  // 1-void PSSMCameraRig::update(NodePath cam_node, LVecBase3f const &light_vector)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"cam_node", "light_vector", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:update", (char **)keyword_list, &param1, &param2)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "PSSMCameraRig.update", true, true);
    LVecBase3f param2_local;
    LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PSSMCameraRig.update", "LVecBase3f");
    }
    if (param1_this != NULL) {
      (*local_this).update(*param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update(const PSSMCameraRig self, NodePath cam_node, const LVecBase3f light_vector)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_update_115_comment =
  "C++ Interface:\n"
  "update(const PSSMCameraRig self, NodePath cam_node, const LVecBase3f light_vector)\n";
#else
static const char *Dtool_PSSMCameraRig_update_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PSSMCameraRig::reset_film_size_cache(void)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_reset_film_size_cache_116(PyObject *self, PyObject *) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.reset_film_size_cache")) {
    return NULL;
  }
  // 1-inline void PSSMCameraRig::reset_film_size_cache(void)
  (*local_this).reset_film_size_cache();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_reset_film_size_cache_116_comment =
  "C++ Interface:\n"
  "reset_film_size_cache(const PSSMCameraRig self)\n"
  "\n"
  "/**\n"
  " * @brief Resets the film size cache\n"
  " * @details In case PSSMCameraRig::set_use_fixed_film_size is used, this resets\n"
  " *   the film size cache. This might lead to a small \"jump\" in the shadows,\n"
  " *   because the film size changes, however it leads to a better shadow distribution.\n"
  " *\n"
  " *   This is the case because when using a fixed film size, the cache will get\n"
  " *   bigger and bigger, whenever the camera moves to a grazing angle. However,\n"
  " *   when moving back to a normal angle, the film size cache still stores this\n"
  " *   big angle, and thus the splits will have a much bigger film size than actualy\n"
  " *   required. To prevent this, call this method once in a while, so an optimal\n"
  " *   distribution is ensured.\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_reset_film_size_cache_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath PSSMCameraRig::get_camera(std::size_t index)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_get_camera_117(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.get_camera")) {
    return NULL;
  }
  // 1-inline NodePath PSSMCameraRig::get_camera(std::size_t index)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_camera", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    NodePath *return_value = new NodePath((*local_this).get_camera((std::size_t)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_camera(const PSSMCameraRig self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_get_camera_117_comment =
  "C++ Interface:\n"
  "get_camera(const PSSMCameraRig self, int index)\n"
  "\n"
  "/**\n"
  " * @brief Returns the n-th camera\n"
  " * @details This returns the n-th camera of the camera rig, which can be used\n"
  " *   for various stuff like showing its frustum, passing it as a shader input,\n"
  " *   and so on.\n"
  " *\n"
  " *   The first camera is the camera which is the camera of the first split,\n"
  " *   which is the split closest to the camera. All cameras follow in descending\n"
  " *   order until to the last camera, which is the split furthest away from the\n"
  " *   camera.\n"
  " *\n"
  " *   If an invalid index is passed, an assertion is thrown.\n"
  " *\n"
  " * @param index Index of the camera.\n"
  " * @return [description]\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_get_camera_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PSSMCameraRig::reparent_to(NodePath parent)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_reparent_to_118(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.reparent_to")) {
    return NULL;
  }
  // 1-void PSSMCameraRig::reparent_to(NodePath parent)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PSSMCameraRig.reparent_to", true, true);
  if (arg_this != NULL) {
    (*local_this).reparent_to(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reparent_to(const PSSMCameraRig self, NodePath parent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_reparent_to_118_comment =
  "C++ Interface:\n"
  "reparent_to(const PSSMCameraRig self, NodePath parent)\n";
#else
static const char *Dtool_PSSMCameraRig_reparent_to_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PTA_LMatrix4f const &PSSMCameraRig::get_mvp_array(void)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_get_mvp_array_119(PyObject *self, PyObject *) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.get_mvp_array")) {
    return NULL;
  }
  // 1-inline PTA_LMatrix4f const &PSSMCameraRig::get_mvp_array(void)
  PTA_LMatrix4f const *return_value = &((*local_this).get_mvp_array());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_get_mvp_array_119_comment =
  "C++ Interface:\n"
  "get_mvp_array(const PSSMCameraRig self)\n"
  "\n"
  "/**\n"
  " * @brief Returns a handle to the MVP array\n"
  " * @details This returns a handle to the array of view-projection matrices\n"
  " *   of the different splits. This can be used for computing shadows. The array\n"
  " *   is a PTALMatrix4f and thus can be directly bound to a shader.\n"
  " *\n"
  " * @return view-projection matrix array\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_get_mvp_array_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PTA_LVecBase2f const &PSSMCameraRig::get_nearfar_array(void)
 *******************************************************************/
static PyObject *Dtool_PSSMCameraRig_get_nearfar_array_120(PyObject *self, PyObject *) {
  PSSMCameraRig *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.get_nearfar_array")) {
    return NULL;
  }
  // 1-inline PTA_LVecBase2f const &PSSMCameraRig::get_nearfar_array(void)
  PTA_LVecBase2f const *return_value = &((*local_this).get_nearfar_array());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_get_nearfar_array_120_comment =
  "C++ Interface:\n"
  "get_nearfar_array(const PSSMCameraRig self)\n"
  "\n"
  "/**\n"
  " * @brief Returns a handle to the near and far planes array\n"
  " * @details This returns a handle to the near and far plane array. Each split\n"
  " *   has an entry in the array, whereas the x component of the vecto denotes the\n"
  " *   near plane, and the y component denotes the far plane of the split.\n"
  " *\n"
  " *   This is required because the near and far planes of the splits change\n"
  " *   constantly. To access them in a shader, the shader needs access to the\n"
  " *   array.\n"
  " *\n"
  " * @return Array of near and far planes\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_get_nearfar_array_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PSSMCameraRig::PSSMCameraRig(std::size_t num_splits)
 *******************************************************************/
static int Dtool_Init_PSSMCameraRig(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PSSMCameraRig() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "num_splits");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'num_splits' (pos 1) not found");
    return -1;
  }
  // 1-PSSMCameraRig::PSSMCameraRig(std::size_t num_splits)
  Py_ssize_t param0;
  if (PyArg_Parse(arg, "n:PSSMCameraRig", &param0)) {
#ifndef NDEBUG
    if (param0 < 0) {
      PyErr_Format(PyExc_OverflowError,
                   "can't convert negative value %zd to size_t",
                   param0);
      return -1;
    }
#endif
    PSSMCameraRig *return_value = new PSSMCameraRig((std::size_t)param0);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PSSMCameraRig, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PSSMCameraRig(int num_splits)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PSSMCameraRig(PyObject *args, PSSMCameraRig const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PSSMCameraRig, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PSSMCameraRig::PSSMCameraRig(std::size_t num_splits)
    Py_ssize_t param0;
    if (PyArg_Parse(arg, "n:PSSMCameraRig", &param0)) {
#ifndef NDEBUG
      if (param0 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param0);
        return false;
      }
#endif
      PSSMCameraRig *return_value = new PSSMCameraRig((std::size_t)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_PSSMCameraRig(PyObject *args, PSSMCameraRig *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PSSMCameraRig, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PSSMCameraRig::PSSMCameraRig(std::size_t num_splits)
    Py_ssize_t param0;
    if (PyArg_Parse(arg, "n:PSSMCameraRig", &param0)) {
#ifndef NDEBUG
      if (param0 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param0);
        return false;
      }
#endif
      PSSMCameraRig *return_value = new PSSMCameraRig((std::size_t)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_PSSMCameraRig(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PSSMCameraRig) {
    printf("PSSMCameraRig ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PSSMCameraRig *local_this = (PSSMCameraRig *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PSSMCameraRig) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PSSMCameraRig(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PSSMCameraRig) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. RPPointLight
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void RPPointLight::set_radius(float radius)
 *******************************************************************/
static PyObject *Dtool_RPPointLight_set_radius_123(PyObject *self, PyObject *arg) {
  RPPointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPPointLight, (void **)&local_this, "RPPointLight.set_radius")) {
    return NULL;
  }
  // 1-inline void RPPointLight::set_radius(float radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const RPPointLight self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPPointLight_set_radius_123_comment =
  "C++ Interface:\n"
  "set_radius(const RPPointLight self, float radius)\n"
  "\n"
  "/**\n"
  " * @brief Sets the radius of the light\n"
  " * @details This sets the radius of the light. It controls the lights\n"
  " *   influence. After a distance greater than this radius, the light influence\n"
  " *   is zero.\n"
  " *\n"
  " * @param radius Light radius in world space\n"
  " */";
#else
static const char *Dtool_RPPointLight_set_radius_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RPPointLight::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_RPPointLight_get_radius_124(PyObject *self, PyObject *) {
  RPPointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPPointLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float RPPointLight::get_radius(void) const
  float return_value = (*(const RPPointLight*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyFloat_FromDouble(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPPointLight_get_radius_124_comment =
  "C++ Interface:\n"
  "get_radius(RPPointLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the lights radius\n"
  " * @details This returns the lights radius previously set with\n"
  " *   RPPointLight::set_radius\n"
  " * @return Light radius in world space\n"
  " */";
#else
static const char *Dtool_RPPointLight_get_radius_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPPointLight::set_inner_radius(float inner_radius)
 *******************************************************************/
static PyObject *Dtool_RPPointLight_set_inner_radius_126(PyObject *self, PyObject *arg) {
  RPPointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPPointLight, (void **)&local_this, "RPPointLight.set_inner_radius")) {
    return NULL;
  }
  // 1-inline void RPPointLight::set_inner_radius(float inner_radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_inner_radius((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_inner_radius(const RPPointLight self, float inner_radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPPointLight_set_inner_radius_126_comment =
  "C++ Interface:\n"
  "set_inner_radius(const RPPointLight self, float inner_radius)\n"
  "\n"
  "/**\n"
  " * @brief Sets the inner radius of the light\n"
  " * @details This sets the inner radius of the light. Anything greater than\n"
  " *   zero causes the light to get an area light. This has influence on the\n"
  " *   specular highlights of the light aswell as the shadows.\n"
  " *\n"
  " *   The inner radius controls the size of the lights sphere size in world\n"
  " *   space units. A radius of 0 means the light has no inner radius, and the\n"
  " *   light will be have like an infinite small point light source.\n"
  " *   A radius greater than zero will cause the light to behave like it would be\n"
  " *   an emissive sphere with the given inner radius emitting light. This is\n"
  " *   more physically correct.\n"
  " *\n"
  " * @param inner_radius Inner-radius in world space\n"
  " */";
#else
static const char *Dtool_RPPointLight_set_inner_radius_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RPPointLight::get_inner_radius(void) const
 *******************************************************************/
static PyObject *Dtool_RPPointLight_get_inner_radius_127(PyObject *self, PyObject *) {
  RPPointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPPointLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float RPPointLight::get_inner_radius(void) const
  float return_value = (*(const RPPointLight*)local_this).get_inner_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyFloat_FromDouble(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPPointLight_get_inner_radius_127_comment =
  "C++ Interface:\n"
  "get_inner_radius(RPPointLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the inner radius of the light\n"
  " * @details This returns the inner radius of the light, previously set with\n"
  " *   RPPointLight::get_inner_radius.\n"
  " * @return [description]\n"
  " */";
#else
static const char *Dtool_RPPointLight_get_inner_radius_127_comment = NULL;
#endif

PyObject *Dtool_RPPointLight_radius_Getter(PyObject *self, void *) {
  const RPPointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPPointLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float RPPointLight::get_radius(void) const
  float return_value = (*(const RPPointLight*)local_this).get_radius();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyFloat_FromDouble(return_value);
}

int Dtool_RPPointLight_radius_Setter(PyObject *self, PyObject *arg, void *) {
  RPPointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPPointLight, (void **)&local_this, "RPPointLight.radius")) {
    return -1;
  }

  // 1-inline void RPPointLight::set_radius(float radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const RPPointLight self, float radius)\n");
  }
  return -1;
}

PyObject *Dtool_RPPointLight_inner_radius_Getter(PyObject *self, void *) {
  const RPPointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPPointLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float RPPointLight::get_inner_radius(void) const
  float return_value = (*(const RPPointLight*)local_this).get_inner_radius();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyFloat_FromDouble(return_value);
}

int Dtool_RPPointLight_inner_radius_Setter(PyObject *self, PyObject *arg, void *) {
  RPPointLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPPointLight, (void **)&local_this, "RPPointLight.inner_radius")) {
    return -1;
  }

  // 1-inline void RPPointLight::set_inner_radius(float inner_radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_inner_radius((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_inner_radius(const RPPointLight self, float inner_radius)\n");
  }
  return -1;
}

/******************************************************************
 * Python type method wrapper for
 * RPPointLight::RPPointLight(void)
 *******************************************************************/
static int Dtool_Init_RPPointLight(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RPPointLight() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-RPPointLight::RPPointLight(void)
  RPPointLight *return_value = new RPPointLight();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RPPointLight, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RPPointLight()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RPPointLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_RPPointLight) {
    printf("RPPointLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  RPPointLight *local_this = (RPPointLight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_RPPointLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_RPLight) {
    return (RPLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(RPLight *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_RPPointLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_RPPointLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_RPLight) {
    RPLight* other_this = (RPLight*)from_this;
    return (RPPointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RPPointLight*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. RPSpotLight
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void RPSpotLight::set_radius(float radius)
 *******************************************************************/
static PyObject *Dtool_RPSpotLight_set_radius_132(PyObject *self, PyObject *arg) {
  RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.set_radius")) {
    return NULL;
  }
  // 1-inline void RPSpotLight::set_radius(float radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const RPSpotLight self, float radius)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_set_radius_132_comment =
  "C++ Interface:\n"
  "set_radius(const RPSpotLight self, float radius)\n";
#else
static const char *Dtool_RPSpotLight_set_radius_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RPSpotLight::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_RPSpotLight_get_radius_133(PyObject *self, PyObject *) {
  RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPSpotLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float RPSpotLight::get_radius(void) const
  float return_value = (*(const RPSpotLight*)local_this).get_radius();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyFloat_FromDouble(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_get_radius_133_comment =
  "C++ Interface:\n"
  "get_radius(RPSpotLight self)\n";
#else
static const char *Dtool_RPSpotLight_get_radius_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPSpotLight::set_fov(float fov)
 *******************************************************************/
static PyObject *Dtool_RPSpotLight_set_fov_135(PyObject *self, PyObject *arg) {
  RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.set_fov")) {
    return NULL;
  }
  // 1-inline void RPSpotLight::set_fov(float fov)
  if (PyNumber_Check(arg)) {
    (*local_this).set_fov((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fov(const RPSpotLight self, float fov)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_set_fov_135_comment =
  "C++ Interface:\n"
  "set_fov(const RPSpotLight self, float fov)\n";
#else
static const char *Dtool_RPSpotLight_set_fov_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float RPSpotLight::get_fov(void) const
 *******************************************************************/
static PyObject *Dtool_RPSpotLight_get_fov_136(PyObject *self, PyObject *) {
  RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPSpotLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float RPSpotLight::get_fov(void) const
  float return_value = (*(const RPSpotLight*)local_this).get_fov();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyFloat_FromDouble(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_get_fov_136_comment =
  "C++ Interface:\n"
  "get_fov(RPSpotLight self)\n";
#else
static const char *Dtool_RPSpotLight_get_fov_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPSpotLight::set_direction(LVecBase3f direction)
 * inline void RPSpotLight::set_direction(float dx, float dy, float dz)
 *******************************************************************/
static PyObject *Dtool_RPSpotLight_set_direction_138(PyObject *self, PyObject *args, PyObject *kwds) {
  RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.set_direction")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "direction");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'direction' (pos 1) not found");
      }
      // 1-inline void RPSpotLight::set_direction(LVecBase3f direction)
      LVecBase3f arg_local;
      LVecBase3f *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "RPSpotLight.set_direction", "LVecBase3f");
      }
      (*local_this).set_direction(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void RPSpotLight::set_direction(float dx, float dy, float dz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"dx", "dy", "dz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_direction", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).set_direction((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_direction() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_direction(const RPSpotLight self, LVecBase3f direction)\n"
      "set_direction(const RPSpotLight self, float dx, float dy, float dz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_set_direction_138_comment =
  "C++ Interface:\n"
  "set_direction(const RPSpotLight self, LVecBase3f direction)\n"
  "set_direction(const RPSpotLight self, float dx, float dy, float dz)\n";
#else
static const char *Dtool_RPSpotLight_set_direction_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &RPSpotLight::get_direction(void) const
 *******************************************************************/
static PyObject *Dtool_RPSpotLight_get_direction_139(PyObject *self, PyObject *) {
  RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPSpotLight, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f const &RPSpotLight::get_direction(void) const
  LVecBase3f const *return_value = &((*(const RPSpotLight*)local_this).get_direction());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_get_direction_139_comment =
  "C++ Interface:\n"
  "get_direction(RPSpotLight self)\n";
#else
static const char *Dtool_RPSpotLight_get_direction_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void RPSpotLight::look_at(LVecBase3f point)
 * inline void RPSpotLight::look_at(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_RPSpotLight_look_at_140(PyObject *self, PyObject *args, PyObject *kwds) {
  RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.look_at")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "point");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'point' (pos 1) not found");
      }
      // 1-inline void RPSpotLight::look_at(LVecBase3f point)
      LVecBase3f arg_local;
      LVecBase3f *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "RPSpotLight.look_at", "LVecBase3f");
      }
      (*local_this).look_at(*arg_this);
      return Dtool_Return_None();
    }
    break;
  case 3:
    {
      // 1-inline void RPSpotLight::look_at(float x, float y, float z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:look_at", (char **)keyword_list, &param1, &param2, &param3)) {
        (*local_this).look_at((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "look_at() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "look_at(const RPSpotLight self, LVecBase3f point)\n"
      "look_at(const RPSpotLight self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_look_at_140_comment =
  "C++ Interface:\n"
  "look_at(const RPSpotLight self, LVecBase3f point)\n"
  "look_at(const RPSpotLight self, float x, float y, float z)\n";
#else
static const char *Dtool_RPSpotLight_look_at_140_comment = NULL;
#endif

PyObject *Dtool_RPSpotLight_radius_Getter(PyObject *self, void *) {
  const RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPSpotLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float RPSpotLight::get_radius(void) const
  float return_value = (*(const RPSpotLight*)local_this).get_radius();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyFloat_FromDouble(return_value);
}

int Dtool_RPSpotLight_radius_Setter(PyObject *self, PyObject *arg, void *) {
  RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.radius")) {
    return -1;
  }

  // 1-inline void RPSpotLight::set_radius(float radius)
  if (PyNumber_Check(arg)) {
    (*local_this).set_radius((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const RPSpotLight self, float radius)\n");
  }
  return -1;
}

PyObject *Dtool_RPSpotLight_fov_Getter(PyObject *self, void *) {
  const RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPSpotLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float RPSpotLight::get_fov(void) const
  float return_value = (*(const RPSpotLight*)local_this).get_fov();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyFloat_FromDouble(return_value);
}

int Dtool_RPSpotLight_fov_Setter(PyObject *self, PyObject *arg, void *) {
  RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.fov")) {
    return -1;
  }

  // 1-inline void RPSpotLight::set_fov(float fov)
  if (PyNumber_Check(arg)) {
    (*local_this).set_fov((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fov(const RPSpotLight self, float fov)\n");
  }
  return -1;
}

PyObject *Dtool_RPSpotLight_direction_Getter(PyObject *self, void *) {
  const RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPSpotLight, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3f const &RPSpotLight::get_direction(void) const
  LVecBase3f const *return_value = &((*(const RPSpotLight*)local_this).get_direction());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

int Dtool_RPSpotLight_direction_Setter(PyObject *self, PyObject *arg, void *) {
  RPSpotLight *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.direction")) {
    return -1;
  }

  // 1-inline void RPSpotLight::set_direction(LVecBase3f direction)
  LVecBase3f arg_local;
  LVecBase3f *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "RPSpotLight.set_direction", "LVecBase3f");
    return -1;
  }
  (*local_this).set_direction(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_direction(const RPSpotLight self, LVecBase3f direction)\n");
  }
  return -1;
}

/******************************************************************
 * Python type method wrapper for
 * RPSpotLight::RPSpotLight(void)
 *******************************************************************/
static int Dtool_Init_RPSpotLight(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RPSpotLight() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-RPSpotLight::RPSpotLight(void)
  RPSpotLight *return_value = new RPSpotLight();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RPSpotLight, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RPSpotLight()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RPSpotLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_RPSpotLight) {
    printf("RPSpotLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  RPSpotLight *local_this = (RPSpotLight *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_RPSpotLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_RPLight) {
    return (RPLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(RPLight *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_RPSpotLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_RPSpotLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_RPLight) {
    RPLight* other_this = (RPLight*)from_this;
    return (RPSpotLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RPSpotLight*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. MeshSplitterWriter
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void MeshSplitterWriter::add_geom(ConstPointerTo< Geom > )
 *******************************************************************/
static PyObject *Dtool_MeshSplitterWriter_add_geom_146(PyObject *self, PyObject *arg) {
  MeshSplitterWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshSplitterWriter, (void **)&local_this, "MeshSplitterWriter.add_geom")) {
    return NULL;
  }
  // 1-void MeshSplitterWriter::add_geom(ConstPointerTo< Geom > )
  Geom const *arg_this = (Geom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Geom, 1, "MeshSplitterWriter.add_geom", true, true);
  if (arg_this != NULL) {
    (*local_this).add_geom(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_geom(const MeshSplitterWriter self, const Geom param0)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshSplitterWriter_add_geom_146_comment =
  "C++ Interface:\n"
  "add_geom(const MeshSplitterWriter self, const Geom param0)\n";
#else
static const char *Dtool_MeshSplitterWriter_add_geom_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MeshSplitterWriter::process(Filename const &dest)
 *******************************************************************/
static PyObject *Dtool_MeshSplitterWriter_process_147(PyObject *self, PyObject *arg) {
  MeshSplitterWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MeshSplitterWriter, (void **)&local_this, "MeshSplitterWriter.process")) {
    return NULL;
  }
  // 1-void MeshSplitterWriter::process(Filename const &dest)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MeshSplitterWriter.process", "Filename");
  }
  (*local_this).process(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "process(const MeshSplitterWriter self, const Filename dest)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MeshSplitterWriter_process_147_comment =
  "C++ Interface:\n"
  "process(const MeshSplitterWriter self, const Filename dest)\n";
#else
static const char *Dtool_MeshSplitterWriter_process_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MeshSplitterWriter::MeshSplitterWriter(void)
 * inline MeshSplitterWriter::MeshSplitterWriter(MeshSplitterWriter const &) = default
 *******************************************************************/
static int Dtool_Init_MeshSplitterWriter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-MeshSplitterWriter::MeshSplitterWriter(void)
      MeshSplitterWriter *return_value = new MeshSplitterWriter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MeshSplitterWriter, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline MeshSplitterWriter::MeshSplitterWriter(MeshSplitterWriter const &) = default
      MeshSplitterWriter const *arg_this = (MeshSplitterWriter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MeshSplitterWriter, 0, "MeshSplitterWriter.MeshSplitterWriter", true, true);
      if (arg_this != NULL) {
        MeshSplitterWriter *return_value = new MeshSplitterWriter(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MeshSplitterWriter, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MeshSplitterWriter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MeshSplitterWriter()\n"
      "MeshSplitterWriter(const MeshSplitterWriter param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MeshSplitterWriter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MeshSplitterWriter) {
    printf("MeshSplitterWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MeshSplitterWriter *local_this = (MeshSplitterWriter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MeshSplitterWriter) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MeshSplitterWriter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MeshSplitterWriter) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. SGNode
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle SGNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SGNode_get_class_type_151(PyObject *, PyObject *) {
  // 1-static TypeHandle SGNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(SGNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SGNode_get_class_type_151_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SGNode_get_class_type_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SGNode::SGNode(SGNode const &) = default
 * SGNode::SGNode(std::string const &name, StaticGeometryHandler *handler, int dataset_reference)
 *******************************************************************/
static int Dtool_Init_SGNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline SGNode::SGNode(SGNode const &) = default
      CPT(SGNode) arg_this;
      if (!Dtool_ConstCoerce_SGNode(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "SGNode.SGNode", "SGNode");
        return -1;
      }
      SGNode *return_value = new SGNode(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SGNode, true, false);
    }
    break;
  case 3:
    {
      // 1-SGNode::SGNode(std::string const &name, StaticGeometryHandler *handler, int dataset_reference)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"name", "handler", "dataset_reference", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oi:SGNode", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
        StaticGeometryHandler *param1_this = (StaticGeometryHandler *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_StaticGeometryHandler, 1, "SGNode.SGNode", false, true);
        if (param1_this != NULL) {
          SGNode *return_value = new SGNode(std::string(param0_str, param0_len), param1_this, (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SGNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SGNode() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SGNode(const SGNode param0)\n"
      "SGNode(str name, StaticGeometryHandler handler, int dataset_reference)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SGNode(PyObject *args, CPT(SGNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SGNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-SGNode::SGNode(std::string const &name, StaticGeometryHandler *handler, int dataset_reference)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      int param2;
      if (PyArg_ParseTuple(args, "s#Oi:SGNode", &param0_str, &param0_len, &param1, &param2)) {
        StaticGeometryHandler *param1_this = (StaticGeometryHandler *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_StaticGeometryHandler, 1, "SGNode.SGNode", false, false);
        if (param1_this != NULL) {
          SGNode *return_value = new SGNode(std::string(param0_str, param0_len), param1_this, (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_SGNode(PyObject *args, PT(SGNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SGNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-SGNode::SGNode(std::string const &name, StaticGeometryHandler *handler, int dataset_reference)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      int param2;
      if (PyArg_ParseTuple(args, "s#Oi:SGNode", &param0_str, &param0_len, &param1, &param2)) {
        StaticGeometryHandler *param1_this = (StaticGeometryHandler *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_StaticGeometryHandler, 1, "SGNode.SGNode", false, false);
        if (param1_this != NULL) {
          SGNode *return_value = new SGNode(std::string(param0_str, param0_len), param1_this, (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_SGNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SGNode) {
    printf("SGNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SGNode *local_this = (SGNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SGNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SGNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SGNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SGNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SGNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SGNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SGNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SGNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SGNode*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. SGRenderNode
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle SGRenderNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SGRenderNode_get_class_type_154(PyObject *, PyObject *) {
  // 1-static TypeHandle SGRenderNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(SGRenderNode::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SGRenderNode_get_class_type_154_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SGRenderNode_get_class_type_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SGRenderNode::SGRenderNode(SGRenderNode const &) = default
 * SGRenderNode::SGRenderNode(StaticGeometryHandler *handler, PointerTo< Shader > collector_shader)
 *******************************************************************/
static int Dtool_Init_SGRenderNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline SGRenderNode::SGRenderNode(SGRenderNode const &) = default
      CPT(SGRenderNode) arg_this;
      if (!Dtool_ConstCoerce_SGRenderNode(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "SGRenderNode.SGRenderNode", "SGRenderNode");
        return -1;
      }
      SGRenderNode *return_value = new SGRenderNode(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SGRenderNode, true, false);
    }
    break;
  case 2:
    {
      // 1-SGRenderNode::SGRenderNode(StaticGeometryHandler *handler, PointerTo< Shader > collector_shader)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"handler", "collector_shader", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:SGRenderNode", (char **)keyword_list, &param0, &param1)) {
        StaticGeometryHandler *param0_this = (StaticGeometryHandler *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_StaticGeometryHandler, 0, "SGRenderNode.SGRenderNode", false, true);
        PT(Shader) param1_this;
        if (!Dtool_Coerce_Shader(param1, param1_this)) {
          Dtool_Raise_ArgTypeError(param1, 1, "SGRenderNode.SGRenderNode", "Shader");
          return -1;
        }
        if (param0_this != NULL) {
          SGRenderNode *return_value = new SGRenderNode(param0_this, MOVE(param1_this));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SGRenderNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SGRenderNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SGRenderNode(const SGRenderNode param0)\n"
      "SGRenderNode(StaticGeometryHandler handler, Shader collector_shader)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SGRenderNode(PyObject *args, CPT(SGRenderNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SGRenderNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-SGRenderNode::SGRenderNode(StaticGeometryHandler *handler, PointerTo< Shader > collector_shader)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "SGRenderNode", 2, 2, &param0, &param1)) {
        StaticGeometryHandler *param0_this = (StaticGeometryHandler *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_StaticGeometryHandler, 0, "SGRenderNode.SGRenderNode", false, false);
        Shader *param1_this = (Shader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Shader, 1, "SGRenderNode.SGRenderNode", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          SGRenderNode *return_value = new SGRenderNode(param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_SGRenderNode(PyObject *args, PT(SGRenderNode) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SGRenderNode, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-SGRenderNode::SGRenderNode(StaticGeometryHandler *handler, PointerTo< Shader > collector_shader)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "SGRenderNode", 2, 2, &param0, &param1)) {
        StaticGeometryHandler *param0_this = (StaticGeometryHandler *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_StaticGeometryHandler, 0, "SGRenderNode.SGRenderNode", false, false);
        Shader *param1_this = (Shader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Shader, 1, "SGRenderNode.SGRenderNode", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          SGRenderNode *return_value = new SGRenderNode(param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_SGRenderNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SGRenderNode) {
    printf("SGRenderNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SGRenderNode *local_this = (SGRenderNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SGRenderNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SGRenderNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SGRenderNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (SGRenderNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (SGRenderNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (SGRenderNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (SGRenderNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (SGRenderNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (SGRenderNode*)other_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Functions for .. StaticGeometryHandler
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DatasetReference StaticGeometryHandler::load_dataset(Filename const &src)
 *******************************************************************/
static PyObject *Dtool_StaticGeometryHandler_load_dataset_158(PyObject *self, PyObject *arg) {
  StaticGeometryHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StaticGeometryHandler, (void **)&local_this, "StaticGeometryHandler.load_dataset")) {
    return NULL;
  }
  // 1-DatasetReference StaticGeometryHandler::load_dataset(Filename const &src)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "StaticGeometryHandler.load_dataset", "Filename");
  }
  DatasetReference return_value = (*local_this).load_dataset(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return PyLongOrInt_FromLong(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_dataset(const StaticGeometryHandler self, const Filename src)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StaticGeometryHandler_load_dataset_158_comment =
  "C++ Interface:\n"
  "load_dataset(const StaticGeometryHandler self, const Filename src)\n";
#else
static const char *Dtool_StaticGeometryHandler_load_dataset_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * StaticGeometryHandler::StaticGeometryHandler(void)
 * inline StaticGeometryHandler::StaticGeometryHandler(StaticGeometryHandler const &) = default
 *******************************************************************/
static int Dtool_Init_StaticGeometryHandler(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-StaticGeometryHandler::StaticGeometryHandler(void)
      StaticGeometryHandler *return_value = new StaticGeometryHandler();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StaticGeometryHandler, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline StaticGeometryHandler::StaticGeometryHandler(StaticGeometryHandler const &) = default
      StaticGeometryHandler const *arg_this = (StaticGeometryHandler *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StaticGeometryHandler, 0, "StaticGeometryHandler.StaticGeometryHandler", true, true);
      if (arg_this != NULL) {
        StaticGeometryHandler *return_value = new StaticGeometryHandler(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StaticGeometryHandler, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StaticGeometryHandler() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StaticGeometryHandler()\n"
      "StaticGeometryHandler(const StaticGeometryHandler param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_StaticGeometryHandler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_StaticGeometryHandler) {
    printf("StaticGeometryHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  StaticGeometryHandler *local_this = (StaticGeometryHandler *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_StaticGeometryHandler) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_StaticGeometryHandler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_StaticGeometryHandler) {
    return from_this;
  }
  return (void *) NULL;
}

//********************************************************************
//*** Py Init Code For .. GPUCommand | GPUCommand
//********************************************************************
static PyMethodDef Dtool_Methods_GPUCommand[] = {
  {"push_int", &Dtool_GPUCommand_push_int_4, METH_O, (const char *)Dtool_GPUCommand_push_int_4_comment},
  {"push_float", &Dtool_GPUCommand_push_float_5, METH_O, (const char *)Dtool_GPUCommand_push_float_5_comment},
  {"push_vec3", &Dtool_GPUCommand_push_vec3_6, METH_O, (const char *)Dtool_GPUCommand_push_vec3_6_comment},
  {"push_vec4", &Dtool_GPUCommand_push_vec4_7, METH_O, (const char *)Dtool_GPUCommand_push_vec4_7_comment},
  {"push_mat3", &Dtool_GPUCommand_push_mat3_8, METH_O, (const char *)Dtool_GPUCommand_push_mat3_8_comment},
  {"push_mat4", &Dtool_GPUCommand_push_mat4_9, METH_O, (const char *)Dtool_GPUCommand_push_mat4_9_comment},
  {"get_uses_integer_packing", &Dtool_GPUCommand_get_uses_integer_packing_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_GPUCommand_get_uses_integer_packing_10_comment},
  {"write_to", (PyCFunction) &Dtool_GPUCommand_write_to_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GPUCommand_write_to_11_comment},
  {"write", &Dtool_GPUCommand_write_12, METH_O, (const char *)Dtool_GPUCommand_write_12_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     GPUCommand
//////////////////
static PyObject *Dtool_Str_GPUCommand(PyObject *self) {
  GPUCommand *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GPUCommand, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
#if PY_MAJOR_VERSION >= 3
  return PyUnicode_FromStringAndSize(ss.data(), ss.length());
#else
  return PyString_FromStringAndSize(ss.data(), ss.length());
#endif
}

static PyNumberMethods Dtool_NumberMethods_GPUCommand = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_GPUCommand = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.GPUCommand",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_GPUCommand,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_GPUCommand,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_GPUCommand,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Class for storing data to be transferred to the GPU.\n"
    " * @details This class can be seen like a packet, to be transferred to the GPU.\n"
    " *   It has a command type, which tells the GPU what to do once it recieved this\n"
    " *   \"packet\". It stores a limited amount of floating point components.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_GPUCommand,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_GPUCommand,
    PyType_GenericAlloc,
    Dtool_new_GPUCommand,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GPUCommand,
  Dtool_UpcastInterface_GPUCommand,
  Dtool_DowncastInterface_GPUCommand,
  (CoerceFunction)Dtool_ConstCoerce_GPUCommand,
  (CoerceFunction)Dtool_Coerce_GPUCommand,
};

static void Dtool_PyModuleClassInit_GPUCommand(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GPUCommand._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_GPUCommand._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Enum  GPUCommand::CommandType;
    PyDict_SetItemString(dict, "CMD_invalid", PyLongOrInt_FromLong(GPUCommand::CMD_invalid));
    PyDict_SetItemString(dict, "CMD_store_light", PyLongOrInt_FromLong(GPUCommand::CMD_store_light));
    PyDict_SetItemString(dict, "CMD_remove_light", PyLongOrInt_FromLong(GPUCommand::CMD_remove_light));
    PyDict_SetItemString(dict, "CMD_store_source", PyLongOrInt_FromLong(GPUCommand::CMD_store_source));
    PyDict_SetItemString(dict, "CMD_remove_sources", PyLongOrInt_FromLong(GPUCommand::CMD_remove_sources));
    if (PyType_Ready((PyTypeObject *)&Dtool_GPUCommand) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GPUCommand)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GPUCommand);
  }
}

//********************************************************************
//*** Py Init Code For .. GPUCommandList | GPUCommandList
//********************************************************************
static PyMethodDef Dtool_Methods_GPUCommandList[] = {
  {"add_command", &Dtool_GPUCommandList_add_command_16, METH_O, (const char *)Dtool_GPUCommandList_add_command_16_comment},
  {"get_num_commands", &Dtool_GPUCommandList_get_num_commands_17, METH_NOARGS, (const char *)Dtool_GPUCommandList_get_num_commands_17_comment},
  {"write_commands_to", (PyCFunction) &Dtool_GPUCommandList_write_commands_to_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GPUCommandList_write_commands_to_18_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_GPUCommandList[] = {
  {(char *)"num_commands", &Dtool_GPUCommandList_num_commands_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_GPUCommandList = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_GPUCommandList = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.GPUCommandList",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_GPUCommandList,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_GPUCommandList,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Class to store a list of commands.\n"
    " * @details This is a class to store a list of GPUCommands. It provides\n"
    " *   functionality to only provide the a given amount of commands at one time.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_GPUCommandList,
    0, // tp_members
    Dtool_Properties_GPUCommandList,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_GPUCommandList,
    PyType_GenericAlloc,
    Dtool_new_GPUCommandList,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GPUCommandList,
  Dtool_UpcastInterface_GPUCommandList,
  Dtool_DowncastInterface_GPUCommandList,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_GPUCommandList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GPUCommandList._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_GPUCommandList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GPUCommandList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GPUCommandList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GPUCommandList);
  }
}

//********************************************************************
//*** Py Init Code For .. RPLight | RPLight
//********************************************************************
static PyMethodDef Dtool_Methods_RPLight[] = {
  {"set_pos", (PyCFunction) &Dtool_RPLight_set_pos_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPLight_set_pos_26_comment},
  {"get_pos", &Dtool_RPLight_get_pos_27, METH_NOARGS, (const char *)Dtool_RPLight_get_pos_27_comment},
  {"set_color", (PyCFunction) &Dtool_RPLight_set_color_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPLight_set_color_30_comment},
  {"get_color", &Dtool_RPLight_get_color_31, METH_NOARGS, (const char *)Dtool_RPLight_get_color_31_comment},
  {"set_color_from_temperature", &Dtool_RPLight_set_color_from_temperature_33, METH_O, (const char *)Dtool_RPLight_set_color_from_temperature_33_comment},
  {"set_lumens", &Dtool_RPLight_set_lumens_34, METH_O, (const char *)Dtool_RPLight_set_lumens_34_comment},
  {"get_lumens", &Dtool_RPLight_get_lumens_35, METH_NOARGS, (const char *)Dtool_RPLight_get_lumens_35_comment},
  {"get_light_type", &Dtool_RPLight_get_light_type_38, METH_NOARGS, (const char *)Dtool_RPLight_get_light_type_38_comment},
  {"set_casts_shadows", (PyCFunction) &Dtool_RPLight_set_casts_shadows_40, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPLight_set_casts_shadows_40_comment},
  {"get_casts_shadows", &Dtool_RPLight_get_casts_shadows_41, METH_NOARGS, (const char *)Dtool_RPLight_get_casts_shadows_41_comment},
  {"set_shadow_map_resolution", &Dtool_RPLight_set_shadow_map_resolution_44, METH_O, (const char *)Dtool_RPLight_set_shadow_map_resolution_44_comment},
  {"get_shadow_map_resolution", &Dtool_RPLight_get_shadow_map_resolution_45, METH_NOARGS, (const char *)Dtool_RPLight_get_shadow_map_resolution_45_comment},
  {"set_ies_profile", &Dtool_RPLight_set_ies_profile_47, METH_O, (const char *)Dtool_RPLight_set_ies_profile_47_comment},
  {"get_ies_profile", &Dtool_RPLight_get_ies_profile_48, METH_NOARGS, (const char *)Dtool_RPLight_get_ies_profile_48_comment},
  {"has_ies_profile", &Dtool_RPLight_has_ies_profile_49, METH_NOARGS, (const char *)Dtool_RPLight_has_ies_profile_49_comment},
  {"clear_ies_profile", &Dtool_RPLight_clear_ies_profile_50, METH_NOARGS, (const char *)Dtool_RPLight_clear_ies_profile_50_comment},
  {"set_near_plane", &Dtool_RPLight_set_near_plane_53, METH_O, (const char *)Dtool_RPLight_set_near_plane_53_comment},
  {"get_near_plane", &Dtool_RPLight_get_near_plane_54, METH_NOARGS, (const char *)Dtool_RPLight_get_near_plane_54_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_RPLight[] = {
  {(char *)"pos", &Dtool_RPLight_pos_Getter, &Dtool_RPLight_pos_Setter, NULL, NULL},
  {(char *)"color", &Dtool_RPLight_color_Getter, &Dtool_RPLight_color_Setter, NULL, NULL},
  {(char *)"lumens", &Dtool_RPLight_lumens_Getter, &Dtool_RPLight_lumens_Setter, NULL, NULL},
  {(char *)"light_type", &Dtool_RPLight_light_type_Getter, NULL, NULL, NULL},
  {(char *)"casts_shadows", &Dtool_RPLight_casts_shadows_Getter, &Dtool_RPLight_casts_shadows_Setter, NULL, NULL},
  {(char *)"shadow_map_resolution", &Dtool_RPLight_shadow_map_resolution_Getter, &Dtool_RPLight_shadow_map_resolution_Setter, NULL, NULL},
  {(char *)"ies_profile", &Dtool_RPLight_ies_profile_Getter, &Dtool_RPLight_ies_profile_Setter, NULL, NULL},
  {(char *)"near_plane", &Dtool_RPLight_near_plane_Getter, &Dtool_RPLight_near_plane_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_RPLight = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RPLight = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_RPLight = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_RPLight = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_RPLight = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.RPLight",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_RPLight,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_RPLight,
    &Dtool_SequenceMethods_RPLight,
    &Dtool_MappingMethods_RPLight,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_RPLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Base class for Lights\n"
    " * @details This is the base class for all lights in the render pipeline. It\n"
    " *   stores common properties, and provides methods to modify these.\n"
    " *   It also defines some interface functions which subclasses have to implement.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_RPLight,
    0, // tp_members
    Dtool_Properties_RPLight,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    0,
    PyType_GenericAlloc,
    Dtool_new_RPLight,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RPLight,
  Dtool_UpcastInterface_RPLight,
  Dtool_DowncastInterface_RPLight,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_RPLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_RPLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_RPLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Enum  RPLight::LightType;
    PyDict_SetItemString(dict, "LT_empty", PyLongOrInt_FromLong(RPLight::LT_empty));
    PyDict_SetItemString(dict, "LT_point_light", PyLongOrInt_FromLong(RPLight::LT_point_light));
    PyDict_SetItemString(dict, "LT_spot_light", PyLongOrInt_FromLong(RPLight::LT_spot_light));
    if (PyType_Ready((PyTypeObject *)&Dtool_RPLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RPLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RPLight);
  }
}

//********************************************************************
//*** Py Init Code For .. ShadowManager | ShadowManager
//********************************************************************
static PyMethodDef Dtool_Methods_ShadowManager[] = {
  {"set_max_updates", &Dtool_ShadowManager_set_max_updates_58, METH_O, (const char *)Dtool_ShadowManager_set_max_updates_58_comment},
  {"set_atlas_size", &Dtool_ShadowManager_set_atlas_size_59, METH_O, (const char *)Dtool_ShadowManager_set_atlas_size_59_comment},
  {"set_scene", &Dtool_ShadowManager_set_scene_60, METH_O, (const char *)Dtool_ShadowManager_set_scene_60_comment},
  {"set_tag_state_manager", &Dtool_ShadowManager_set_tag_state_manager_61, METH_O, (const char *)Dtool_ShadowManager_set_tag_state_manager_61_comment},
  {"set_atlas_graphics_output", &Dtool_ShadowManager_set_atlas_graphics_output_62, METH_O, (const char *)Dtool_ShadowManager_set_atlas_graphics_output_62_comment},
  {"get_atlas_size", &Dtool_ShadowManager_get_atlas_size_63, METH_NOARGS, (const char *)Dtool_ShadowManager_get_atlas_size_63_comment},
  {"get_num_update_slots_left", &Dtool_ShadowManager_get_num_update_slots_left_64, METH_NOARGS, (const char *)Dtool_ShadowManager_get_num_update_slots_left_64_comment},
  {"init", &Dtool_ShadowManager_init_65, METH_NOARGS, (const char *)Dtool_ShadowManager_init_65_comment},
  {"update", &Dtool_ShadowManager_update_66, METH_NOARGS, (const char *)Dtool_ShadowManager_update_66_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ShadowManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShadowManager = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ShadowManager = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ShadowManager = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ShadowManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.ShadowManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ShadowManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ShadowManager,
    &Dtool_SequenceMethods_ShadowManager,
    &Dtool_MappingMethods_ShadowManager,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ShadowManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ShadowManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ShadowManager,
    PyType_GenericAlloc,
    Dtool_new_ShadowManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShadowManager,
  Dtool_UpcastInterface_ShadowManager,
  Dtool_DowncastInterface_ShadowManager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ShadowManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_ShadowManager._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_ShadowManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShadowManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShadowManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShadowManager);
  }
}

//********************************************************************
//*** Py Init Code For .. TagStateManager | TagStateManager
//********************************************************************
static PyMethodDef Dtool_Methods_TagStateManager[] = {
  {"get_gbuffer_mask", &Dtool_TagStateManager_get_gbuffer_mask_70, METH_NOARGS | METH_STATIC, (const char *)Dtool_TagStateManager_get_gbuffer_mask_70_comment},
  {"get_voxelize_mask", &Dtool_TagStateManager_get_voxelize_mask_71, METH_NOARGS | METH_STATIC, (const char *)Dtool_TagStateManager_get_voxelize_mask_71_comment},
  {"get_shadow_mask", &Dtool_TagStateManager_get_shadow_mask_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_TagStateManager_get_shadow_mask_72_comment},
  {"get_envmap_mask", &Dtool_TagStateManager_get_envmap_mask_73, METH_NOARGS | METH_STATIC, (const char *)Dtool_TagStateManager_get_envmap_mask_73_comment},
  {"apply_shadow_state", (PyCFunction) &Dtool_TagStateManager_apply_shadow_state_74, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TagStateManager_apply_shadow_state_74_comment},
  {"apply_voxelize_state", (PyCFunction) &Dtool_TagStateManager_apply_voxelize_state_75, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TagStateManager_apply_voxelize_state_75_comment},
  {"apply_envmap_state", (PyCFunction) &Dtool_TagStateManager_apply_envmap_state_76, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TagStateManager_apply_envmap_state_76_comment},
  {"cleanup_states", &Dtool_TagStateManager_cleanup_states_77, METH_NOARGS, (const char *)Dtool_TagStateManager_cleanup_states_77_comment},
  {"register_shadow_camera", &Dtool_TagStateManager_register_shadow_camera_78, METH_O, (const char *)Dtool_TagStateManager_register_shadow_camera_78_comment},
  {"unregister_shadow_camera", &Dtool_TagStateManager_unregister_shadow_camera_79, METH_O, (const char *)Dtool_TagStateManager_unregister_shadow_camera_79_comment},
  {"register_voxelize_camera", &Dtool_TagStateManager_register_voxelize_camera_80, METH_O, (const char *)Dtool_TagStateManager_register_voxelize_camera_80_comment},
  {"unregister_voxelize_camera", &Dtool_TagStateManager_unregister_voxelize_camera_81, METH_O, (const char *)Dtool_TagStateManager_unregister_voxelize_camera_81_comment},
  {"register_envmap_camera", &Dtool_TagStateManager_register_envmap_camera_82, METH_O, (const char *)Dtool_TagStateManager_register_envmap_camera_82_comment},
  {"unregister_envmap_camera", &Dtool_TagStateManager_unregister_envmap_camera_83, METH_O, (const char *)Dtool_TagStateManager_unregister_envmap_camera_83_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_TagStateManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_TagStateManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.TagStateManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TagStateManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TagStateManager,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief This class handles all different tag states\n"
    " * @details The TagStateManager stores a list of RenderStates assigned to different\n"
    " *   steps in the pipeline. For example, there are a list of shadow states, which\n"
    " *   are applied whenever objects are rendered from a shadow camera.\n"
    " *\n"
    " *   The Manager also stores a list of all cameras used in the different stages,\n"
    " *   to keep track of the states used and to be able to attach new states.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TagStateManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TagStateManager,
    PyType_GenericAlloc,
    Dtool_new_TagStateManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TagStateManager,
  Dtool_UpcastInterface_TagStateManager,
  Dtool_DowncastInterface_TagStateManager,
  (CoerceFunction)Dtool_ConstCoerce_TagStateManager,
  (CoerceFunction)Dtool_Coerce_TagStateManager,
};

static void Dtool_PyModuleClassInit_TagStateManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TagStateManager._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_TagStateManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TagStateManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TagStateManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TagStateManager);
  }
}

//********************************************************************
//*** Py Init Code For .. IESDataset | IESDataset
//********************************************************************
static PyMethodDef Dtool_Methods_IESDataset[] = {
  {"set_vertical_angles", &Dtool_IESDataset_set_vertical_angles_86, METH_O, (const char *)Dtool_IESDataset_set_vertical_angles_86_comment},
  {"set_horizontal_angles", &Dtool_IESDataset_set_horizontal_angles_87, METH_O, (const char *)Dtool_IESDataset_set_horizontal_angles_87_comment},
  {"set_candela_values", &Dtool_IESDataset_set_candela_values_88, METH_O, (const char *)Dtool_IESDataset_set_candela_values_88_comment},
  {"generate_dataset_texture_into", (PyCFunction) &Dtool_IESDataset_generate_dataset_texture_into_89, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_IESDataset_generate_dataset_texture_into_89_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_IESDataset = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_IESDataset = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.IESDataset",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_IESDataset,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_IESDataset,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief This class generates a LUT from IES data.\n"
    " * @details This class is used by the IESLoader to generate a LUT texture which\n"
    " *   is used in the shaders to perform IES lighting. It takes a set of vertical\n"
    " *   and horizontal angles, as well as a set of candela values, which then are\n"
    " *   lineary interpolated onto a 2D LUT Texture.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_IESDataset,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_IESDataset,
    PyType_GenericAlloc,
    Dtool_new_IESDataset,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IESDataset,
  Dtool_UpcastInterface_IESDataset,
  Dtool_DowncastInterface_IESDataset,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_IESDataset(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_IESDataset._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_IESDataset._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IESDataset) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IESDataset)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IESDataset);
  }
}

//********************************************************************
//*** Py Init Code For .. ShadowAtlas | ShadowAtlas
//********************************************************************
static PyMethodDef Dtool_Methods_ShadowAtlas[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ShadowAtlas = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_ShadowAtlas = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.ShadowAtlas",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ShadowAtlas,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ShadowAtlas,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Class which manages distributing shadow maps in an atlas.\n"
    " * @details This class manages the shadow atlas. It handles finding and reserving\n"
    " *   space for new shadow maps.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ShadowAtlas,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ShadowAtlas,
    PyType_GenericAlloc,
    Dtool_new_ShadowAtlas,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShadowAtlas,
  Dtool_UpcastInterface_ShadowAtlas,
  Dtool_DowncastInterface_ShadowAtlas,
  (CoerceFunction)Dtool_ConstCoerce_ShadowAtlas,
  (CoerceFunction)Dtool_Coerce_ShadowAtlas,
};

static void Dtool_PyModuleClassInit_ShadowAtlas(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ShadowAtlas._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ShadowAtlas._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShadowAtlas) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShadowAtlas)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShadowAtlas);
  }
}

//********************************************************************
//*** Py Init Code For .. InternalLightManager | InternalLightManager
//********************************************************************
static PyMethodDef Dtool_Methods_InternalLightManager[] = {
  {"add_light", &Dtool_InternalLightManager_add_light_96, METH_O, (const char *)Dtool_InternalLightManager_add_light_96_comment},
  {"remove_light", &Dtool_InternalLightManager_remove_light_97, METH_O, (const char *)Dtool_InternalLightManager_remove_light_97_comment},
  {"update", &Dtool_InternalLightManager_update_98, METH_NOARGS, (const char *)Dtool_InternalLightManager_update_98_comment},
  {"get_max_light_index", &Dtool_InternalLightManager_get_max_light_index_99, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_max_light_index_99_comment},
  {"get_num_lights", &Dtool_InternalLightManager_get_num_lights_100, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_num_lights_100_comment},
  {"get_num_shadow_sources", &Dtool_InternalLightManager_get_num_shadow_sources_101, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_num_shadow_sources_101_comment},
  {"set_command_list", &Dtool_InternalLightManager_set_command_list_102, METH_O, (const char *)Dtool_InternalLightManager_set_command_list_102_comment},
  {"set_shadow_manager", &Dtool_InternalLightManager_set_shadow_manager_103, METH_O, (const char *)Dtool_InternalLightManager_set_shadow_manager_103_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_InternalLightManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_InternalLightManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.InternalLightManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_InternalLightManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_InternalLightManager,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Internal class used for handling lights and shadows.\n"
    " * @details This is the internal class used by the pipeline to handle all\n"
    " *   lights and shadows. It stores references to the lights, manages handling\n"
    " *   the light and shadow slots, and also communicates with the GPU with the\n"
    " *   GPUCommandQueue to store light and shadow source data.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_InternalLightManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_InternalLightManager,
    PyType_GenericAlloc,
    Dtool_new_InternalLightManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InternalLightManager,
  Dtool_UpcastInterface_InternalLightManager,
  Dtool_DowncastInterface_InternalLightManager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_InternalLightManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_InternalLightManager._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_InternalLightManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InternalLightManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InternalLightManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InternalLightManager);
  }
}

//********************************************************************
//*** Py Init Code For .. PSSMCameraRig | PSSMCameraRig
//********************************************************************
static PyMethodDef Dtool_Methods_PSSMCameraRig[] = {
  {"set_pssm_distance", &Dtool_PSSMCameraRig_set_pssm_distance_108, METH_O, (const char *)Dtool_PSSMCameraRig_set_pssm_distance_108_comment},
  {"set_sun_distance", &Dtool_PSSMCameraRig_set_sun_distance_109, METH_O, (const char *)Dtool_PSSMCameraRig_set_sun_distance_109_comment},
  {"set_use_fixed_film_size", &Dtool_PSSMCameraRig_set_use_fixed_film_size_110, METH_O, (const char *)Dtool_PSSMCameraRig_set_use_fixed_film_size_110_comment},
  {"set_resolution", &Dtool_PSSMCameraRig_set_resolution_111, METH_O, (const char *)Dtool_PSSMCameraRig_set_resolution_111_comment},
  {"set_use_stable_csm", &Dtool_PSSMCameraRig_set_use_stable_csm_112, METH_O, (const char *)Dtool_PSSMCameraRig_set_use_stable_csm_112_comment},
  {"set_logarithmic_factor", &Dtool_PSSMCameraRig_set_logarithmic_factor_113, METH_O, (const char *)Dtool_PSSMCameraRig_set_logarithmic_factor_113_comment},
  {"set_border_bias", &Dtool_PSSMCameraRig_set_border_bias_114, METH_O, (const char *)Dtool_PSSMCameraRig_set_border_bias_114_comment},
  {"update", (PyCFunction) &Dtool_PSSMCameraRig_update_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PSSMCameraRig_update_115_comment},
  {"reset_film_size_cache", &Dtool_PSSMCameraRig_reset_film_size_cache_116, METH_NOARGS, (const char *)Dtool_PSSMCameraRig_reset_film_size_cache_116_comment},
  {"get_camera", &Dtool_PSSMCameraRig_get_camera_117, METH_O, (const char *)Dtool_PSSMCameraRig_get_camera_117_comment},
  {"reparent_to", &Dtool_PSSMCameraRig_reparent_to_118, METH_O, (const char *)Dtool_PSSMCameraRig_reparent_to_118_comment},
  {"get_mvp_array", &Dtool_PSSMCameraRig_get_mvp_array_119, METH_NOARGS, (const char *)Dtool_PSSMCameraRig_get_mvp_array_119_comment},
  {"get_nearfar_array", &Dtool_PSSMCameraRig_get_nearfar_array_120, METH_NOARGS, (const char *)Dtool_PSSMCameraRig_get_nearfar_array_120_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PSSMCameraRig = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_PSSMCameraRig = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.PSSMCameraRig",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PSSMCameraRig,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PSSMCameraRig,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Main class used for handling PSSM\n"
    " * @details This is the main class for supporting PSSM, it is used by the PSSM\n"
    " *   plugin to compute the position of the splits.\n"
    " *\n"
    " *   It supports handling a varying amount of cameras, and fitting those cameras\n"
    " *   into the main camera frustum, to render distant shadows. It also supports\n"
    " *   various optimizations for fitting the frustum, e.g. rotating the sources\n"
    " *   to get a better coverage.\n"
    " *\n"
    " *   It also provides methods to get arrays of data about the used cameras\n"
    " *   view-projection matrices and their near and far plane, which is required for\n"
    " *   processing the data in the shadow sampling shader.\n"
    " *\n"
    " *   In this class, there is often referred to \"Splits\" or also called \"Cascades\".\n"
    " *   These denote the different cameras which are used to split the frustum,\n"
    " *   and are a common term related to the PSSM algorithm.\n"
    " *\n"
    " *   To understand the functionality of this class, a detailed knowledge of the\n"
    " *   PSSM algorithm is helpful.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PSSMCameraRig,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PSSMCameraRig,
    PyType_GenericAlloc,
    Dtool_new_PSSMCameraRig,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PSSMCameraRig,
  Dtool_UpcastInterface_PSSMCameraRig,
  Dtool_DowncastInterface_PSSMCameraRig,
  (CoerceFunction)Dtool_ConstCoerce_PSSMCameraRig,
  (CoerceFunction)Dtool_Coerce_PSSMCameraRig,
};

static void Dtool_PyModuleClassInit_PSSMCameraRig(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PSSMCameraRig._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PSSMCameraRig._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PSSMCameraRig) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PSSMCameraRig)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PSSMCameraRig);
  }
}

//********************************************************************
//*** Py Init Code For .. RPPointLight | RPPointLight
//********************************************************************
static PyMethodDef Dtool_Methods_RPPointLight[] = {
  {"set_radius", &Dtool_RPPointLight_set_radius_123, METH_O, (const char *)Dtool_RPPointLight_set_radius_123_comment},
  {"get_radius", &Dtool_RPPointLight_get_radius_124, METH_NOARGS, (const char *)Dtool_RPPointLight_get_radius_124_comment},
  {"set_inner_radius", &Dtool_RPPointLight_set_inner_radius_126, METH_O, (const char *)Dtool_RPPointLight_set_inner_radius_126_comment},
  {"get_inner_radius", &Dtool_RPPointLight_get_inner_radius_127, METH_NOARGS, (const char *)Dtool_RPPointLight_get_inner_radius_127_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_RPPointLight[] = {
  {(char *)"radius", &Dtool_RPPointLight_radius_Getter, &Dtool_RPPointLight_radius_Setter, NULL, NULL},
  {(char *)"inner_radius", &Dtool_RPPointLight_inner_radius_Getter, &Dtool_RPPointLight_inner_radius_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_RPPointLight = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RPPointLight = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_RPPointLight = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_RPPointLight = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_RPPointLight = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.RPPointLight",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_RPPointLight,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_RPPointLight,
    &Dtool_SequenceMethods_RPPointLight,
    &Dtool_MappingMethods_RPPointLight,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_RPPointLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief PointLight class\n"
    " * @details This represents a point light, a light which has a position and\n"
    " *   radius. Checkout the RenderPipeline documentation for more information\n"
    " *   about this type of light.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_RPPointLight,
    0, // tp_members
    Dtool_Properties_RPPointLight,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_RPPointLight,
    PyType_GenericAlloc,
    Dtool_new_RPPointLight,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RPPointLight,
  Dtool_UpcastInterface_RPPointLight,
  Dtool_DowncastInterface_RPPointLight,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_RPPointLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RPLight(NULL);
    Dtool_RPPointLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RPLight);
    PyObject *dict = PyDict_New();
    Dtool_RPPointLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RPPointLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RPPointLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RPPointLight);
  }
}

//********************************************************************
//*** Py Init Code For .. RPSpotLight | RPSpotLight
//********************************************************************
static PyMethodDef Dtool_Methods_RPSpotLight[] = {
  {"set_radius", &Dtool_RPSpotLight_set_radius_132, METH_O, (const char *)Dtool_RPSpotLight_set_radius_132_comment},
  {"get_radius", &Dtool_RPSpotLight_get_radius_133, METH_NOARGS, (const char *)Dtool_RPSpotLight_get_radius_133_comment},
  {"set_fov", &Dtool_RPSpotLight_set_fov_135, METH_O, (const char *)Dtool_RPSpotLight_set_fov_135_comment},
  {"get_fov", &Dtool_RPSpotLight_get_fov_136, METH_NOARGS, (const char *)Dtool_RPSpotLight_get_fov_136_comment},
  {"set_direction", (PyCFunction) &Dtool_RPSpotLight_set_direction_138, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPSpotLight_set_direction_138_comment},
  {"get_direction", &Dtool_RPSpotLight_get_direction_139, METH_NOARGS, (const char *)Dtool_RPSpotLight_get_direction_139_comment},
  {"look_at", (PyCFunction) &Dtool_RPSpotLight_look_at_140, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPSpotLight_look_at_140_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_RPSpotLight[] = {
  {(char *)"radius", &Dtool_RPSpotLight_radius_Getter, &Dtool_RPSpotLight_radius_Setter, NULL, NULL},
  {(char *)"fov", &Dtool_RPSpotLight_fov_Getter, &Dtool_RPSpotLight_fov_Setter, NULL, NULL},
  {(char *)"direction", &Dtool_RPSpotLight_direction_Getter, &Dtool_RPSpotLight_direction_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_RPSpotLight = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RPSpotLight = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_RPSpotLight = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_RPSpotLight = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_RPSpotLight = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.RPSpotLight",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_RPSpotLight,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_RPSpotLight,
    &Dtool_SequenceMethods_RPSpotLight,
    &Dtool_MappingMethods_RPSpotLight,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_RPSpotLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief SpotLight class\n"
    " * @details This represents a spot light, a light which has a position, radius,\n"
    " *   direction and FoV. Checkout the RenderPipeline documentation for more\n"
    " *   information about this type of light.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_RPSpotLight,
    0, // tp_members
    Dtool_Properties_RPSpotLight,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_RPSpotLight,
    PyType_GenericAlloc,
    Dtool_new_RPSpotLight,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RPSpotLight,
  Dtool_UpcastInterface_RPSpotLight,
  Dtool_DowncastInterface_RPSpotLight,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_RPSpotLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RPLight(NULL);
    Dtool_RPSpotLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RPLight);
    PyObject *dict = PyDict_New();
    Dtool_RPSpotLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RPSpotLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RPSpotLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RPSpotLight);
  }
}

//********************************************************************
//*** Py Init Code For .. MeshSplitterWriter | MeshSplitterWriter
//********************************************************************
static PyMethodDef Dtool_Methods_MeshSplitterWriter[] = {
  {"add_geom", &Dtool_MeshSplitterWriter_add_geom_146, METH_O, (const char *)Dtool_MeshSplitterWriter_add_geom_146_comment},
  {"process", &Dtool_MeshSplitterWriter_process_147, METH_O, (const char *)Dtool_MeshSplitterWriter_process_147_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MeshSplitterWriter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_MeshSplitterWriter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.MeshSplitterWriter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MeshSplitterWriter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MeshSplitterWriter,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// This small class just wraps arround mesh splitter and handles the combining of geoms\n"
    "// and the writing of the .rpsg files",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MeshSplitterWriter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MeshSplitterWriter,
    PyType_GenericAlloc,
    Dtool_new_MeshSplitterWriter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MeshSplitterWriter,
  Dtool_UpcastInterface_MeshSplitterWriter,
  Dtool_DowncastInterface_MeshSplitterWriter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MeshSplitterWriter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MeshSplitterWriter._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_MeshSplitterWriter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MeshSplitterWriter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MeshSplitterWriter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MeshSplitterWriter);
  }
}

//********************************************************************
//*** Py Init Code For .. SGNode | SGNode
//********************************************************************
static PyMethodDef Dtool_Methods_SGNode[] = {
  {"get_class_type", &Dtool_SGNode_get_class_type_151, METH_NOARGS | METH_STATIC, (const char *)Dtool_SGNode_get_class_type_151_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SGNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SGNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SGNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SGNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SGNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.SGNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SGNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SGNode,
    &Dtool_SequenceMethods_SGNode,
    &Dtool_MappingMethods_SGNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SGNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// This class extends from pandanode and can be attached to the scene graph\n"
    "// to be manipulated like a usual panda node, however, when rendering it it\n"
    "// only attaches its triangle dataset to a list of rendered datasets instead\n"
    "// of emitting geometry",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SGNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SGNode,
    PyType_GenericAlloc,
    Dtool_new_SGNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SGNode,
  Dtool_UpcastInterface_SGNode,
  Dtool_DowncastInterface_SGNode,
  (CoerceFunction)Dtool_ConstCoerce_SGNode,
  (CoerceFunction)Dtool_Coerce_SGNode,
};

static void Dtool_PyModuleClassInit_SGNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_SGNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_SGNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SGNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SGNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SGNode);
  }
}

//********************************************************************
//*** Py Init Code For .. SGRenderNode | SGRenderNode
//********************************************************************
static PyMethodDef Dtool_Methods_SGRenderNode[] = {
  {"get_class_type", &Dtool_SGRenderNode_get_class_type_154, METH_NOARGS | METH_STATIC, (const char *)Dtool_SGRenderNode_get_class_type_154_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SGRenderNode = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SGRenderNode = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SGRenderNode = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SGRenderNode = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SGRenderNode = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.SGRenderNode",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SGRenderNode,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SGRenderNode,
    &Dtool_SequenceMethods_SGRenderNode,
    &Dtool_MappingMethods_SGRenderNode,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SGRenderNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// This node is attached to the scene graph and called last, it renders all\n"
    "// static geometry to a buffer",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SGRenderNode,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SGRenderNode,
    PyType_GenericAlloc,
    Dtool_new_SGRenderNode,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SGRenderNode,
  Dtool_UpcastInterface_SGRenderNode,
  Dtool_DowncastInterface_SGRenderNode,
  (CoerceFunction)Dtool_ConstCoerce_SGRenderNode,
  (CoerceFunction)Dtool_Coerce_SGRenderNode,
};

static void Dtool_PyModuleClassInit_SGRenderNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_SGRenderNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_SGRenderNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SGRenderNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SGRenderNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SGRenderNode);
  }
}

//********************************************************************
//*** Py Init Code For .. StaticGeometryHandler | StaticGeometryHandler
//********************************************************************
static PyMethodDef Dtool_Methods_StaticGeometryHandler[] = {
  {"load_dataset", &Dtool_StaticGeometryHandler_load_dataset_158, METH_O, (const char *)Dtool_StaticGeometryHandler_load_dataset_158_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_StaticGeometryHandler = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
};

struct Dtool_PyTypedObject Dtool_StaticGeometryHandler = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "RSNative.StaticGeometryHandler",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_StaticGeometryHandler,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_StaticGeometryHandler,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_StaticGeometryHandler,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_StaticGeometryHandler,
    PyType_GenericAlloc,
    Dtool_new_StaticGeometryHandler,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StaticGeometryHandler,
  Dtool_UpcastInterface_StaticGeometryHandler,
  Dtool_DowncastInterface_StaticGeometryHandler,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_StaticGeometryHandler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StaticGeometryHandler._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_StaticGeometryHandler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StaticGeometryHandler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StaticGeometryHandler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StaticGeometryHandler);
  }
}


//********************************************************************
//*** Module Object Linker ..
//********************************************************************
void Dtool_RSNative_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("GPUCommand", Dtool_GPUCommand);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("GPUCommandList", Dtool_GPUCommandList);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("RPLight", Dtool_RPLight);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ShadowManager", Dtool_ShadowManager);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TagStateManager", Dtool_TagStateManager);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("IESDataset", Dtool_IESDataset);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ShadowAtlas", Dtool_ShadowAtlas);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("InternalLightManager", Dtool_InternalLightManager);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PSSMCameraRig", Dtool_PSSMCameraRig);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("RPPointLight", Dtool_RPPointLight);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("RPSpotLight", Dtool_RPSpotLight);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("MeshSplitterWriter", Dtool_MeshSplitterWriter);
#endif
  Dtool_SGNode._type = SGNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_SGNode);
  Dtool_SGRenderNode._type = SGRenderNode::get_class_type();
  RegisterRuntimeTypedClass(Dtool_SGRenderNode);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("StaticGeometryHandler", Dtool_StaticGeometryHandler);
#endif
}

void Dtool_RSNative_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_PointerToArray_unsigned_char = LookupNamedClass("PointerToArray< unsigned char >");
  Dtool_Ptr_LVecBase3i = LookupRuntimeTypedClass(LVecBase3i::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_LMatrix4f = LookupRuntimeTypedClass(LMatrix4f::get_class_type());
  Dtool_Ptr_PointerToArray_float = LookupNamedClass("PointerToArray< float >");
  Dtool_Ptr_LVecBase4i = LookupRuntimeTypedClass(LVecBase4i::get_class_type());
  Dtool_Ptr_LMatrix3f = LookupRuntimeTypedClass(LMatrix3f::get_class_type());
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_Texture = LookupRuntimeTypedClass(Texture::get_class_type());
  Dtool_Ptr_BitMask_PN_uint32_32 = LookupRuntimeTypedClass(BitMask< PN_uint32, 32 >::get_class_type());
  Dtool_Ptr_Geom = LookupRuntimeTypedClass(Geom::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_PointerToArray_UnalignedLMatrix4f = LookupNamedClass("PointerToArray< UnalignedLMatrix4f >");
  Dtool_Ptr_PointerToArray_LVecBase2f = LookupNamedClass("PointerToArray< LVecBase2f >");
  Dtool_Ptr_Shader = LookupRuntimeTypedClass(Shader::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_Camera = LookupRuntimeTypedClass(Camera::get_class_type());
  Dtool_Ptr_GraphicsOutput = LookupRuntimeTypedClass(GraphicsOutput::get_class_type());
#endif
}

void Dtool_RSNative_BuildInstants(PyObject *module) {
  (void) module;
  // Module init upcall for GPUCommand
  // GPUCommand
  Dtool_PyModuleClassInit_GPUCommand(module);
  PyModule_AddObject(module, "GPUCommand", (PyObject *)&Dtool_GPUCommand);
  // Module init upcall for GPUCommandList
  // GPUCommandList
  Dtool_PyModuleClassInit_GPUCommandList(module);
  PyModule_AddObject(module, "GPUCommandList", (PyObject *)&Dtool_GPUCommandList);
  // Module init upcall for RPLight
  // RPLight
  Dtool_PyModuleClassInit_RPLight(module);
  PyModule_AddObject(module, "RPLight", (PyObject *)&Dtool_RPLight);
  // Module init upcall for ShadowManager
  // ShadowManager
  Dtool_PyModuleClassInit_ShadowManager(module);
  PyModule_AddObject(module, "ShadowManager", (PyObject *)&Dtool_ShadowManager);
  // Module init upcall for TagStateManager
  // TagStateManager
  Dtool_PyModuleClassInit_TagStateManager(module);
  PyModule_AddObject(module, "TagStateManager", (PyObject *)&Dtool_TagStateManager);
  // Module init upcall for IESDataset
  // IESDataset
  Dtool_PyModuleClassInit_IESDataset(module);
  PyModule_AddObject(module, "IESDataset", (PyObject *)&Dtool_IESDataset);
  // Module init upcall for ShadowAtlas
  // ShadowAtlas
  Dtool_PyModuleClassInit_ShadowAtlas(module);
  PyModule_AddObject(module, "ShadowAtlas", (PyObject *)&Dtool_ShadowAtlas);
  // Module init upcall for InternalLightManager
  // InternalLightManager
  Dtool_PyModuleClassInit_InternalLightManager(module);
  PyModule_AddObject(module, "InternalLightManager", (PyObject *)&Dtool_InternalLightManager);
  // Module init upcall for PSSMCameraRig
  // PSSMCameraRig
  Dtool_PyModuleClassInit_PSSMCameraRig(module);
  PyModule_AddObject(module, "PSSMCameraRig", (PyObject *)&Dtool_PSSMCameraRig);
  // Module init upcall for RPPointLight
  // RPPointLight
  Dtool_PyModuleClassInit_RPPointLight(module);
  PyModule_AddObject(module, "RPPointLight", (PyObject *)&Dtool_RPPointLight);
  // Module init upcall for RPSpotLight
  // RPSpotLight
  Dtool_PyModuleClassInit_RPSpotLight(module);
  PyModule_AddObject(module, "RPSpotLight", (PyObject *)&Dtool_RPSpotLight);
  // Module init upcall for MeshSplitterWriter
  // MeshSplitterWriter
  Dtool_PyModuleClassInit_MeshSplitterWriter(module);
  PyModule_AddObject(module, "MeshSplitterWriter", (PyObject *)&Dtool_MeshSplitterWriter);
  // Module init upcall for SGNode
  // SGNode
  Dtool_PyModuleClassInit_SGNode(module);
  PyModule_AddObject(module, "SGNode", (PyObject *)&Dtool_SGNode);
  // Module init upcall for SGRenderNode
  // SGRenderNode
  Dtool_PyModuleClassInit_SGRenderNode(module);
  PyModule_AddObject(module, "SGRenderNode", (PyObject *)&Dtool_SGRenderNode);
  // Module init upcall for StaticGeometryHandler
  // StaticGeometryHandler
  Dtool_PyModuleClassInit_StaticGeometryHandler(module);
  PyModule_AddObject(module, "StaticGeometryHandler", (PyObject *)&Dtool_StaticGeometryHandler);
//********************************************************************
//*** Module Init Upcall ..  Externally Defined Class
//********************************************************************
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef RSNative_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1455352308,  /* file_identifier */
  "RSNative",  /* library_name */
  "g05Y",  /* library_hash_name */
  "RSNative",  /* module_name */
  "Interrogate.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  386  /* next_index */
};

Configure(_in_configure_RSNative);
ConfigureFn(_in_configure_RSNative) {
  interrogate_request_module(&_in_module_def);
}

