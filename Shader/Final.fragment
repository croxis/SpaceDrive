#version 400



#extension GL_EXT_shader_image_load_store : enable

#pragma include "Includes/Configuration.include"
#pragma include "Includes/PositionReconstruction.include"
#pragma include "Includes/ChromaticAbberation.include"
#pragma include "Includes/ColorCorrection.include"


in vec2 texcoord;

uniform sampler2D velocityTex;
uniform sampler2D colorTex;


uniform sampler2D colorLUT;
// uniform sampler2D depthTex;

uniform float motionBlurFactor;

uniform sampler2D debugTex;

out vec3 result;


layout (rgba32f) uniform image2D lastFramePosition;
layout (r16f) uniform image2D lastFrameOcclusion;


uniform sampler2D currentFramePosition;
uniform sampler2D computedOcclusion;

void main() {



    // Store last frame position and occlusion
    ivec2 intCoords = ivec2(gl_FragCoord.xy / 2.0);
    vec3 lastPosition = texelFetch(currentFramePosition, intCoords * 2, 0).xyz;
    imageStore(lastFramePosition, intCoords, vec4(lastPosition, 1.0));

    #ifdef USE_OCCLUSION
        float lastOcclusion = texelFetch(computedOcclusion, intCoords, 0).x;
        imageStore(lastFrameOcclusion, intCoords, vec4(lastOcclusion));
    #endif


    // Fetch screen size, so we don't have to pass it as a shader input
    ivec2 screenSize = textureSize(colorTex, 0);

    // Screen coordinate (as int vec)
    ivec2 screenCoord = ivec2(gl_FragCoord.xy);

    // Color LUT
    #ifndef DEBUG_DISABLE_COLOR_CORRECTION

        
        // Dont color correct when showing occlusion
        #ifndef DEBUG_RM_OCCLUSION
        
        // Chromatic abberation
        result = applyChromaticAbberation(colorTex, texcoord, 1.0);
        
        // Color LUT
        result = applyColorLUT(colorLUT, result);

        #endif

    #else
        result =  textureLod(colorTex, texcoord, 0).xyz;
    #endif

         
    // Motion Blur
    #ifdef USE_MOTION_BLUR  

        // Currently disabled. Have to improve it first.
        
        #if 0
        vec2 pixelVelocity = textureLod(velocityTex, texcoord, 0).xy
            / 255.0 * motionBlurFactor * 1.2;

        float velStrength = length(pixelVelocity);

        // Motion blur
        vec3 motionResult = textureLod(colorTex, texcoord, 0).xyz;
        float motionDivide = 0.5;

        for (int i = 1; i < MOTION_BLUR_SAMPLES; i++) {
            vec2 offset = pixelVelocity * (float(i) / float(MOTION_BLUR_SAMPLES - 1) - 0.5);
            // motionResult += textureLod(colorTex, texcoord + offset, 0).rgb;
            vec3 motionSample = textureLod(colorTex, texcoord + offset, 0).rgb;
            vec2 motionVelocity = textureLod(velocityTex, texcoord + offset, 0).xy
                / 255.0 * motionBlurFactor * 1.2;
            float motionFactor =  saturate(1.0 - max(0.0, distance(motionVelocity, pixelVelocity) ) * 2000.0);
            motionResult += motionSample * motionFactor;
            motionDivide += motionFactor;


        }
        motionResult /= motionDivide;

        result = mix(result, motionResult, saturate(velStrength*200.0) );
        // result = mix(result, motionResult, 1.0 );
    

        #ifdef DEBUG_DISABLE_MOTIONBLUR
            result = textureLod(colorTex, texcoord, 0).rgb;
        #endif

        #endif
    #else
    #endif

    float vignett = 1.0 - smoothstep(0, 1, 
        (length( (texcoord - vec2(0.5, 0.5)) * vec2(1.2, 1.0)  ) - 0.22) ) * 1.0;
    result *= vignett;

}
