#pragma once



// https://gist.github.com/fisch0920/6770346

// number of directions to sample in UV space
#define HBAO_NUM_SAMPLE_DIRECTIONS 8
#define HBAO_TANGENT_BIAS 0.2
#define HBAO_NUM_SAMPLING_STEPS 4
#define HBAO_SAMPLING_STEP 0.004

#define HBAO_SCALE 0.15
#define HBAO_SAMPLING_RADIUS 2.0


#define OCCLUSION_RESULT_TYPE float
#define OCCLUSION_PER_LIGHT_SEND_PARAMETERS , occlusionTotal, occlusionResult 
#define OCCLUSION_PER_LIGHT_RECV_PARAMETERS , inout float occlusionTotal, float occlusionResult

#define APPLY_OCCLUSION() occlusionTotal += occlusionResult * attenuation * OCCLUSION_STRENGTH * saturate(1.1-shadowFactor);


uniform sampler2D viewSpaceNormals;
uniform sampler2D viewSpacePosition;



vec3 hbao_getPositionViewSpace(vec2 uv) {
  return texture(viewSpacePosition, uv).xyz;
}

const float TWO_PI = 2.0 * M_PI;
const float hbaoTheta = TWO_PI / HBAO_NUM_SAMPLE_DIRECTIONS;

OCCLUSION_RESULT_TYPE computeOcclusion(vec2 coord, ivec2 coordInt, float distanceToCamera) {

  vec3 viewPos = texture(viewSpacePosition, coord).xyz;
  vec3 viewNorm = texture(viewSpaceNormals, coord).xyz;

  float total = 0.0f;
  float sample_direction_increment = TWO_PI / HBAO_NUM_SAMPLE_DIRECTIONS;
 

  float hbaoScale = saturate(1.0 / distanceToCamera) * 10.0;

  for(uint i = 0; i < HBAO_NUM_SAMPLE_DIRECTIONS; i++)
  {
    // no jittering or randomization of sampling direction just yet
    float sampling_angle = i * sample_direction_increment; // azimuth angle theta in the paper
    vec2 sampleDir = vec2(cos(sampling_angle), sin(sampling_angle));
    // we will now march along sampleDir and calculate the horizon
    // horizon starts with the tangent plane to the surface, whose angle we can get from the normal
    float tangentAngle = acos(dot(vec3(sampleDir, 0), viewNorm)) - (0.5 * M_PI) + HBAO_TANGENT_BIAS;
    float horizonAngle = tangentAngle;
    vec3 lastDiff = vec3(0);
 
    for (uint j = 0; j < HBAO_NUM_SAMPLING_STEPS; j++)
    {
      // march along the sampling direction and see what the horizon is
      vec2 sampleOffset = float(j+1) * HBAO_SAMPLING_STEP * sampleDir * hbaoScale;
      vec2 offTex = coord + sampleOffset;
 
      vec3 off_viewPos = texture(viewSpacePosition, offTex).xyz;
      // we now have the view space position of the offset point
      vec3 diff = off_viewPos - viewPos;
      if (length(diff) < HBAO_SAMPLING_RADIUS)
      {
        // skip samples which are outside of our local sampling radius
        lastDiff = diff;
        float elevationAngle = atan(diff.z / length(diff.xy));
        horizonAngle = max(horizonAngle, elevationAngle);
      }
    } // sampling steps
 
    // the paper uses this attenuation but I like the other way better
    //float normDiff = length(lastDiff) / SAMPLING_RADIUS;
    //float attenuation = 1 - normDiff*normDiff;
    float attenuation = 1.0 / (1 + length(lastDiff));
    // now compare horizon angle to tangent angle to get ambient occlusion
    float occlusion = clamp(attenuation * (sin(horizonAngle) - sin(tangentAngle)), 0.0, 1.0);
    total += 1.0 - HBAO_SCALE*occlusion;
  } // sampling directions
 
  total /= HBAO_NUM_SAMPLE_DIRECTIONS;
  total = clamp(total, 0.0, 1.0);
  return total;

#if 0
  // return 1.0;
  
  vec3 originVS = hbao_getPositionViewSpace(coord);
  vec3 normalVS = texture(viewSpaceNormals, coord).xyz;

  float radiusSS = 0.0; // radius of influence in screen space
  float radiusWS = 0.0; // radius of influence in world space
  

  // return abs(normalVS.x);
  // radiusSS = hbaoSampleRadius;
  // vec4 temp0 = viewProjectionInverseMatrix * vec4(0.0, 0.0, -1.0, 1.0);
  // vec3 out0  = temp0.xyz;
  // vec4 temp1 = viewProjectionInverseMatrix * vec4(radiusSS, 0.0, -1.0, 1.0);
  // vec3 out1  = temp1.xyz;
  
  // NOTE (travis): empirically, the main introduction of artifacts with HBAO 
  // is having too large of a world-space radius; attempt to combat this issue by 
  // clamping the world-space radius based on the screen-space radius' projection
  // radiusWS = min(tan(radiusSS * uFOV / 2.0) * originVS.y / 2.0, length(out1 - out0));
  
  radiusWS = 0.5;
  radiusSS = saturate(1.0 / distanceToCamera) * 1.0;

  // early exit if the radius of influence is smaller than one fragment
  // since all samples would hit the current fragment.
  // if (dist > 120.0) {
  //   return 1.0;
  // }
  

  float cosTheta = cos(hbaoTheta);
  float sinTheta = sin(hbaoTheta);
  
  // matrix to create the sample directions
  mat2 deltaRotationMatrix = mat2(cosTheta, -sinTheta, sinTheta, cosTheta);
  
  // step vector in view space
  vec2 deltaUV = vec2(1.0, 0.0) * (radiusSS / (float(HBAO_NUM_SAMPLE_DIRECTIONS * HBAO_NUM_SAMPLE_STEPS) + 1.0));
  
  // we don't want to sample to the perimeter of R since those samples would be 
  // omitted by the distance attenuation (W(R) = 0 by definition)
  // Therefore we add a extra step and don't use the last sample.
  vec3 sampleNoise    = texture(noiseTexture, texcoord).xyz;
  sampleNoise.xy      = sampleNoise.xy * 2.0 - 1.0;

  sampleNoise = vec3(0);

  mat2 rotationMatrix = mat2(sampleNoise.x, -sampleNoise.y, 
                             sampleNoise.y,  sampleNoise.x);
  

  float minBias = hbaoAngleBias + distanceToCamera * 0.005;
  // apply a random rotation to the base step vector
  // deltaUV = rotationMatrix * deltaUV;
  
  float jitter = sampleNoise.z+1.0;
  jitter = 0.0;
  float occlusion = 0.0;
  
  for (int i = 0; i < HBAO_NUM_SAMPLE_DIRECTIONS; ++i) {

    // incrementally rotate sample direction
    deltaUV = deltaRotationMatrix * deltaUV;
    
    vec2 sampleDirUV = deltaUV;
    float oldAngle   = minBias;
    
    for (int j = 0; j < HBAO_NUM_SAMPLE_STEPS; ++j) {
      vec2 sampleUV     = texcoord + (jitter + float(j)) * sampleDirUV;
      vec3 sampleVS     = texture(viewSpacePosition, sampleUV).xyz;
      vec3 sampleDirVS  = (sampleVS - originVS);
      
      // angle between fragment tangent and the sample
      float gamma = (M_PI / 2.0) - acos(dot(normalVS, normalize(sampleDirVS)));
      
      if (gamma > oldAngle) {
        float value = sin(gamma) - sin(oldAngle);
        
#if HBAO_APPLY_ATTENUATION
        // distance between original and sample points
        float attenuation = clamp(1.0 - pow(length(sampleDirVS) / radiusWS, 2.0), 0.0, 1.0);
        occlusion += attenuation * value;
#else
        occlusion += value;
#endif
        oldAngle = gamma;
      }
    }
  }
  
  occlusion = 1.0 - occlusion / float(HBAO_NUM_SAMPLE_DIRECTIONS);
  occlusion = clamp(pow(occlusion, 1.0 + hbaoIntensity), 0.0, 1.0);
  // result = vec4(occlusion, occlusion, occlusion, 1.0);
  return occlusion;
#endif

}