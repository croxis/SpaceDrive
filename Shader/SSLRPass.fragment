#version 400


// #pragma optionNV (unroll all)

#extension GL_EXT_shader_image_load_store : enable

#pragma include "Includes/Configuration.include"
#pragma include "Includes/PositionReconstruction.include"
#pragma include "Includes/PoissonDisk.include"

in vec2 texcoord;

uniform sampler2D colorTex;
uniform sampler2D depthTex;
uniform sampler2D positionTex;
uniform sampler2D normalTex;

uniform vec3 cameraPosition;



uniform mat4 currentMVP;



out vec4 result;


#define SSLR_RADIUS_WORLD_SPACE 15.0
#define SSLR_PER_CONE_STEPS 64
#define SSLR_FADE_DISTANCE 0.06


#define SSLR_BINARY_SEARCH_STEPS 0



vec4 traceRayTo(vec3 endPosWorld, int steps, float depth, vec3 reflectionVector) {

    vec4 transformedTarget = currentMVP * vec4(endPosWorld, 1);
    transformedTarget.xyz = (transformedTarget.xyz / transformedTarget.w) * 0.5 + 0.5; 


    vec3 currentCoord = vec3(texcoord, depth);

    vec3 traceVector = normalize(transformedTarget.xyz - currentCoord) * 0.4;
    vec3 coordStep = traceVector / float(steps);


    // currentCoord += coordStep * 3.0;

    vec3 lastCoordPos = vec3(-1);


    vec3 pixelNormal = texture(normalTex, texcoord).xyz;
    vec3 pixelPos = texture(positionTex, texcoord).xyz;


    float foundDiff = 1.0;
    float maxDepthDiff = 0.0005 / (getLinearZFromZ(depth));
    maxDepthDiff = 0.0002;

    // Trace Ray
    for (int i = 0; i < steps; i++) {
        currentCoord += coordStep;
        // coordStep *= 1.2;

        if (any(greaterThan(currentCoord.xy, vec2(1.0))) || any(lessThan(currentCoord.xy, vec2(0.0)))) {
            break;
        }

        float sampleDepth = texture(depthTex, currentCoord.xy).x;
        float depthDiff = currentCoord.z - sampleDepth;

        if ( depthDiff > 0.0 && depthDiff < maxDepthDiff ) {

            vec3 sampleNormal = texture(normalTex, currentCoord.xy).xyz;
            vec3 samplePos = texture(positionTex, currentCoord.xy).xyz;

            float visibilityFactor = max(0.0, dot(-sampleNormal, pixelNormal));

            vec3 vectorToSurface = pixelPos - samplePos;

            visibilityFactor = dot(-vectorToSurface, pixelNormal);

            // visibilityFactor = 1.0;
            if ( visibilityFactor > 0.0) {

                // Found match
                lastCoordPos = currentCoord;
                foundDiff = depthDiff;
                break;

            }
        }

    }

    // Binary search
    vec3 coordBeforePos = lastCoordPos - coordStep;
    vec3 currentStep = coordStep;
    vec3 currentPos =  lastCoordPos;

    for (int i = 0; i < SSLR_BINARY_SEARCH_STEPS; i++) {

        vec3 coordTop = currentPos + currentStep * 0.5;
        vec3 coordBot = currentPos - currentStep * 0.5;

        float dTop = texture(depthTex, coordTop.xy).x;
        float dBot = texture(depthTex, coordBot.xy).x;

        float diffTop = abs(coordTop.z - dTop);
        float diffBot = abs(coordBot.z - dBot);
        
        if (diffTop <= 0.0) diffTop = 101.0;
        if (diffBot <= 0.0) diffTop = 100.0;

        currentStep *= 0.5;

        if (diffTop < diffBot) {
            currentPos += currentStep;
        } else {
            currentPos -= currentStep;
        }

    }   


    float fade = 1.0;

    float fadeArea = 0.2;

    fade *= saturate(currentPos.x / fadeArea);
    fade *= saturate( (1.0 - currentPos.x) / fadeArea);

    fade *= saturate(currentPos.y / fadeArea);
    fade *= saturate( (1.0 - currentPos.y) / fadeArea);

    fade *= saturate(SSLR_FADE_DISTANCE / distance(texcoord, currentPos.xy));

    float actualDepthDiff = abs(texture(depthTex, currentPos.xy).x - currentPos.z);
    // fade *= 1.0 - saturate(actualDepthDiff * 20000.0);


    float stepsDone = (currentPos.x - texcoord.x) / coordStep.x / SSLR_PER_CONE_STEPS;

    // fade *= 1.0 - saturate( saturate(stepsDone-0.3) * 10.0);



    // result = texture(colorTex, currentPos.xy) * fade;
    if (lastCoordPos.x < 0.0 || lastCoordPos.y < 0.0 || distance(lastCoordPos.xy, texcoord) < 0.007) {
        result = vec4(0);
    } else {
        result = texture(colorTex, lastCoordPos.xy);

        if (result.w < 0.5) {
            result = vec4(0);
        }
        // result = vec4(positionTex);


        result.xyz *= fade;
    }
    
    return result;
}

void main() {

    ivec2 coord = ivec2(gl_FragCoord.xy)*2;

    #if !defined(DEBUG_DISABLE_SSLR)
    // vec4 sslrPerPixelData = texelFetch(sslrDataTex, coord, 0);

    // vec3 reflectionVector = sslrPerPixelData.xyz;
    // float sslrFactor = sslrPerPixelData.w;



    // Fetch pixel data
    float pixelDepth = texelFetch(depthTex, coord, 0).x;
    vec3 pixelNormal = texelFetch(normalTex, coord, 0).xyz;
    vec3 pixelPos = texelFetch(positionTex, coord, 0).xyz;
    vec4 pixelColor = texelFetch(colorTex, coord, 0);

    float sslrFactor = pixelColor.w;

    // Ignore skybox
    if (pixelColor.w < 0.01) {
        result = vec4(0);
        return;
    }

    vec3 viewVector = normalize(pixelPos - cameraPosition);

    vec3 reflectionVector = reflect(viewVector, pixelNormal);




    float fragmentDistance = getLinearZFromZ(pixelDepth);

    // Convert reflection vector to world space
    // vec3 reflectionTargetWorld = pixelPos + normalize(reflectionVector) / distance(cameraPosition, pixelPos) * SSLR_RADIUS_WORLD_SPACE;
    vec3 reflectionTargetWorld = pixelPos + reflectionVector * SSLR_RADIUS_WORLD_SPACE;


    vec4 traceResult = traceRayTo(reflectionTargetWorld, SSLR_PER_CONE_STEPS, pixelDepth, reflectionVector);
    traceResult *= sslrFactor * 0.5;

    #if defined(DEBUG_VISUALIZATION_ACTIVE) && !defined(DEBUG_RM_SSLR)
        traceResult = vec4(0);
    #endif

    result = traceResult;


    #else

    result = vec4(0);

    #endif

}
