#version 400
#pragma file "ApplyLighting.fragment"

#extension GL_ARB_shader_image_load_store : enable


// TODO: Make some benchmarks to see wheter unrolling
// is faster or slower ..

// NOTICE: This pass does DSSDO.
// For dssdo, this option is !!REQUIRED!!
// Otherwise it runs poor as f*ck
#pragma optionNV (unroll all)

#include "Includes/Configuration.include"
#include "Includes/Light.include"
#include "Includes/Material.include"
#include "Includes/ShadowSource.include"
#include "Includes/ColorCorrection.include"
#include "Scattering/ScatteringOptions.include"

uniform sampler2D data0;
uniform sampler2D data1;
uniform sampler2D data2;
uniform sampler2D data3;

uniform sampler2D depth;


layout (r32i) readonly uniform iimage2D lightsPerTile;
layout (rgba16f) uniform image2D destination;


uniform Light lights[MAX_VISIBLE_LIGHTS]; 
uniform ShadowSource shadowSources[SHADOW_MAX_TOTAL_MAPS]; 
in vec2 texcoord;

uniform int temporalProjXOffs;
uniform sampler2D dssdoNoiseTex;


// Has to be after the uniforms
#include "Occlusion/Init.include"
#include "Includes/Lighting.include"
#include "Scattering/Final.include"

out vec4 lightingResult;

uniform sampler3D inscatterSampler;
uniform ScatteringOptions scatteringOptions;



vec3 HDR(vec3 L, float exposure) {
    L = L * exposure;
    L.r = L.r < 1.413 ? pow(L.r * 0.38317, 1.0 / 2.2) : 1.0 - exp(-L.r);
    L.g = L.g < 1.413 ? pow(L.g * 0.38317, 1.0 / 2.2) : 1.0 - exp(-L.g);
    L.b = L.b < 1.413 ? pow(L.b * 0.38317, 1.0 / 2.2) : 1.0 - exp(-L.b);
    return L;
}

void main() {


    // Compute texcoords
    ivec2 screenSize = textureSize(data0, 0);
    ivec2 screenCoord = ivec2(texcoord * vec2(screenSize.x + 1 , screenSize.y)); 

    // Shift x by 1 for temporal reprojection
    // Usually we would do just screenCoord.x += temporalProjXOffs
    // But using a checkerboard pattern removes a lot of artifacts, 
    // as you otherwise can see the line-pattern very obviously. Using
    // a checkerboard more gives a dithering effect, which is barely visible
    screenCoord.x += (screenCoord.x + screenCoord.y) % 2 == temporalProjXOffs ? -1 : 0;

    vec2 correctTexcoord = (vec2(screenCoord)+0.5) / vec2(screenSize);

    ivec2 precomputeCoord = ivec2( vec2(screenCoord) / 
        vec2(LIGHTING_COMPUTE_PATCH_SIZE_X, LIGHTING_COMPUTE_PATCH_SIZE_Y) ) * 8;


    // Extract material data
    vec4 target0data = texelFetch(data0, screenCoord, 0);
    vec4 target1data = texelFetch(data1, screenCoord, 0);
    vec4 target2data = texelFetch(data2, screenCoord, 0);
    vec4 target3data = texelFetch(data3, screenCoord, 0);
    Material material = unpackMaterial(target0data, target1data, target2data, target3data);

    #ifdef DEBUG_RM_LIGHTING
        material.baseColor = vec3(1);
    #endif

    // Fetch the light counts
    // We perform a min as it *might* be that we read a wrong value
    // from the texture. Imagine reading 123123123 from the texture,
    // then the light processing loop would be 123123123 iterations long,
    // which simply crashes the driver. With this method it would be only
    // a few hundreds, which is long but does not crash the driver.
    int countPointLight = min(MAX_POINT_LIGHTS, 
        imageLoad(lightsPerTile, precomputeCoord + ivec2(0,0)).r);

    int countPointLightShadow = min(MAX_SHADOW_POINT_LIGHTS, 
        imageLoad(lightsPerTile, precomputeCoord + ivec2(1,0)).r);

    int countDirectionalLight = min(MAX_SHADOW_POINT_LIGHTS, 
        imageLoad(lightsPerTile, precomputeCoord + ivec2(2,0)).r);

    int countDirectionalLightShadow = min(MAX_SHADOW_POINT_LIGHTS, 
        imageLoad(lightsPerTile, precomputeCoord + ivec2(3,0)).r);


    vec3 result = vec3(0);
    bool isSkybox = distance(material.position, cameraPosition) > SKYBOX_BEGIN;


    // Compute Occlusion
    float distanceToCamera = distance(cameraPosition, material.position);
    OCCLUSION_RESULT_TYPE occlusionResult = computeOcclusion(correctTexcoord, screenCoord, distanceToCamera);


    occlusionResult = 1.0 - occlusionResult;

    #ifdef DEBUG_DISABLE_OCCLUSION
        occlusionResult = 0.0;
    #endif

    // Metallic materials don't have much occlusion
    // occlusionResult = mix(occlusionResult, vec4(0.0), saturate(material.metallic-0.3) );

    float occlusionTotal = 0.0;

    // Compute point lights
    ivec2 baseOffset = precomputeCoord + ivec2(0,1);
    ivec2 currentOffset = ivec2(0);
    int currentLightId = 0;
    Light currentLight;

    for (int i = 0; i < countPointLight; i++) {
        currentOffset = ivec2(i % 8, i / 8);
        currentLightId = imageLoad(lightsPerTile, baseOffset + currentOffset).r;
        currentLight = lights[currentLightId];

        result += applyPointLight(currentLight, material OCCLUSION_PER_LIGHT_SEND_PARAMETERS );
    }

    // Compute shadow point lights
    baseOffset = precomputeCoord + ivec2(0,3);
    for (int i = 0; i < countPointLightShadow; i++) {
        currentOffset = ivec2(i % 8, i / 8);
        currentLightId = imageLoad(lightsPerTile, baseOffset + currentOffset).r;
        currentLight = lights[currentLightId];

        #if USE_SHADOWS
            result += applyPointLightWithShadow(currentLight, material OCCLUSION_PER_LIGHT_SEND_PARAMETERS );
        #else
            result += applyPointLight(currentLight, material OCCLUSION_PER_LIGHT_SEND_PARAMETERS );
        #endif
    }

    // Compute directinal lights
    baseOffset = precomputeCoord + ivec2(0,5);
    for (int i = 0; i < countDirectionalLight; i++) {
        currentOffset = ivec2(i % 8, i / 8);
        currentLightId = imageLoad(lightsPerTile, baseOffset + currentOffset).r;
        currentLight = lights[currentLightId];
        result += applyDirectionalLight(currentLight, material OCCLUSION_PER_LIGHT_SEND_PARAMETERS );
        
    }


    float inscatterFactor = 5.0;

    // Occlusion on skybox leads to artifacts
    if (isSkybox) {
        occlusionTotal = 0.0;
        material.position *= 10000.0;
        inscatterFactor = 1.0;
    }


    
    // SRGB
    result.xyz = sqrt(result.xyz);

    vec3 attenuation;
    float irradianceFactor;

    // Reconstruct position - otherwise we have precision errors
    vec3 viewDir = calculateSurfacePos(1.0, texcoord);
    
    vec3 scatteringResult = scatteringComputeInscatteredLight(
        scatteringOptions,
        material.position, 
        cameraPosition,
        viewDir, 
        inscatterSampler,
        // transmittanceSampler,
        attenuation, 
        irradianceFactor);

    #ifndef DEBUG_DISABLE_SCATTERING
        result += scatteringResult * inscatterFactor;
    #endif

    // result = HDR(result, 1.0);

    result = 1.0f - exp(-1.5 * result);

    #ifdef DEBUG_RM_BASECOLOR
        result = sqrt(material.baseColor);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_SPECULAR
        result = vec3(material.specular);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_OCCLUSION
        result = vec3(1);
        // occlusionTotal = 0.0;
        // result = vec3(occlusionResult);
    #endif

    #ifdef DEBUG_RM_METALLIC
        result = vec3(material.metallic);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_ROUGHNESS
        result = vec3(material.roughness);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_NORMAL
        result = vec3((material.normal));
        // result = vec3((material.normal.x));
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_SCATTERING
        result = scatteringResult * inscatterFactor;
    result = 1.0f - exp(-1.5 * result);
        occlusionTotal = 0.0;
    #endif

    lightingResult = vec4(result, 1.0 - saturate(occlusionTotal) );
}