#version 400
#pragma file "ApplyLighting.fragment"

#extension GL_ARB_shader_image_load_store : enable


// TODO: Make some benchmarks to see wheter unrolling
// is faster or slower ..

// NOTICE: This pass does DSSDO.
// For dssdo, this option is !!REQUIRED!!
// Otherwise it runs poor as f*ck
#pragma optionNV (unroll all)

#include "Includes/Configuration.include"
#include "Includes/Light.include"
#include "Includes/Material.include"
#include "Includes/ShadowSource.include"
#include "Includes/ColorCorrection.include"
#include "Includes/PositionReconstruction.include"
#include "Includes/SphericalHarmonics.include"


uniform sampler2D data0;
uniform sampler2D data1;
uniform sampler2D data2;
uniform sampler2D data3;

uniform sampler2D depth;


layout (r32i) readonly uniform iimage2D lightsPerTile;
layout (rgba16f) uniform image2D destination;


uniform Light lights[MAX_VISIBLE_LIGHTS]; 
uniform ShadowSource shadowSources[SHADOW_MAX_TOTAL_MAPS]; 
in vec2 texcoord;


#ifdef USE_TEMPORAL_REPROJECTION
    uniform int temporalProjXOffs;
#endif



#ifdef USE_GLOBAL_ILLUMINATION
    uniform vec3 GI_gridStart;
    uniform vec3 GI_gridEnd;
    uniform int GI_cascadeSize;
    uniform sampler2D GI_gridColor;
#endif


uniform sampler2D noiseTexture;

uniform vec3 cameraPosition;

// Has to be after the uniforms
#include "Occlusion/Init.include"
#include "Includes/Lighting.include"


out vec4 lightingResult;


#ifdef USE_SCATTERING

#include "Scattering/ScatteringOptions.include"
#include "Scattering/Final.include"

uniform sampler3D inscatterSampler;
uniform ScatteringOptions scatteringOptions;
#endif

void main() {


    // Compute texcoords
    ivec2 screenSize = textureSize(data0, 0);

    #ifdef USE_TEMPORAL_REPROJECTION
     ivec2 screenCoord = ivec2(texcoord * vec2(screenSize.x + 1 , screenSize.y)); 

        // Shift x by 1 for temporal reprojection
        // Usually we would do just screenCoord.x += temporalProjXOffs
        // But using a checkerboard pattern removes a lot of artifacts, 
        // as you otherwise can see the line-pattern very obviously. Using
        // a checkerboard more gives a dithering effect, which is barely visible
        screenCoord.x += (screenCoord.x + screenCoord.y) % 2 == temporalProjXOffs ? -1 : 0;
        vec2 correctTexcoord = (vec2(screenCoord)+0.5) / vec2(screenSize);

    #else

        ivec2 screenCoord = ivec2(gl_FragCoord.xy);
        vec2 correctTexcoord = texcoord;

    #endif

    ivec2 precomputeCoord = ivec2( vec2(screenCoord) / 
        vec2(LIGHTING_COMPUTE_PATCH_SIZE_X, LIGHTING_COMPUTE_PATCH_SIZE_Y) ) * 8;


    // Extract material data
    vec4 target0data = texelFetch(data0, screenCoord, 0);
    vec4 target1data = texelFetch(data1, screenCoord, 0);
    vec4 target2data = texelFetch(data2, screenCoord, 0);
    vec4 target3data = texelFetch(data3, screenCoord, 0);
    Material material = unpackMaterial(target0data, target1data, target2data, target3data);

    #ifdef DEBUG_RM_LIGHTING
        material.baseColor = vec3(1);
    #endif

    // Fetch the light counts
    // We perform a min as it *might* be that we read a wrong value
    // from the texture. Imagine reading 123123123 from the texture,
    // then the light processing loop would be 123123123 iterations long,
    // which simply crashes the driver. With this method it would be only
    // a few hundreds, which is long but does not crash the driver.
    int countPointLight = min(MAX_POINT_LIGHTS, 
        imageLoad(lightsPerTile, precomputeCoord + ivec2(0,0)).r);

    int countPointLightShadow = min(MAX_SHADOW_POINT_LIGHTS, 
        imageLoad(lightsPerTile, precomputeCoord + ivec2(1,0)).r);

    int countDirectionalLight = min(MAX_SHADOW_POINT_LIGHTS, 
        imageLoad(lightsPerTile, precomputeCoord + ivec2(2,0)).r);

    int countDirectionalLightShadow = min(MAX_SHADOW_POINT_LIGHTS, 
        imageLoad(lightsPerTile, precomputeCoord + ivec2(3,0)).r);


    vec3 result = vec3(0);

    // There should be a more elegant way, but for now it works
    bool isSkybox = distance(material.position, cameraPosition) > SKYBOX_BEGIN;


    vec3 shAmbient = computeSphericalHarmonics(material.normal, harmonicsTomb);
// harmonicsGroove
// harmonicsBeach
// harmonicsTomb

    // Compute Occlusion
    float distanceToCamera = distance(cameraPosition, material.position);
    OCCLUSION_RESULT_TYPE occlusionResult = computeOcclusion(correctTexcoord, screenCoord, distanceToCamera);


    occlusionResult = 1.0 - occlusionResult;

    #ifdef DEBUG_DISABLE_OCCLUSION
        occlusionResult = 0.0;
    #endif

    // Metallic materials don't have much occlusion
    // occlusionResult = mix(occlusionResult, vec4(0.0), saturate(material.metallic-0.3) );

    float occlusionTotal = 0.0;

    // Compute point lights
    ivec2 baseOffset = precomputeCoord + ivec2(0,1);
    ivec2 currentOffset = ivec2(0);
    int currentLightId = 0;
    Light currentLight;

    for (int i = 0; i < countPointLight; i++) {
        currentOffset = ivec2(i % 8, i / 8);
        currentLightId = imageLoad(lightsPerTile, baseOffset + currentOffset).r;
        currentLight = lights[currentLightId];

        result += applyPointLight(currentLight, material OCCLUSION_PER_LIGHT_SEND_PARAMETERS );
    }

    // Compute shadow point lights
    baseOffset = precomputeCoord + ivec2(0,3);
    for (int i = 0; i < countPointLightShadow; i++) {
        currentOffset = ivec2(i % 8, i / 8);
        currentLightId = imageLoad(lightsPerTile, baseOffset + currentOffset).r;
        currentLight = lights[currentLightId];

        #if USE_SHADOWS
            result += applyPointLightWithShadow(currentLight, material OCCLUSION_PER_LIGHT_SEND_PARAMETERS );
        #else
            result += applyPointLight(currentLight, material OCCLUSION_PER_LIGHT_SEND_PARAMETERS );
        #endif
    }

    // Compute directinal lights
    baseOffset = precomputeCoord + ivec2(0,5);
    for (int i = 0; i < countDirectionalLight; i++) {
        currentOffset = ivec2(i % 8, i / 8);
        currentLightId = imageLoad(lightsPerTile, baseOffset + currentOffset).r;
        currentLight = lights[currentLightId];
        result += applyDirectionalLight(currentLight, material OCCLUSION_PER_LIGHT_SEND_PARAMETERS );
    }


    // Compute shadowed directinal lights
    baseOffset = precomputeCoord + ivec2(0,6);
    for (int i = 0; i < countDirectionalLightShadow; i++) {
        currentOffset = ivec2(i % 8, i / 8);
        currentLightId = imageLoad(lightsPerTile, baseOffset + currentOffset).r;
        currentLight = lights[currentLightId];
        result += applyDirectionalLightWithShadow(currentLight, material, shAmbient OCCLUSION_PER_LIGHT_SEND_PARAMETERS );
    }

    // Reconstruct position - otherwise we have precision errors
    vec3 viewDir = calculateSurfacePos(1.0, texcoord);
    vec3 posFromDepth = calculateSurfacePos(texelFetch(depth, screenCoord, 0).x, texcoord);

    float inscatterFactor = 5.0;

    // Occlusion on skybox leads to artifacts
    if (isSkybox) {
        occlusionTotal = 0.0;

        // Push very far away
        posFromDepth *= 1e20;
        inscatterFactor = 1.0;
    }



    #ifdef USE_SCATTERING
    vec3 attenuation;
    float irradianceFactor;

    vec3 scatteringResult = scatteringComputeInscatteredLight(
        scatteringOptions,
        posFromDepth, 
        cameraPosition,
        viewDir, 
        inscatterSampler,
        attenuation, 
        irradianceFactor);

    #ifndef DEBUG_DISABLE_SCATTERING
        result += scatteringResult * inscatterFactor;
    #endif

    #endif







    // SRGB
    result.xyz = sqrt(result.xyz);


    #ifdef USE_GLOBAL_ILLUMINATION
        #ifndef DEBUG_DISABLE_GI
        int giCascadeSize = GI_cascadeSize;
        bool isInGrid = all(greaterThan(material.position, GI_gridStart)) && 
                        all(lessThan(material.position, GI_gridEnd));
        if (isInGrid) {

            vec3 voxelSize = (GI_gridEnd - GI_gridStart) / float(GI_cascadeSize);

            // We have to substract a very little value, because of compiler
            // optimizations. Otherwise the voxels are displaced and everythink breaks.
            // FUCK THE COMPILER! sorry.
            vec3 biasedPosition = material.position - 0.0000002 + material.normal * voxelSize * 1.0;


            vec3 localCoord = (biasedPosition-GI_gridStart) / (GI_gridEnd-GI_gridStart);
            ivec3 localCoordInt = ivec3(localCoord * GI_cascadeSize);

            ivec2 texcoordInt = ivec2(localCoordInt.xy) + ivec2(localCoordInt.z*GI_cascadeSize, 0);

            vec2 giCoord = localCoord.xy * vec2(1.0 / giCascadeSize, 1.0);
            giCoord.x += int(localCoord.z * giCascadeSize ) / float(giCascadeSize);

            // giCoord.xy = clamp(giCoord.xy, vec2(1.0 / (giCascadeSize*giCascadeSize) ), vec2(1 - 1.0/giCascadeSize));

            vec4 interp1 = texture(GI_gridColor, giCoord.xy, 0);
            vec4 interp2 = texture(GI_gridColor, giCoord.xy + vec2(1.0 / giCascadeSize, 0), 0);            

            float lerpFactor = mod(localCoord.z, 1.0/giCascadeSize) * float(giCascadeSize);
            vec4 interpTexelFetch = texelFetch(GI_gridColor, texcoordInt, 0 );
                
            // Linear filtered
            vec4 giColor = mix(interp1, interp2, lerpFactor );

            // Point filtered (for debugging)
            // vec4 giColor = interpTexelFetch + 0.1;

            // vec4 giColor = mix(interp1, interp2, 0.0);
            // giColor = interp2;
            // vec3 giResult = max(vec3(0.0), vec3( 1.0 - exp(-0.01 * giColor.xyz) )) + 0.2;
            // vec3 giResult = max(vec3(0.0), giColor.xyz * 32.0 ) + 0.2;
            vec3 giResult = vec3( max(vec3(0.0), pow( giColor.xyz+1.0, vec3(1.0/32.0)) * 2.5 )) + 0.0;
            // vec3 giResult = vec3(ivec3(biasedPosition.xyz * 512.0) % 2);
            giResult = max(vec3(0.0), giResult - 2.5) * 4.0 + 0.2;

            // vec3 giResult = vec3(1);
            // giResult = 1.05f - exp(-0.5 * giResult);
            // giResult /= 100000.0;
             

            #ifdef DEBUG_RM_GI
                result = (giResult - 1.0);
                occlusionTotal = 0.0;
            #else
                result *= giResult;
                occlusionTotal *= 1.0 - saturate(length(giResult) * 0.2);
            #endif

            result = saturate(result);
            result *= 1.9;

            // result = vec3( giColor.x, giColor.x, giColor.y ) + 0.0; 
            // result = vec3(mod(localCoord.z, 1.0/giCascadeSize) * float(giCascadeSize));
            // result = vec3(giCoord.x,0, 0);
            // result = vec3(gridCoordInt.z > 16? 1.0 : 0.0);
        } else {

            #ifdef DEBUG_RM_GI
                result = vec3(0);
                occlusionTotal = 0.0;
            #endif
            // result = vec3(1,0,0);
        }

        #endif

    #endif


    result = 1.0f - exp(-1.5 * result);

    float fogFactor = saturate( (distance(cameraPosition, material.position)-10.0) / 500.0);
    if (isSkybox) fogFactor = 0.0;
    result = mix(result, vec3(1.0,1.0,1.2), fogFactor);
    occlusionTotal = mix(occlusionTotal, 0.0, fogFactor * 2.0);



    // result = HDR(result, 1.0);


    #ifdef DEBUG_RM_BASECOLOR
        result = sqrt(material.baseColor);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_SPECULAR
        result = vec3(material.specular);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_OCCLUSION
        result = vec3(1);
        occlusionTotal = occlusionResult;
        // occlusionTotal = 0.0;
        // result = vec3(occlusionResult);
    #endif

    #ifdef DEBUG_RM_METALLIC
        result = vec3(material.metallic);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_ROUGHNESS
        result = vec3(material.roughness);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_NORMAL
        result = vec3((material.normal));
        // result = vec3((material.normal.x));
        occlusionTotal = 0.0;
    #endif


    #ifdef DEBUG_RM_SCATTERING
        #ifdef USE_SCATTERING
            result = scatteringResult * inscatterFactor;
            result = 1.0f - exp(-1.5 * result);
            occlusionTotal = 0.0;
        #endif
    #endif


    lightingResult = vec4(result, 1.0 - saturate(occlusionTotal) );
}