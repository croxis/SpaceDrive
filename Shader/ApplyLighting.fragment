#version 400


#extension GL_ARB_shader_image_load_store : enable


// TODO: Make some benchmarks to see wheter unrolling
// is faster or slower ..
#pragma optionNV (unroll all)



#pragma include "Includes/Configuration.include"
#pragma include "Includes/Light.include"
#pragma include "Includes/Material.include"
#pragma include "Includes/ShadowSource.include"
#pragma include "Includes/ColorCorrection.include"
#pragma include "Includes/PositionReconstruction.include"
#pragma include "Includes/SphericalHarmonics.include"

uniform sampler2D data0;
uniform sampler2D data1;
uniform sampler2D data2;
uniform sampler2D data3;

uniform sampler2D depth;

#ifdef USE_GLOBAL_ILLUMINATION
uniform sampler2D giDiffuseTex;
uniform sampler2D giReflectionTex;
#endif

#ifdef USE_OCCLUSION
uniform sampler2D occlusionTex;
#endif

uniform isamplerBuffer lightsPerTileBuffer;

uniform ivec2 precomputeSize;

uniform Light lights[MAX_VISIBLE_LIGHTS]; 
uniform ShadowSource shadowSources[SHADOW_MAX_TOTAL_MAPS]; 
in vec2 texcoord;

uniform int frameIndex;

uniform sampler2D noiseTexture;
uniform vec4 bufferSize;

uniform vec3 cameraPosition;

// Has to be after the uniforms
#pragma include "Includes/Lighting.include"



layout(location = 0) out vec4 lightingResult;

#ifdef USE_SSLR
layout(location = 1) out vec4 sslrDataResult;
#endif


uniform sampler2D lastFramePosition;

#ifdef USE_OCCLUSION
uniform sampler2D lastFrameOcclusion;
#endif

#ifdef USE_SCATTERING

#pragma include "Scattering/ScatteringOptions.include"
#pragma include "Scattering/Final.include"

uniform sampler3D inscatterSampler;
uniform ScatteringOptions scatteringOptions;
#endif

vec3 getPositionWorld(vec2 coord) {
    float z = texture(depth, coord).x;
    return calculateSurfacePos(z, coord);
}


void main() {


    // Compute texcoords
    ivec2 screenSize = textureSize(data0, 0);
    ivec2 screenCoord = ivec2(gl_FragCoord.xy);
    vec2 correctTexcoord = texcoord;
   

    ivec2 tileIndex = ivec2(vec2(screenCoord) / 
        vec2(LIGHTING_COMPUTE_PATCH_SIZE_X, LIGHTING_COMPUTE_PATCH_SIZE_Y));

    ivec2 precomputeCoord = tileIndex * 8;

    int tileBufferOffset = (tileIndex.x + tileIndex.y * precomputeSize.x) * LIGHTING_PER_TILE_STRIDE;


    // Extract material data
    vec4 target0data = texelFetch(data0, screenCoord, 0);
    vec4 target1data = texelFetch(data1, screenCoord, 0);
    vec4 target2data = texelFetch(data2, screenCoord, 0);
    vec4 target3data = texelFetch(data3, screenCoord, 0);
    Material material = unpackMaterial(target0data, target1data, target2data, target3data);

    #ifdef DEBUG_RM_LIGHTING
        material.baseColor = vec3(1);
    #endif
    #ifdef DEBUG_RM_PSSM_SPLITS
        material.baseColor = vec3(1);
    #endif


    #ifdef DEBUG_RM_DIFFUSE_LIGHTING
        material.baseColor = vec3(1);
        material.metallic = 0.0;
        material.specular = 0.0;
    #endif

      

    // Fetch the light counts
    // We perform a min as it *might* be that we read a wrong value
    // from the texture. Imagine reading 123123123 from the texture,
    // then the light processing loop would be 123123123 iterations long,
    // which simply crashes the driver. With this method it would be only
    // a few hundreds, which is long but does not crash the driver.
    int countPointLight = min(MAX_TILE_POINT_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 0).r);

    int countPointLightShadow = min(MAX_TILE_SHADOWED_POINT_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 1).r);

    int countDirectionalLight = min(MAX_TILE_DIRECTIONAL_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 2).r);

    int countDirectionalLightShadow = min(MAX_TILE_SHADOWED_DIRECTIONAL_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 3).r);

    int countSpotLight = min(MAX_TILE_SPOT_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 4).r);

    int countSpotLightShadow = min(MAX_TILE_SHADOWED_SPOT_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 5).r);


    // Lighting result gets stored in this variables
    vec3 result = vec3(0);
    vec4 giDiffuseColor = vec4(0.1);
    vec3 giSpecularColor = vec3(1);
    vec3 ambient = vec3(0);

    // Compute depth normal
    vec3 pixelW = vec3(bufferSize.xy, 0);
    vec3 world = getPositionWorld(texcoord);
    vec3 worldX1 = getPositionWorld(texcoord + pixelW.xz);
    vec3 worldY1 = getPositionWorld(texcoord + pixelW.zy);
    vec3 wsNormal = (cross(world - worldX1, world - worldY1));
    wsNormal = normalize(wsNormal);



    float pixelDepth = texelFetch(depth, screenCoord,0 ).x;
    float reflectionFactor = saturate( (0.5 - material.roughness) * 5.0 ) ;


    #ifdef USE_GLOBAL_ILLUMINATION

    #ifndef DEBUG_DISABLE_GI
    // Bilateral upsample global illumination

    ivec2 giSampleCoord = screenCoord / 2;
    
    ivec2 giSampleOffsets[5] = ivec2[](
        ivec2(0,0),
        ivec2(-1,0),
        ivec2(1,0),
        ivec2(0,-1),
        ivec2(0,1)
        // ivec2(-1, -1),
        // ivec2(-1, 1),
        // ivec2(1, -1),
        // ivec2(1, 1)
    );

    vec4 giDiffuseResult = vec4(0);
    vec4 giSpecularResult = vec4(0);
    float giValidSamples = 0.01;



    for (int i = 0; i < 5; i++) {
        ivec2 coord = giSampleCoord + giSampleOffsets[i];
        ivec2 coordScreen = coord * 2;
        vec3 normalScreen = normalize(texelFetch(data1, coordScreen, 0).xyz);
        float depthScreen = texelFetch(depth, coordScreen, 0).x;

        float reliability = 1.0 - saturate(distance(normalScreen, material.normal));
        reliability *= 1.0 - saturate( abs(pow(depthScreen,10.0) - pow(pixelDepth, 10.0)) * 200.0);

        giDiffuseResult += texelFetch(giDiffuseTex, coord, 0) * reliability;
        giSpecularResult += texelFetch(giReflectionTex, coord, 0) * reliability;
        giValidSamples += reliability;

    }

    // giDiffuseColor = vec4(diffuseColorSamples);
    giDiffuseColor = giDiffuseResult / giValidSamples;
    giSpecularColor = giSpecularResult.xyz / giValidSamples;

    if (giValidSamples < 0.5) {
        giDiffuseColor = texelFetch(giDiffuseTex, giSampleCoord, 0);
        giSpecularColor = texelFetch(giReflectionTex, giSampleCoord, 0).xyz;
    }

    // float giSampleDepth = texelFetch(depth, giSampleCoord, 0).x;
    

    // giDiffuseColor = texelFetch(giDiffuseTex, giSampleCoord, 0);

    #endif
    #endif


    // There should be a more elegant way, but for now it works. I don't want to
    // waste a gbuffer flag for marking the skybox.
    bool isSkybox = distance(material.position, cameraPosition) > SKYBOX_BEGIN;
    
    float occlusionTotal = 0.0;

    vec3 scatteringReflectedColor = vec3(0,0,0);
    vec3 viewVector = normalize(cameraPosition - material.position);

    // Scattering
    #ifdef USE_SCATTERING

    vec3 attenuation;
    float irradianceFactor;

    // Reconstruct position - otherwise we have precision errors
    vec3 viewDir = calculateSurfacePos(1.0, texcoord);

    vec3 posFromDepth = calculateSurfacePos(texelFetch(depth, screenCoord, 0).x, texcoord);


    vec3 sunVector = vec3(0,0,1);

    sunVector = normalize(lights[0].direction);

    #ifndef DEBUG_DISABLE_SCATTERING
    float inscatterFactor = 5.0;

    // Occlusion on skybox leads to artifacts
    if (isSkybox) {
        occlusionTotal = 0.0;

        // Push very far away
        posFromDepth *= 1e20;
        inscatterFactor = 1.5;

        reflectionFactor = 0.0;
    }

    vec3 scatteringResult = scatteringComputeInscatteredLight(
        scatteringOptions,
        posFromDepth, 
        cameraPosition,
        viewDir, 
        sunVector,
        inscatterSampler,
        attenuation, 
        irradianceFactor);

    vec3 reflectVector = reflect(viewVector, material.normal);
    vec3 startPos = vec3(0);
    vec3 endPos = reflectVector * 1e17;
    endPos = vec3(0,0,1e12);
    vec3 startToEnd = normalize(startPos - endPos);
    scatteringReflectedColor = scatteringComputeInscatteredLight(
        scatteringOptions,
        endPos, 
        startPos,
        startToEnd, 
        sunVector,
        inscatterSampler,
        attenuation, 
        irradianceFactor) * 1.0;

    // scatteringReflectedColor = mix(scatteringReflectedColor, vec3(1.0), material.roughness);

    // scatteringReflectedColor = 1.0 - exp(-4.0 * scatteringReflectedColor);
    // scatteringReflectedColor = scatteringReflectedColor;

    
        result += scatteringResult * inscatterFactor ;
    #endif

    #endif


    // We can skip lighting for the skybox
    if (isSkybox) {

        result += 3.0 * material.baseColor;


    } else {


        // upscale occlusion here

        #if USE_OCCLUSION


            vec2 velocity = target2data.xy / 255.0;
            vec2 lastFrameTexcoord = texcoord  + velocity;
            ivec2 lastFrameCoordInt = ivec2(lastFrameTexcoord * textureSize(lastFramePosition, 0).xy);

            vec3 lastPos = texelFetch(lastFramePosition, lastFrameCoordInt, 0).xyz;

            float reliability = 1.0 - saturate(distance(lastPos, material.position) * 10.0);
            // reliability = 1.0;

            occlusionTotal = texture(occlusionTex, texcoord).x;

            float lastOcclusion = texelFetch(lastFrameOcclusion, lastFrameCoordInt, 0).x;
            occlusionTotal = mix(occlusionTotal, lastOcclusion, 0.5 * saturate(reliability) );
            // occlusionTotal = mix(occlusionTotal, lastOcclusion, 0.5);

            // occlusionTotal = reliability;


        #endif

        #ifdef DEBUG_DISABLE_OCCLUSION
            occlusionTotal = 0.0;
        #endif

        // Metallic materials don't have much occlusion
        // occlusionResult = mix(occlusionResult, vec4(0.0), saturate(material.metallic-0.3) );


        int currentTileOffset = tileBufferOffset + 16;

        // Compute point lights
        int currentLightId = 0;
        Light currentLight;

        for (int i = 0; i < countPointLight; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];
            result += applyPointLight(currentLight, material);
        }

        currentTileOffset += MAX_TILE_POINT_LIGHTS;

        // Compute shadow point lights
        for (int i = 0; i < countPointLightShadow; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];

            #if USE_SHADOWS
                result += applyPointLightWithShadow(currentLight, material );
            #else
                result += applyPointLight(currentLight, material);
            #endif
        }

        currentTileOffset += MAX_TILE_SHADOWED_POINT_LIGHTS;

        // Compute directional lights
        for (int i = 0; i < countDirectionalLight; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];
            result += applyDirectionalLight(currentLight, material);
        }

        currentTileOffset += MAX_TILE_DIRECTIONAL_LIGHTS;

        // Compute shadowed directinal lights
        for (int i = 0; i < countDirectionalLightShadow; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];
            result += applyDirectionalLightWithShadow(currentLight, material);
        }


        currentTileOffset += MAX_TILE_SHADOWED_DIRECTIONAL_LIGHTS;

        // Compute spot lights
        for (int i = 0; i < countSpotLight; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];
            result += applySpotLight(currentLight, material);
        }

        currentTileOffset += MAX_TILE_SPOT_LIGHTS;

        // Compute shadow spot lights
        // baseOffset = precomputeCoord + ivec2(0,8);
        // for (int i = 0; i < countPointLightShadow; i++) {
        //     currentOffset = ivec2(i % 8, i / 8);
        //     currentLightId = texelFetch(lightsPerTile, baseOffset + currentOffset, 0).r;
        //     currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
        //     currentLight = lights[currentLightId];

        //     #if USE_SHADOWS
        //         result += applyPointLightWithShadow(currentLight, material );
        //     #else
        //         result += applyPointLight(currentLight, material);
        //     #endif
        // }
        currentTileOffset += MAX_TILE_SHADOWED_SPOT_LIGHTS;



        // Ambient / Reflections

        ambient = computeAmbient(material, giDiffuseColor, giSpecularColor, viewVector, wsNormal);    
        #ifndef DEBUG_RM_PSSM_SPLITS
            result += ambient;
        #endif
    }



    // SSLR Precomputation data

    vec3 reflectionVector = normalize(reflect(viewVector, material.normal));



    #ifdef USE_SSLR
        sslrDataResult = vec4(reflectionVector, reflectionFactor);
    #endif


    // result.xyz *= giDiffuseColor.xyz;


    // SRGB
    result.xyz = pow(result.xyz, vec3(1.0 / 2.2) ); 
    result = 1.0f - exp(-1.0 * result);


    // #define ENABLE_FOG

    #ifdef ENABLE_FOG
        float fogFactor = saturate( (distance(cameraPosition, material.position)-50.0) / 100.0);
        if (isSkybox) fogFactor = 0.0;
        result = mix(result, vec3(1.0,1.0,1.2), fogFactor);
        occlusionTotal = mix(occlusionTotal, 0.0, fogFactor * 2.0);
    #endif

    #ifdef DEBUG_RM_GI
        result = pow(giDiffuseColor.xyz, vec3(1.0 / 2.2));
        result = 1.0f - exp(-2.0* result);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_REFLECTIONS
        result = vec3(giSpecularColor);
        occlusionTotal = 0.0;        
    #endif

    #ifdef DEBUG_RM_BASECOLOR
        result = (material.baseColor);
    // result.xyz = pow(result.xyz, vec3(1.0 / 2.2) ); 
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_SPECULAR
        result = vec3(material.specular);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_OCCLUSION
        result = vec3(1.0);
        // occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_METALLIC
        result = vec3(material.metallic);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_ROUGHNESS
        result = vec3(material.roughness);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_NORMAL
        result = vec3((material.normal));
        // result = vec3((material.normal.x));
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_AMBIENT
        result = vec3(ambient);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_PSSM_SPLITS
        occlusionTotal = 0.0;
    #endif


    #ifdef DEBUG_RM_SCATTERING
        #ifdef USE_SCATTERING
            result = scatteringResult * inscatterFactor;
            result = 1.0f - exp(-1.5 * result);
            // result = texture(inscatterSampler, vec3(texcoord, 0 ) ).xyz;
            occlusionTotal = 0.0;
        #endif
    #endif

    #ifdef DEBUG_RM_SHADOWS
        occlusionTotal = 0.0;
        // result *= 0.5;
    #endif  


    // result = vec3(texelFetch(lightsPerTileBuffer, tileBufferOffset).x / 12.0);
        // result = vec3(countDirectionalLightShadow / 2.0 + 0.1);

    // result = vec3(tileIndex.y / 10.0);

    lightingResult = vec4(result, saturate(occlusionTotal) );
}
