#version 400


// Required, or it runs incredible slow
#pragma optionNV (unroll all)

#extension GL_ARB_shader_image_load_store : enable


#pragma include "Includes/Configuration.include"
#pragma include "Includes/Light.include"
#pragma include "Includes/Material.include"
#pragma include "Includes/ShadowSource.include"
#pragma include "Includes/PositionReconstruction.include"

uniform sampler2D data0;
uniform sampler2D data1;
uniform sampler2D data2;
uniform sampler2D data3;

uniform sampler2D depth;

#ifdef USE_GLOBAL_ILLUMINATION
uniform sampler2D giDiffuseTex;
uniform sampler2D giReflectionTex;
#endif

#ifdef USE_OCCLUSION
uniform sampler2D occlusionTex;
#endif

uniform isamplerBuffer lightsPerTileBuffer;
uniform ivec2 lightingTileCount;

uniform Light lights[MAX_VISIBLE_LIGHTS]; 
uniform ShadowSource shadowSources[SHADOW_MAX_TOTAL_MAPS]; 

uniform int frameIndex;

uniform sampler2D noiseTexture;
uniform vec4 bufferSize;

uniform vec3 cameraPosition;

in vec2 texcoord;


// Has to be after the uniforms
#pragma include "Includes/Lighting.include"



layout(location = 0) out vec4 lightingResult;

#ifdef USE_SSLR
layout(location = 1) out vec4 sslrDataResult;
#endif


uniform sampler2D lastFramePosition;

#ifdef USE_OCCLUSION
uniform sampler2D lastFrameOcclusion;
#endif

#ifdef USE_SCATTERING

#pragma include "Scattering/ScatteringOptions.include"
#pragma include "Scattering/Final.include"

uniform sampler3D inscatterSampler;
uniform ScatteringOptions scatteringOptions;
#endif


#ifdef USE_ADAPTIVE_BRIGHTNESS
uniform sampler2D dynamicExposureTex;
#endif


vec3 getPositionWorld(vec2 coord) {
    float z = texture(depth, coord).x;
    return calculateSurfacePos(z, coord);
}


void main() {


    // Compute texcoords
    ivec2 screenSize = textureSize(data0, 0);
    ivec2 screenCoord = ivec2(gl_FragCoord.xy);
    vec2 correctTexcoord = texcoord;
   

    int shadowsComputed = 0;

    ivec2 tileIndex = ivec2(vec2(screenCoord) / 
        vec2(LIGHTING_COMPUTE_PATCH_SIZE_X, LIGHTING_COMPUTE_PATCH_SIZE_Y));

    ivec2 precomputeCoord = tileIndex * 8;

    int tileBufferOffset = (tileIndex.x + tileIndex.y * lightingTileCount.x) * LIGHTING_PER_TILE_STRIDE;


    // Extract material data
    vec4 target0data = texelFetch(data0, screenCoord, 0);
    vec4 target1data = texelFetch(data1, screenCoord, 0);
    vec4 target2data = texelFetch(data2, screenCoord, 0);
    vec4 target3data = texelFetch(data3, screenCoord, 0);
    Material material = unpackMaterial(target0data, target1data, target2data, target3data);

    // Low roughness values look shitty
    material.roughness = max(0.02, material.roughness);

    #ifdef DEBUG_RM_LIGHTING
        material.baseColor = vec3(1);
    #endif
    #ifdef DEBUG_RM_PSSM_SPLITS
        material.baseColor = vec3(1);
    #endif


    #ifdef DEBUG_RM_DIFFUSE_LIGHTING
        material.baseColor = vec3(1);
        material.metallic = 0.0;
        material.specular = 0.0;
    #endif      

    // Fetch the light counts
    // We perform a min as it *might* be that we read a wrong value
    // from the texture. Imagine reading 123123123 from the texture,
    // then the light processing loop would be 123123123 iterations long,
    // which simply crashes the driver. With this method it would be only
    // a few hundreds, which is long but does not crash the driver.
    int countPointLight = min(MAX_TILE_POINT_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 0).r);

    int countPointLightShadow = min(MAX_TILE_SHADOWED_POINT_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 1).r);

    int countDirectionalLight = min(MAX_TILE_DIRECTIONAL_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 2).r);

    int countDirectionalLightShadow = min(MAX_TILE_SHADOWED_DIRECTIONAL_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 3).r);

    int countSpotLight = min(MAX_TILE_SPOT_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 4).r);

    int countSpotLightShadow = min(MAX_TILE_SHADOWED_SPOT_LIGHTS, 
        texelFetch(lightsPerTileBuffer, tileBufferOffset + 5).r);


    // Lighting result gets stored in this variables
    vec3 result = vec3(0);
    vec4 giDiffuseColor = vec4(0.5);
    vec4 giSpecularColor = vec4(0);
    vec3 ambient = vec3(0);

    // Compute depth normal
    vec3 pixelW = vec3(bufferSize.xy, 0);
    vec3 world = getPositionWorld(texcoord);
    vec3 worldX1 = getPositionWorld(texcoord + pixelW.xz);
    vec3 worldY1 = getPositionWorld(texcoord + pixelW.zy);
    vec3 wsNormal = (cross(world - worldX1, world - worldY1));
    wsNormal = normalize(wsNormal);

    float pixelDepth = texelFetch(depth, screenCoord,0 ).x;
    float reflectionFactor = saturate( (0.5 - material.roughness) * 5.0 ) ;


    #ifdef USE_GLOBAL_ILLUMINATION

    #ifndef DEBUG_DISABLE_GI


    // Bilateral upsample global illumination

    ivec2 giSampleCoord = screenCoord / 2;
    
    const int giSampleCount = 5;

    vec2 giSampleOffsets[giSampleCount] = vec2[](
        vec2(0,0),
        vec2(-1,0),
        vec2(1,0),
        vec2(0,-1),
        vec2(0,1)

        // vec2(1, 1),
        // vec2(-1, 1),
        // vec2(-1, -1),
        // vec2(1, -1)
    );

    vec4 giDiffuseResult = vec4(0);
    vec4 giSpecularResult = vec4(0);
    float giValidSamples = 0.01;

    float pixelLZ = getLinearZFromZ(pixelDepth);

    for (int i = 0; i < giSampleCount; i++) {

        vec2 coord = texcoord + giSampleOffsets[i] / vec2(screenSize) * 0.5;
        vec3 normalScreen = normalize(textureLod(data1, coord, 0).xyz);
        float depthScreen = textureLod(depth, coord, 0).x;
        float reliability = saturate((dot(normalScreen, material.normal)-0.9));

        float lz1 = getLinearZFromZ(depthScreen);

        reliability *= 1.0 - saturate(abs(lz1 - pixelLZ) * 50.0);

        giDiffuseResult += texture(giDiffuseTex, coord) * reliability;
        giSpecularResult += texture(giReflectionTex, coord) * reliability;
        giValidSamples += reliability;

    }
    giDiffuseColor = giDiffuseResult / giValidSamples;
    giSpecularColor = giSpecularResult / giValidSamples;


    // giSpecularColor = vec4(giValidSamples / giSampleCount);

    #endif
    #endif


    // There should be a more elegant way, but for now it works. I don't want to
    // waste a gbuffer flag for marking the skybox.
    bool isSkybox = distance(material.position, cameraPosition) > SKYBOX_BEGIN;
    
    float occlusionTotal = 0.0;

    vec3 scatteringReflectedColor = vec3(0,0,0);
    vec3 viewVector = normalize(cameraPosition - material.position);

    // Scattering
    #ifdef USE_SCATTERING

    vec3 attenuation;
    float irradianceFactor;

    // Reconstruct position - otherwise we have precision errors
    vec3 viewDir = calculateSurfacePos(1.0, texcoord);

    vec3 posFromDepth = calculateSurfacePos(texelFetch(depth, screenCoord, 0).x, texcoord);


    vec3 sunVector = vec3(0,0,1);

    // FIXME: Should be set by user
    
    sunVector = normalize(lights[0].direction);

    #ifndef DEBUG_DISABLE_SCATTERING
    float inscatterFactor = 5.0;

    // Occlusion on skybox leads to artifacts
    if (isSkybox) {
        occlusionTotal = 0.0;

        // Push very far away
        posFromDepth *= 1e20;
        inscatterFactor = 1.5;

        reflectionFactor = 0.0;

    }

    vec3 scatteringResult = scatteringComputeInscatteredLight(
        scatteringOptions,
        posFromDepth, 
        cameraPosition,
        viewDir, 
        sunVector,
        inscatterSampler,
        attenuation, 
        irradianceFactor);

    vec3 reflectVector = reflect(viewVector, material.normal);
    vec3 startPos = vec3(0);
    vec3 endPos = reflectVector * 1e17;
    endPos = vec3(0,0,1e12);
    vec3 startToEnd = normalize(startPos - endPos);
    scatteringReflectedColor = scatteringComputeInscatteredLight(
        scatteringOptions,
        endPos, 
        startPos,
        startToEnd, 
        sunVector,
        inscatterSampler,
        attenuation, 
        irradianceFactor) * 1.5;

    #ifdef USE_GLOBAL_ILLUMINATION
    // Complete gi specular

    // giSpecularColor.xyz += scatteringReflectedColor.xyz * (1.0 - giSpecularColor.w) * 0.1;
    // giSpecularColor.xyz += 1.0 - giSpecularColor.w;
    // giSpecularColor.xyz *= 0.4;

    #endif

    // scatteringReflectedColor = mix(scatteringReflectedColor, vec3(1.0), material.roughness);

    // scatteringReflectedColor = 1.0 - exp(-4.0 * scatteringReflectedColor);
    // scatteringReflectedColor = scatteringReflectedColor;

    
        result += scatteringResult * inscatterFactor ;
    #endif

    #endif


    // We can skip lighting for the skybox
    if (isSkybox) {

        result += 3.0 * material.baseColor;


    } else {


        // upscale occlusion here
        #if USE_OCCLUSION

            // Temporal occlusion
            vec2 velocity = target2data.xy / 255.0;
            vec2 lastFrameTexcoord = texcoord  + velocity;
            ivec2 lastFrameCoordInt = ivec2(lastFrameTexcoord * textureSize(lastFramePosition, 0).xy);

            vec3 lastPos = texelFetch(lastFramePosition, lastFrameCoordInt, 0).xyz;
            float reliability = 1.0 - saturate(distance(lastPos, material.position) * 10.0);
            occlusionTotal = texture(occlusionTex, texcoord).x;

            float lastOcclusion = texelFetch(lastFrameOcclusion, lastFrameCoordInt, 0).x;
            occlusionTotal = mix(occlusionTotal, lastOcclusion, 0.5 * saturate(reliability) );

        #endif

        #ifdef DEBUG_DISABLE_OCCLUSION
            occlusionTotal = 0.0;
        #endif

        // Metallic materials don't have much occlusion
        // occlusionResult = mix(occlusionResult, vec4(0.0), saturate(material.metallic-0.3) );


        #ifndef DEBUG_DISABLE_LIGHTS

        int currentTileOffset = tileBufferOffset + 16;

        // Compute point lights
        int currentLightId = 0;
        Light currentLight;

        for (int i = 0; i < countPointLight; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];
            result += applyPointLight(currentLight, material);
        }

        currentTileOffset += MAX_TILE_POINT_LIGHTS;

        // Compute shadow point lights
        for (int i = 0; i < countPointLightShadow; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];

            #if USE_SHADOWS
                result += applyPointLightWithShadow(currentLight, material );
                shadowsComputed ++;
            #else
                result += applyPointLight(currentLight, material);
            #endif
        }

        currentTileOffset += MAX_TILE_SHADOWED_POINT_LIGHTS;

        // Compute directional lights
        for (int i = 0; i < countDirectionalLight; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];
            result += applyDirectionalLight(currentLight, material);
        }

        currentTileOffset += MAX_TILE_DIRECTIONAL_LIGHTS;

        // Compute shadowed directinal lights
        for (int i = 0; i < countDirectionalLightShadow; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];
            result += applyDirectionalLightWithShadow(currentLight, material);
            shadowsComputed ++;
        }


        currentTileOffset += MAX_TILE_SHADOWED_DIRECTIONAL_LIGHTS;

        // Compute spot lights
        for (int i = 0; i < countSpotLight; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];
            result += applySpotLight(currentLight, material);
        }

        currentTileOffset += MAX_TILE_SPOT_LIGHTS;

        // Compute shadow spot lights
        for (int i = 0; i < countSpotLightShadow; i++) {
            currentLightId = texelFetch(lightsPerTileBuffer, currentTileOffset + i).r;
            currentLight = lights[currentLightId];

            #if USE_SHADOWS
                result += applySpotLightWithShadow(currentLight, material);
                shadowsComputed ++;
            #else
                result += applySpotLight(currentLight, material);
            #endif
        }
        currentTileOffset += MAX_TILE_SHADOWED_SPOT_LIGHTS;



        #endif

        // Ambient / Reflections

        ambient = computeAmbient(material, giDiffuseColor, giSpecularColor, viewVector, wsNormal);    
        // ambient = vec3(0.2);

        #ifndef DEBUG_RM_PSSM_SPLITS
            result += ambient;
        #endif
    }



    #ifdef USE_SSLR
        // SSLR Precomputation data
        vec3 reflectionVector = normalize(reflect(viewVector, material.normal));
        sslrDataResult = vec4(reflectionVector, reflectionFactor);
    #endif

    // SRGB
    result.xyz = pow(result.xyz, vec3(1.0 / 2.2) ); 

    float exposure = 1.0;

    #ifdef USE_ADAPTIVE_BRIGHTNESS
        // Adaptive Brightness
        exposure = texelFetch(dynamicExposureTex, ivec2(0), 0).x;
    #endif

    result = 1.0f - exp(-exposure * result);

    // #define ENABLE_FOG

    #ifdef ENABLE_FOG
        float fogFactor = saturate( (distance(cameraPosition, material.position)-50.0) / 100.0);
        if (isSkybox) fogFactor = 0.0;
        result = mix(result, vec3(1.0,1.0,1.2), fogFactor);
        occlusionTotal = mix(occlusionTotal, 0.0, fogFactor * 2.0);
    #endif

    #ifdef DEBUG_RM_GI
        result = pow(giDiffuseColor.xyz, vec3(1.0 / 2.2));
        result = 1.0f - exp(-2.0* result);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_REFLECTIONS
        result = vec3(giSpecularColor);
        occlusionTotal = 0.0;        
    #endif

    #ifdef DEBUG_RM_BASECOLOR
        result = (material.baseColor);
    // result.xyz = pow(result.xyz, vec3(1.0 / 2.2) ); 
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_SPECULAR
        result = vec3(material.specular);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_OCCLUSION
        result = vec3(1.0);
        // occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_METALLIC
        result = vec3(material.metallic);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_ROUGHNESS
        result = vec3(material.roughness);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_NORMAL
        result = vec3((material.normal));
        // result = vec3((material.normal.x));
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_AMBIENT
        result = vec3(ambient);
        occlusionTotal = 0.0;
    #endif

    #ifdef DEBUG_RM_PSSM_SPLITS
        occlusionTotal = 0.0;
    #endif


    #ifdef DEBUG_RM_SCATTERING
        #ifdef USE_SCATTERING
            result = scatteringResult * inscatterFactor;
            result = 1.0f - exp(-1.5 * result);
            occlusionTotal = 0.0;
        #endif
    #endif

    #ifdef DEBUG_RM_SHADOWS
        occlusionTotal = 0.0;
    #endif  


    #ifdef DEBUG_RM_SHADOW_COMPUTATIONS
        float loadFactor = float(shadowsComputed) / 10.0;
        result = vec3(loadFactor, 1.0 - loadFactor, 0.0);
    #endif

    #ifdef DEBUG_RM_LIGHT_COMPUTATIONS
        int lightsComputed = countPointLight + countPointLightShadow + countDirectionalLight + countDirectionalLightShadow + countSpotLight + countSpotLightShadow;
        float loadFactor = float(lightsComputed) / 40.0;
        result = vec3(loadFactor, 1.0 - loadFactor, 0.0);
    #endif


    lightingResult = vec4(result, 0.0 );
}
