

#include "Includes/Configuration.include"
#include "Includes/Packing.include"


// const float normalsDiscardThreshold = 0.99999;
const float normalsDiscardThreshold = 0.9;


#pragma optionNV (unroll all)

uniform sampler2D normalsView;


vec4 mipmapBasedBlur(vec2 texcoord, vec2 direction, sampler2D colorTex, sampler2D blurFactors) {

    // return texture(colorTex, texcoord);

    float blurFactor = texture(blurFactors, texcoord).r;

    if (blurFactor < 0.01) {
        return texture(colorTex, texcoord);
    } else {

        float blurWeights[9] = float[9]
        (
            0.013519569015984728,
            0.047662179108871855,
            0.11723004402070096,
            0.20116755999375591,
            0.240841295721373,
            0.20116755999375591,
            0.11723004402070096,
            0.047662179108871855,
            0.013519569015984728
        );

        float offsets[9] = float[9] (-4,-3,-2,-1,0,+1,+2,+3,+4);

        float mipmap = blurFactor * 2.2;
        mipmap = 0.0;
        vec2 texelSize = 7.2 / vec2(textureSize(colorTex, 0));
        texelSize *= direction * blurFactor;
        vec4 result = vec4(0);
        float weights;
        for (int i = 0; i < 9; i++) {
            vec2 offsetCoord = texcoord + offsets[i]*texelSize;
            float dofFactorOffset = textureLod(blurFactors, offsetCoord, 0).r;
            float weight = max(0.0, dofFactorOffset - blurFactor) *  blurWeights[i];
            weight = 1.0;

            result += textureLod(colorTex, offsetCoord , mipmap) *weight;
            weights += weight;
        }
        return result / weights;
    }
}


float edgePreservingAlphaBlur(vec2 texcoord, ivec2 screenCoord, sampler2D colorTex, sampler2D normalTex) {

    #ifndef USE_OCCLUSION_BLUR
        return texture(colorTex, texcoord).a;
    #endif

    #ifdef DSSDO_ENABLED

        float blurWeights[9] = float[9]
        (
            0.013519569015984728,
            0.047662179108871855,
            0.11723004402070096,
            0.20116755999375591,
            0.240841295721373,
            0.20116755999375591,
            0.11723004402070096,
            0.047662179108871855,
            0.013519569015984728
        );

        vec3 normals[9];
        float occlusion[9];

        // AMD Can't handle texelFetchOffset with loops

        // #define EPAB_INIT_VALUES(i) \
        // normals[i] = decodeNormal(texelFetchOffset(normalTex, screenCoord, 0, ivec2(i-4)*blurDirection).xy); \
        // occlusion[i] = texelFetchOffset(colorTex, screenCoord, 0, ivec2(i-4)*blurDirection).a;

        // EPAB_INIT_VALUES(0)
        // EPAB_INIT_VALUES(1)
        // EPAB_INIT_VALUES(2)
        // EPAB_INIT_VALUES(3)
        // EPAB_INIT_VALUES(4)
        // EPAB_INIT_VALUES(5)
        // EPAB_INIT_VALUES(6)
        // EPAB_INIT_VALUES(7)
        // EPAB_INIT_VALUES(8)

        vec2 offset = texcoord;
        vec2 texelSize = 2.0 / vec2(textureSize(colorTex, 0));
        vec2 perStep = texelSize * vec2(blurDirection);
        offset -= perStep * 4.0;

        for (int i = 0; i < 9; i++) {
            offset += perStep;
            normals[i] = decodeNormal(texture(normalTex, offset).xy);
            occlusion[i] = texture(colorTex, offset).a;
        }

        // pixel normal is the mid normalr
        vec3 normal = normals[4];

        float alphaResult = 0.0;
        float alphaWeights = 0.0;



        // Check for edges, as we are performing an edge preserving blur
        for (int i = 0; i < 9; i++) {
            float weight = blurWeights[i];
            float normalInfluenceFactor = step(normalsDiscardThreshold, dot(normals[i], normal));
            alphaResult += occlusion[i]*weight*normalInfluenceFactor;
            alphaWeights += weight*normalInfluenceFactor;   
        }

        return alphaResult / alphaWeights;


    #else
        return texelFetch(colorTex, screenCoord, 0).a;
    #endif
}