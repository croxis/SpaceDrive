#pragma once


#pragma include "Includes/Configuration.include"
#pragma include "Includes/Material.include"
#pragma include "Includes/GIData.include"
#pragma include "Includes/PoissonDisk.include"



uniform float opt_ao_cone_height;
// uniform float opt_ao_step_ratio;
// uniform float opt_ao_cone_ratio;
// uniform float opt_ao_start_distance;
// uniform float opt_ao_initial_radius;


vec4 traceCone(GIData data, sampler3D targetTex, vec3 start, vec3 direction,
    int iterations, float stepRatio, float coneRatio, float startDistance, float initialConeRadius) {

    vec3 directionStep = normalize(direction) / (2.0 * data.gridHalfSize);
    vec4 result = vec4(0);

    float currentDistance = startDistance;
    float currentConeRadius = initialConeRadius;

    // TODO: Optimize
    for (int i = 0; i < iterations; i++) {
        currentConeRadius *= stepRatio; 
        currentDistance += currentConeRadius * coneRatio;
        vec3 currentPos = start + directionStep * currentDistance;
        float currentMip = log2( currentConeRadius + 1.0 ) * 1.5;
        // currentMip = 2.0;
        vec4 currentVal = textureLod(targetTex, currentPos, currentMip );
        result += currentVal * (1.0-result.w);
    }
    return result;
}

vec4 traceConeWithCollisions(GIData data, vec3 start, vec3 direction, 
int iterations, float stepRatio, float coneRatio, float startDistance, float initialConeRadius) {

    vec3 directionStep = normalize(direction) / (2.0 * data.gridHalfSize);
    vec4 result = vec4(0);

    float currentDistance = startDistance;
    float currentConeRadius = initialConeRadius;

    // TODO: Optimize
    for (int i = 0; i < iterations; i++) {
        currentConeRadius *= stepRatio; 
        currentDistance += currentConeRadius * coneRatio;
        vec3 currentPos = start + directionStep * currentDistance;
        // float currentMip = clamp(log2( currentConeRadius ) * 1.5, 0.0, 5.0);
        float currentMip = log2(currentConeRadius);
        vec4 currentVal = textureLod(data.voxels, currentPos, currentMip );
        result += (1.0-result.w) * currentVal;
    }
    return result;
}

vec4 computeGlobalIllumination(Material m, vec3 viewVector, GIData data, out vec4 specularColor, vec3 flatNormal, vec3 cameraPosition) {

    // The color which is returned when a pixel is not in the gi range.
    // Also used to fade out gi at the grid borders.
    float boundsColor = 1.0;

    // Fetch the normal used to compute the cone directions
    // vec3 correctNormal = normalize(cross(dFdx(m.position), dFdy(m.position)));
    vec3 correctNormal = m.normal;

    // Compute grid variables
    vec3 gridStart = data.gridPos - data.gridHalfSize;
    vec3 gridEnd = data.gridPos + data.gridHalfSize;
    vec3 voxelSize = (gridEnd - gridStart) / vec3(data.gridResolution);


    // Check if the pixel is in the grid
    bool isInGrid = all(greaterThan(m.position, gridStart)) && 
                    all(lessThan(m.position, gridEnd));

    specularColor = vec4(0);

    // If not in gi range, ignore this pixel
    // TODO: Check if early out is actually faster
    if (!isInGrid) return vec4(boundsColor);


    // Bias position a bit, so self shadowing gets less strong
    vec3 biasedPosition = m.position + m.normal * voxelSize * 0.0;

    // Compute coordinate in voxel space
    vec3 localCoord = (biasedPosition-gridStart) / (2 * data.gridHalfSize);
    vec3 localCoordOffs = mod(localCoord, 1.0 / data.gridResolution);

    // Bias position again
    localCoord += 0.0 / data.gridResolution * m.normal;

    // Compute fadeout
    vec3 diffVector = (cameraPosition - m.position) / (data.gridHalfSize);
    float mixFactor = saturate(pow( length(diffVector) * 1.1, 12.0));
    localCoordOffs *= data.gridResolution;


    // if (localCoordOffs.x > 0.95 || localCoordOffs.y > 0.95 || localCoordOffs.z > 0.95) return mix(vec4(1,0,0,0), vec4(1), mixFactor);

    // Compute reflection vector, for specular reflections
    vec3 reflectVector = reflect(viewVector, m.normal);

    #ifndef DEBUG_RM_REFLECTIONS

    // Hopefully some GPUs can branch this effectively out. If so, they save
    // a lot of work!
    if (m.specular > 0.001) { 
    #endif

        // m.roughness = 0.0;

        // localCoord += 4.0 / data.gridResolution * reflectVector;
        localCoord += 3.0 / data.gridResolution * m.normal;

        // Trace specular reflections, using a cone size based on the roughness
        vec4 traced = traceCone(data, data.geometry, localCoord, reflectVector, 12, 1.01 + m.roughness*0.1, 1.0, 0.2, 0.01);
        // traced.xyz += scatteringReflected * (1.0 - traced.w) * 0.5;

        // mixFactor = 0.0;
        specularColor = mix(traced, vec4(0), mixFactor);


    #ifndef DEBUG_RM_REFLECTIONS
    }
    #endif

    // Reconstruct tangent & binormal
    vec3 t; 
    vec3 b; 
    vec3 c1 = cross(correctNormal, vec3(0.0, 0.0, 1.0)); 
    vec3 c2 = cross(correctNormal, vec3(0.0, 1.0, 0.0)); 
    if (length(c1) > length(c2))
      t = c1;   
    else
      t = c2;   
    t = normalize(t);
    b = normalize(cross(t, correctNormal));


    // Trace Occlusion
    const int numSamplesAO = 32;


    float randomVariableWhichIsNeverReferenced = opt_ao_cone_height * 0.00000001 + 0.875;

    vec4 aoResult = vec4(0);
    vec3 startCoord = localCoord + correctNormal * voxelSize * 0.0;
    for (int i = 0; i < numSamplesAO; i++) {
        vec3 traceDirection = poisson3D_32[i];
        traceDirection.z = abs(traceDirection.z) * 4.0;

        vec3 mixedNormal = normalize(
            t * traceDirection.x + 
            b * traceDirection.y + 
            correctNormal * traceDirection.z
        );
        // aoResult += traceCone(data, data.geometry, startCoord, mixedNormal , 16, opt_ao_step_ratio, opt_ao_cone_ratio , opt_ao_start_distance, opt_ao_initial_radius * 0.1);
        aoResult += traceCone(data, data.geometry, startCoord, mixedNormal , 8, 1.1227, 0.5682 , 0.727, 3.0228 * 0.1);
    }
    aoResult = aoResult / float(numSamplesAO);


    // raytrace to debug  voxels

    #if 0
    int numRaySteps = 500;
    vec3 rayStart = cameraPosition;
    vec3 rayEnd = cameraPosition + normalize(m.position - cameraPosition) * 80.0; 

    // transform to grid space
    rayStart = (rayStart-gridStart) / (2 * data.gridHalfSize);
    rayEnd = (rayEnd-gridStart) / (2 * data.gridHalfSize);

    vec3 rayPos = rayStart;
    vec3 rayStep = (rayEnd - rayStart) / float(numRaySteps);

    vec4 traceResult = vec4(0);

    vec3 traceResultPos = vec3(0);

    bool traceFound = false;
    for (int i = 0; i < numRaySteps; i++) {

        // vec4 texelVal = textureLod(data.geometry, rayPos, 0);
        vec4 texelVal = texelFetch(data.geometry, ivec3(rayPos * vec3(data.gridResolution) + 0.0) , 0);

        if (texelVal.w > 0.1 && !traceFound) {
            // traceResult += texelVal * (1.0 - traceResult.w);
            traceResultPos = rayPos;
            traceFound = true;
        }

        rayPos += rayStep;
    }


    traceResult = texelFetch(data.geometry, ivec3(traceResultPos * vec3(data.gridResolution) + 0.0) , 0);


    return vec4(traceResult.xyz, 1);

    #endif


    // Trace gi

    #if 0
    const int numSamplesGI = 1;
    float giConeHeight = 1.1;
    vec4 giResult = vec4(0);
    startCoord = localCoord + correctNormal * voxelSize * 0.0;
    for (int i = 0; i < numSamplesGI; i++) {
        vec3 traceDirection = poisson3D_32[i];
        traceDirection.z = abs(traceDirection.z) * 5.0;
        // traceDirection.z = abs(traceDirection.z) * 1.2;


        vec3 mixedNormal = normalize(
            t * traceDirection.x + b * traceDirection.y + correctNormal * traceDirection.z
        );
        // mixedNormal = mix(mixedNormal, traceDirection, 0.7);
        // mixedNormal = traceDirection;
        // giResult += traceConeWithCollisions(data, startCoord, mixedNormal , 12, 1.2523,0.7477, -0.0909, 1.0228);
        giResult += traceConeWithCollisions(data, startCoord, mixedNormal , 24, opt_ao_step_ratio, opt_ao_cone_ratio , opt_ao_start_distance, opt_ao_initial_radius);
        // giResult += traceConeWithCollisions(data, startCoord, mixedNormal , 24, opt_ao_step_ratio, opt_ao_cone_ratio , opt_ao_start_distance, opt_ao_initial_radius);

    }
    giResult = giResult / float(numSamplesGI);
    giResult = (pow(giResult, vec4(1.2)) * 1.0);

    #endif


    // giResult *= 1.0;

    // Single Cone GI (faster but lower quality)
    // startCoord = localCoord + correctNormal * data.voxelSize * 0.0;
    // vec4 giResult = traceConeWithCollisions(data, startCoord, correctNormal , 12, 1.8, 1.3, 4.0, 4.6) * 4.0;


    // giResult = vec4(textureLod(data.voxels, localCoord, 1.0).xyz,0) * 20.5;
    // giResult = vec4(textureLod(data.voxels, localCoord, 0.0).xyz)) * 1.5;


    float aoMultiplier = saturate(1.0 - aoResult.w);

    // float aoMultiplier = exp(-2.5 * length(aoResult.xyz)) * 1.0;
    // aoMultiplier = 1.0;

    // return vec4(giResult * 1.0);
    // return vec4(1.02 - exp(-10.5 *giResult));
    return vec4(mix(aoMultiplier, 1.0, mixFactor));  
    // return vec4(giResult);  
    // return mix(max(vec4(0.0), giResult) * aoMultiplier + 0.01, vec4(boundsColor), mixFactor);


}
