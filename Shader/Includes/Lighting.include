
#include "Includes/Configuration.include"
#include "Includes/Light.include"
#include "Includes/Random.include"
#include "Includes/LightingModels.include"
#include "Includes/Material.include"
#include "Includes/ParabolicTransform.include"
#include "Includes/ShadowSource.include"
#include "Includes/PositionReconstruction.include"
#include "Includes/PoissonDisk.include"
#include "Includes/SphericalHarmonics.include"


uniform samplerCube directionToFace;
uniform samplerCube fallbackCubemap;

const mat4 shadowBiasMatrix = mat4(
    0.5, 0.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 0.0,
    0.0, 0.0, 0.5, 0.0,
    0.5, 0.5, 0.5, 1.0
);


#if USE_HARDWARE_PCF
    uniform sampler2DShadow shadowAtlas;
#else
    uniform sampler2D shadowAtlas;
#endif

vec2 convertAtlasCoord(vec2 rawCoord, ShadowSource source) {
    // Todo: Raw coord can be simply clamped to 0 .. 1 instead of clamping the result
    float factor = float(source.resolution) / SHADOW_MAP_ATLAS_SIZE;
    float factorBy1 = 1.0 / SHADOW_MAP_ATLAS_SIZE;
    return ( clamp(rawCoord * factor, factorBy1, 1.0 - factorBy1) + source.atlasPos);
}


vec3 computeSpecular(vec3 specularColor, float roughness, float NxL, float LxH, float NxV, float NxH) {

    float specularD = DistributionBRDF(roughness, NxH) / M_PI;
    float specularG = GeometricBRDF(roughness, NxV, NxL);
    vec3  specularF = FresnelBRDF(specularColor, LxH);
    
    return genericMicrofacetBRDF(specularF, specularG, specularD, NxL, NxV);
}

vec3 computeLightModel(Light light, Material material, 
        vec3 l, vec3 v, vec3 n, vec3 h, 
        float attenuation, float shadowFactor) {

    #if USE_SIMPLE_LIGHTING
        return light.color * attenuation;
    #else

        // Performance optimization
        if (shadowFactor < 0.001) return vec3(0.0);

        vec3 lightingResult = vec3(0);

        vec3 specularColor = mix(vec3(1), material.baseColor, material.metallic) * material.specular;
        vec3 diffuseColor = mix(material.baseColor, vec3(0), material.metallic);

        float roughness = clamp(material.roughness, 0.005, 1.0);

        // pre-computed cross products
        float NxL = saturate(dot(n, l));
        float LxH = saturate(dot(l, h));
        float NxV = saturate(dot(n, v));
        float NxH = saturate(dot(n, h));

        // Evaluate specular
        vec3 specularContribution = computeSpecular(specularColor, roughness, NxL, LxH, NxV, NxH) * light.color * NxL * specularColor;

        // Energy conservation
        specularContribution *= pow(1.0 + roughness * 0.5, 2.0);
        lightingResult += vec3(specularContribution);

        // Evaluate diffuse
        vec3 diffuseContribution = diffuseColor / M_PI * NxL * light.color;
        lightingResult += vec3(diffuseContribution);

        // Apply shadows
        lightingResult *= shadowFactor;

        return lightingResult;

    #endif
}

vec3 computeEnvironmentBRDF(vec3 specularColor, float roughness, float NxV)
{
    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
    vec4 r = roughness * c0 + c1;
    float a004 = min( r.x * r.x, exp2( -9.28 * NxV ) ) * r.x + r.y;
    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
    AB.y *= saturate( 50.0 * specularColor.g );
    return specularColor * AB.x + AB.y;
}

vec3 computeAmbient(Material material, vec4 giAmbient, vec3 giSpecular, vec3 v, vec3 n) {

    #ifdef DEBUG_DISABLE_AMBIENT
        return vec3(0.0);
    #endif

    vec3 reflectedDir = reflect( v, material.normal );
    float mipmap = log2(material.roughness * 800.0);
    vec3 reflection1 = textureLod(fallbackCubemap, reflectedDir.xzy, mipmap).rgb;
    vec3 reflection2 = textureLod(fallbackCubemap, reflectedDir.xzy, mipmap - 1.0).rgb;
    vec3 reflectedColor = reflection1*0.5 + reflection2*0.5;
    reflectedColor *= reflectedColor;

    // No additional reflections for complex scenes
    // reflectedColor = vec3(0.03);


    float NxV = max(0.0, dot(material.normal, v));
    vec3 result = vec3(0);

    result += giAmbient.xyz * 0.2 * material.baseColor * (1.0 - material.metallic);

    vec3 specularColor = material.baseColor * reflectedColor * giSpecular * material.specular;
    vec3 environment = computeEnvironmentBRDF(specularColor, material.roughness, NxV);
    
    result += environment * material.baseColor;

    // result = giAmbient;

    return result;
}

float computePointLightAttenuation(Light light, float distanceToLight) {

    // return distanceToLight < light.radius ? 1.0 : 0.0;

    float attenuation = pow(1.0 + (distanceToLight / light.radius) , -2.0) * 1.2;

    // Cut light transition starting at 80%. Otherwise it's exponential and never gets really 0
    float cutoff = light.radius * 0.8;
    attenuation *= 1.0 - smoothstep(0.0, 1.0, ( (distanceToLight / cutoff) - 1.0) * 4.0 );   
    attenuation = max(0.0, attenuation);

    return attenuation;
}



// http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/
vec2 getShadowOffsets(vec3 N, vec3 L) {
    float cos_alpha = saturate(dot(N, L));
    float offset_scale_N = sqrt(1 - cos_alpha*cos_alpha); // sin(acos(L·N))
    float offset_scale_L = offset_scale_N / cos_alpha;    // tan(acos(L·N))
    return vec2(offset_scale_N, min(2, offset_scale_L));
}

float computeShadowsForSource(ShadowSource source, Material material, vec3 n, vec3 l, 
    float slopeScaledBias, float normalScaledBias, float baseBias) {

    #ifdef DEBUG_DISABLE_SHADOWS
        return 0.0;
    #endif

    vec2 offsets = getShadowOffsets(n, l);
    vec3 biasedPos = material.position;
    float resFactor = 1024.0 / float(source.resolution);
    float baseShift = 0.3;

    biasedPos += baseShift * l * offsets.x * slopeScaledBias;
    biasedPos += baseShift * n * offsets.y * normalScaledBias;

    vec4 projected = source.mvp * vec4(biasedPos, 1);
    resFactor = min(resFactor, 1.0);

    // Parabolic transform
    // projected = transformParabol(projected, currentSource.nearPlane, currentSource.farPlane);            
    // projected = projected * 0.5 + 0.5;    

    float pixOffset = 1.5 / SHADOW_MAP_ATLAS_SIZE;

    vec3 projCoord = projected.xyz / projected.w;
    projCoord.xyz = projCoord.xyz * 0.5 + 0.5;

    float pixScaled = 2.0 / float(source.resolution);

    if (any(lessThan(projCoord.xy, vec2(pixScaled))) || any(greaterThan(projCoord.xy, vec2(1-pixScaled)))) {
        return 0.0;
    }

    vec2 centerCoord = convertAtlasCoord(projCoord.xy, source);

    // apply point light shadows
    float shadowFactor = 0.0;
    for (int i = 0; i < SHADOWS_NUM_SAMPLES; i++) {

        vec2 offset = poissonDisk16[i] * pixOffset;

        #if SHADOWS_NUM_SAMPLES == 1
            offset = vec2(0);
        #endif

        #if USE_HARDWARE_PCF
            float sampled = texture(shadowAtlas, vec3(centerCoord + offset, projCoord.z - baseBias) ); // .r?
            shadowFactor += (1.0 - sampled);
        #else
            float sampled = textureLod(shadowAtlas, centerCoord + offset , 0).r;
            shadowFactor += step(sampled, projCoord.z - baseBias);
        #endif
    }
    shadowFactor /= SHADOWS_NUM_SAMPLES;

    return 1.0 - shadowFactor;
}


#include "Includes/Lights.include" 
