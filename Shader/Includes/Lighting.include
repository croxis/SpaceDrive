
#include "Includes/Configuration.include"
#include "Includes/Light.include"
#include "Includes/Random.include"
#include "Includes/LightingModels.include"
#include "Includes/Material.include"
#include "Includes/ParabolicTransform.include"
#include "Includes/ShadowSource.include"
#include "Includes/PositionReconstruction.include"
#include "Includes/PoissonDisk.include"
#include "Includes/SphericalHarmonics.include"


uniform samplerCube directionToFace;
uniform samplerCube fallbackCubemap;

const mat4 shadowBiasMatrix = mat4(
    0.5, 0.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 0.0,
    0.0, 0.0, 0.5, 0.0,
    0.5, 0.5, 0.5, 1.0
);


#if USE_HARDWARE_PCF
    uniform sampler2DShadow shadowAtlas;
#else
    uniform sampler2D shadowAtlas;
#endif

vec2 convertAtlasCoord(vec2 rawCoord, ShadowSource source) {
    // Todo: Raw coord can be simply clamped to 0 .. 1 instead of clamping the result
    float factor = float(source.resolution) / SHADOW_MAP_ATLAS_SIZE;
    float factorBy1 = 1.0 / SHADOW_MAP_ATLAS_SIZE;
    return ( clamp(rawCoord * factor, factorBy1, 1.0 - factorBy1) + source.atlasPos);
}


vec3 computeSpecular(vec3 specularColor, float roughness, float NxL, float LxH, float NxV, float NxH) {

    float specularD = DistributionBRDF(roughness, NxH) / M_PI;
    float specularG = GeometricBRDF(roughness, NxV, NxL);
    vec3  specularF = FresnelBRDF(specularColor, LxH);
    
    return genericMicrofacetBRDF(specularF, specularG, specularD, NxL, NxV);
}

vec3 computeLightModel(Light light, Material material, 
        vec3 l, vec3 v, vec3 n, vec3 h, 
        float attenuation, float shadowFactor) {

    #if USE_SIMPLE_LIGHTING
        return light.color * attenuation;
    #else

        // Performance optimization
        if (shadowFactor < 0.001) return vec3(0.0);

        vec3 lightingResult = vec3(0);
        vec3 specularColor = mix(vec3(1), material.baseColor, material.metallic) * material.specular;
        vec3 diffuseColor = mix(material.baseColor, vec3(0), material.metallic);

        float roughness = clamp(material.roughness, 0.005, 1.0);

        // pre-computed cross products
        float NxL = saturate(dot(n, l));
        float LxH = saturate(dot(l, h));
        float NxV = saturate(dot(n, v));
        float NxH = saturate(dot(n, h));

        // Evaluate specular
        vec3 specularContribution = computeSpecular(specularColor, roughness, NxL, LxH, NxV, NxH) * light.color * NxL * specularColor;

        // Energy conservation
        specularContribution *= pow(1.0 + roughness * 0.5, 2.0);
        lightingResult += vec3(specularContribution);

        // Evaluate diffuse
        vec3 diffuseContribution = diffuseColor / M_PI * NxL * light.color;
        lightingResult += vec3(diffuseContribution);

        // Apply shadows
        lightingResult *= shadowFactor;

        return lightingResult;

    #endif
}

vec3 computeEnvironmentBRDF(vec3 specularColor, float roughness, float NxV)
{
    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
    vec4 r = roughness * c0 + c1;
    float a004 = min( r.x * r.x, exp2( -9.28 * NxV ) ) * r.x + r.y;
    vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
    AB.y *= saturate( 50.0 * specularColor.g );
    return specularColor * AB.x + AB.y;
}

vec3 computeAmbient(Material material, vec4 giAmbient, vec3 giSpecular, vec3 v, vec3 n) {

    #ifdef DEBUG_DISABLE_AMBIENT
        return vec3(0.0);
    #endif

    vec3 reflectedDir = reflect( v, material.normal );
    float mipmap = log2(material.roughness * 800.0);
    vec3 reflection1 = textureLod(fallbackCubemap, reflectedDir.xzy, mipmap).rgb;
    vec3 reflection2 = textureLod(fallbackCubemap, reflectedDir.xzy, mipmap - 1.0).rgb;
    vec3 reflectedColor = reflection1*0.5 + reflection2*0.5;
    reflectedColor *= reflectedColor;

    // No additional reflections for complex scenes
    // reflectedColor = vec3(0.4);
    // reflectedColor = mix(reflectedColor, vec3(0.1), 0.8);
    // reflectedColor *= 8.0;

    float NxV = max(0.0, dot(material.normal, v));
    vec3 result = vec3(0);

    result += giAmbient.xyz * 0.1 * material.baseColor * (1.0 - material.metallic);

    vec3 specularColor = material.baseColor * reflectedColor * giSpecular * material.specular;
    vec3 environment = computeEnvironmentBRDF(specularColor, material.roughness, NxV);
    
    result += environment * material.baseColor;
    
    // Cheap SH
    result *= 1.0 + abs(material.normal.x)*0.2;

    return result;
}

float computePointLightAttenuation(Light light, float distanceToLight) {

    // Hard transition
    // return distanceToLight < light.radius ? 1.0 : 0.0;

    // Soft transition
    float attenuation = pow(1.0 + (distanceToLight / light.radius) , -2.0) * 1.2;

    // Cut light transition starting at 80% because the curve is exponential and never gets really 0
    float cutoff = light.radius * 0.8;
    attenuation *= 1.0 - smoothstep(0.0, 1.0, ( (distanceToLight / cutoff) - 1.0) * 4.0 );   
    attenuation = max(0.0, attenuation);
    return attenuation;
}


// http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/
// Apply a bias to the shadowmaps
vec2 getShadowOffsets(vec3 N, vec3 L) {
    float cos_alpha = saturate(dot(N, L));
    float offset_scale_N = sqrt(1 - cos_alpha*cos_alpha); // sin(acos(L·N))
    float offset_scale_L = offset_scale_N / cos_alpha;    // tan(acos(L·N))
    return vec2(offset_scale_N, min(2, offset_scale_L));
}

vec3 reprojectShadow(ShadowSource source, vec3 pos) {
    vec4 projected = source.mvp * vec4(pos, 1);
    return (projected.xyz / projected.w * 0.5) + 0.5;
}

vec3 computeBiasedPosition(Material material, float slopeBias, float normalBias, vec3 l, vec3 n) {
    vec3 biasedPos = material.position;
    float baseShift = 10.0;
    vec2 offsets = getShadowOffsets(n, l);
    biasedPos += baseShift * l * offsets.x * slopeBias;
    biasedPos += baseShift * n * offsets.y * normalBias; 
    return biasedPos;
}


bool coord_inside(vec2 coord, vec2 min_coord, vec2 max_coord) {
    return all(greaterThan(coord, min_coord)) && all(lessThan(coord, max_coord));
}


float pcssKernel(ShadowSource source, vec3 projCoord, float baseBias) {


    #ifndef DEBUG_DISABLE_PCSS

    // Project 2 points on the xy plane to find out the filter radius in shadowmap space.
    // This ensures the correct filtering for split shadow sources
    vec3 point1 = vec3(0,0,0);
    vec3 point2 = vec3(1,1,0) * PSSM_RADIUS_WS;

    vec3 proj1 = reprojectShadow(source, point1);
    vec3 proj2 = reprojectShadow(source, point2);

    // The filter size is the difference of both lightspace pixels
    vec2 projSize = abs(proj1.xy - proj2.xy);


    vec2 centerCoord = convertAtlasCoord(projCoord.xy, source);
   
    vec2 searchRegionRadiusUV = PCSS_SEARCH_RADIUS * projSize;

    float blockerSum = 0.0;
    float numBlockers = 0.0;
    float biasedDepth = projCoord.z - baseBias;

    // Find blocker
    for ( int i = 0; i < PCSS_SEARCH_SAMPLES; ++i )
    {
        vec2 offset = poissonDisk64[i] * searchRegionRadiusUV;
        float shadowMapDepth = textureLod(shadowAtlas, centerCoord + offset , 0).x;
        float factor = step(shadowMapDepth, biasedDepth);
        numBlockers += factor;
        blockerSum += shadowMapDepth * factor;
    }

    float avgBlockerDepth = blockerSum / numBlockers;
    float penumbraSize = abs(biasedDepth - avgBlockerDepth) / biasedDepth * 20.0;

    if (numBlockers < 0.5) return 1.0;

    penumbraSize = min(penumbraSize, 15.0);

    vec2 filterRadiusUV = penumbraSize * PCSS_FILTER_RADIUS * projSize;

    // PCF Filter
    float sum = 0.0;

    for ( int i = 0; i < PCSS_FILTER_SAMPLES; ++i )
    {
        vec2 offset = poissonDisk64[i] * filterRadiusUV;
        float sampled = textureLod(shadowAtlas, centerCoord + offset , 0).x;
        sum += step(sampled, biasedDepth);        
    }
    sum /= PCSS_FILTER_SAMPLES;
    // return 1.0 - saturate(pow(sum, 2.0));
    return 1.0 - saturate(sum);

    #else

        vec2 centerCoord = convertAtlasCoord(projCoord.xy, source);
        float biasedDepth = projCoord.z - baseBias;
        float sampled = textureLod(shadowAtlas, centerCoord, 0).x;
        return 1.0 - step(sampled, biasedDepth);


    #endif
}

float computeShadowsForSource(ShadowSource source, Material material, vec3 n, vec3 l, 
    float slopeScaledBias, float normalScaledBias, float baseBias) {

    #ifdef DEBUG_DISABLE_SHADOWS
        return 0.0;
    #endif

    vec3 biasedPos = computeBiasedPosition(material, slopeScaledBias, normalScaledBias, n, l);
    vec3 projCoord = reprojectShadow(source, biasedPos);

    float pixScaled = 2.0 / float(source.resolution);

    if (any(lessThan(projCoord.xy, vec2(pixScaled))) || any(greaterThan(projCoord.xy, vec2(1-pixScaled)))) {
        return 1.0;
    }

    
    return pcssKernel(source, projCoord, baseBias);
}

float computePSSMShadowsForLight(Light light, Material material, vec3 n, vec3 l, 
    float slopeScaledBias, float normalScaledBias, float baseBias, out int map_used) {

    map_used = 0;
    #ifdef DEBUG_DISABLE_SHADOWS
        return 0.0;
    #endif

    vec3 biasedPos = computeBiasedPosition(material, slopeScaledBias, normalScaledBias, n, l);
    int shadow_map_index = 6;
    vec3 projCoord = vec3(0);

    for (int i = 0; i < 6; i++) {
        int sourceIndex = light.sourceIndexes[i];
        ShadowSource source = shadowSources[sourceIndex];
        projCoord = reprojectShadow(source, biasedPos);

        // Border
        float pixScaled = 250.0 / float(source.resolution);

        if (all(greaterThan(projCoord.xy, vec2(pixScaled))) && all(lessThan(projCoord.xy, vec2(1-pixScaled)))) {
            // Source can be used
            shadow_map_index = i;
            break;
        }
    }

    if (shadow_map_index > 6) return 0.0;

    ShadowSource source = shadowSources[shadow_map_index];
    vec2 centerCoord = convertAtlasCoord(projCoord.xy, source);
    map_used = shadow_map_index;
    return pcssKernel(source, projCoord, baseBias);


}


#include "Includes/Lights.include" 
