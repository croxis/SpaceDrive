
#include "Includes/Light.include"
#include "Includes/LightingModels.include"
#include "Includes/Material.include"
#include "Includes/ParabolicTransform.include"
#include "Includes/ShadowSource.include"
#include "Includes/PositionReconstruction.include"
#include "Includes/PoissonDisk.include"

uniform samplerCube directionToFace;
uniform samplerCube fallbackCubemap;

const mat4 shadowBiasMatrix = mat4(
    0.5, 0.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 0.0,
    0.0, 0.0, 0.5, 0.0,
    0.5, 0.5, 0.5, 1.0
);


#if USE_HARDWARE_PCF
    uniform sampler2DShadow shadowAtlas;
#else
    uniform sampler2D shadowAtlas;
#endif


vec2 convertAtlasCoord(vec2 rawCoord, ShadowSource source) {
    // Todo: Raw coord can be simply clamped to 0 .. 1 instead of clamping the result
    float factor = float(source.resolution) / SHADOW_MAP_ATLAS_SIZE;
    float factorBy1 = 1.0 / SHADOW_MAP_ATLAS_SIZE;
    return ( clamp(rawCoord * factor, factorBy1, 1.0 - factorBy1) + source.atlasPos);
}

vec3 computeLightModel(Light light, Material material, vec3 l, vec3 v, vec3 n, vec3 h, float attenuation) {

    // return vec3(attenuation);

    #if USE_SIMPLE_LIGHTING

        // return max(vec3(0.0), light.color * attenuation * dot(n, l));
        return light.color * attenuation;

    #else

        /*
            TODO: Optimize
        */

        float roughness = clamp(material.roughness, 0.005, 1.0);
        float specular = material.specular;
        float refractiveFactor = material.metallic * 0.5 + 0.5;

        vec3 diffuseColor = material.baseColor * (1.0 - material.metallic);
        vec3 specularColor = material.baseColor * (material.metallic) + specular * (1.0 - material.metallic);

        // Compute reflection
        vec3 reflectedDir = reflect( v, n);

        float cubemapResolutionParameter = material.roughness;
        vec3 reflection1 = textureLod(fallbackCubemap, reflectedDir.xzy, cubemapResolutionParameter * 60.0).rgb;
        vec3 reflection2 = textureLod(fallbackCubemap, reflectedDir.xzy, cubemapResolutionParameter * 60.0 - 1.0).rgb;
        vec3 reflectedColor = reflection1*0.5 + reflection2*0.5;
        // vec3 reflectedColor = vec3(1);

        // Compute specular BRDF
        float specG = clamp(specularBrdfG(l, v, h, n, roughness), 0, 1);
        vec3  specF = clamp(specularBrdfFresnel(specularColor, safeDot(v, n)  ) , 0, 1);

        // D is not clamped, highlights can get very bright
        float specD = specularBrdfD(n, h, roughness); 

        // Compute diffuse BRDF
        // vec3 diffuseBrdf = diffuseBrdfOrenNayar(l, v, n) * safeDot(n, l);
        vec3 diffuseBrdf = vec3(diffuseBrdfSimpleOrenNayar(l, v, n, 1.5));

        // Combine specular
        vec3 specularTerm = (specF * specG * specD) * max(0.0, 4.0 * dot(n, l) * dot(n, v));

        // Compute total contributions
        vec3 diffuseContribution = diffuseColor * diffuseBrdf * attenuation * light.color;
        vec3 specularContribution = specularTerm * attenuation * light.color * specular * mix(vec3(1.0), material.baseColor, material.metallic*0.5 + 0.5); 
        vec3 refractiveContribution = reflectedColor * refractiveFactor * specularColor *
                                        specF * attenuation * light.color * material.baseColor * max(0.01, safeDot(n, l));

       
        vec3 combinedContribution = refractiveContribution + diffuseContribution + specularContribution;
        return max(vec3(0.0), combinedContribution) ;

    #endif


}

float getRandom(vec2 seed) {
    float dot_product = dot(seed, vec2(12.9898,78.233));
    return fract(sin(dot_product) * 43758.5453);
}


float computePointLightAttenuation(Light light, float distanceToLight) {

    // return distanceToLight < light.radius ? 1.0 : 0.0;

    float attenuation = pow(1.0 + (distanceToLight / light.radius) , -2.0) * 1.2;

    // Cut light transition starting at 80%. Otherwise it's exponential and never gets really 0
    float cutoff = light.radius * 0.8;
    attenuation *= 1.0 - smoothstep(0.0, 1.0, ( (distanceToLight / cutoff) - 1.0) * 4.0 );   
    attenuation = max(0.0, attenuation);

    return attenuation;
}

vec3 applyPointLight(Light light, Material material 
    OCCLUSION_PER_LIGHT_RECV_PARAMETERS ) {

    float distanceToLight = distance(material.position, light.position);   
    float distanceRelative = distanceToLight / light.radius; 
    float attenuation = computePointLightAttenuation(light, distanceToLight);

    vec3  l = normalize(light.position - material.position);
    vec3  v = normalize(cameraPosition - material.position);
    vec3  n = normalize(material.normal);
    vec3  h = normalize(l + v);
    vec3 ambientContribution = 0.1 * material.baseColor * light.ambient * attenuation;

    APPLY_OCCLUSION();

    return computeLightModel(light, material, l,v, n, h, attenuation) + ambientContribution;
}

// http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/
vec2 getShadowOffsets(vec3 N, vec3 L) {
    float cos_alpha = saturate(dot(N, L));
    float offset_scale_N = sqrt(1 - cos_alpha*cos_alpha); // sin(acos(L·N))
    float offset_scale_L = offset_scale_N / cos_alpha;    // tan(acos(L·N))
    return vec2(offset_scale_N, min(2, offset_scale_L));
}



float computeShadowsForSource(ShadowSource source, Material material, vec3 n, vec3 l, 
    float slopeScaledBias, float normalScaledBias, float baseBias) {

    vec2 offsets = getShadowOffsets(n, l);
    vec3 biasedPos = material.position;
    float resFactor = 1024.0 / float(source.resolution);
    float baseShift = 0.3;

    biasedPos += baseShift * l * offsets.x * slopeScaledBias;
    biasedPos += baseShift * n * offsets.y * normalScaledBias;

    vec4 projected = source.mvp * vec4(biasedPos, 1);
    resFactor = min(resFactor, 1.0);

    // Parabolic transform
    // projected = transformParabol(projected, currentSource.nearPlane, currentSource.farPlane);            
    // projected = projected * 0.5 + 0.5;    

    vec3 projCoord = projected.xyz / projected.w;
    projCoord.xyz = projCoord.xyz * 0.5 + 0.5;
    vec2 centerCoord = convertAtlasCoord(projCoord.xy, source);


    float pixOffset = 2.0 / SHADOW_MAP_ATLAS_SIZE;
    // float baseBias = 0.0002;

    // pixOffset = 0.0;
    #define SHADOWS_NUM_SAMPLES 16

    // apply point light shadows
    float shadowFactor = 0.0;
    for (int i = 0; i < SHADOWS_NUM_SAMPLES; i++) {

        vec2 offset = poissonDisk16[i] * pixOffset;

        #if USE_HARDWARE_PCF
            // Notice: when using opengl 4.1+, it has to be texture(xxx).r 
            float sampled = texture(shadowAtlas, vec3(centerCoord + offset, projCoord.z - baseBias) );
            shadowFactor += (1.0 - sampled);
        #else
            float sampled = textureLod(shadowAtlas, centerCoord + offset , 0).r;
            shadowFactor += step(sampled, projCoord.z - baseBias);
        #endif
    }
    shadowFactor /= SHADOWS_NUM_SAMPLES;

    return shadowFactor;
}


vec3 applyPointLightWithShadow(Light light, Material material
    OCCLUSION_PER_LIGHT_RECV_PARAMETERS ) {

    float distanceToLight = distance(material.position, light.position);   
    float distanceRelative = distanceToLight / light.radius; 
    float attenuation = computePointLightAttenuation(light, distanceToLight);

    vec3  l = normalize(light.position - material.position);
    vec3  v = normalize(cameraPosition - material.position);
    vec3  n = normalize(material.normal);
    vec3  h = normalize(l + v);

    APPLY_OCCLUSION();

    vec3 rawLighting = computeLightModel(light, material, l,v, n, h, attenuation);

    // We decide which shadow map to sample using a simple lookup cubemap
    int faceIndex = int( textureLod(directionToFace, l, 0).r * 5.0);
    int shadowSourceIndex = light.sourceIndexes[faceIndex];

    ShadowSource currentSource = shadowSources[shadowSourceIndex]; 

    float shadowFactor = computeShadowsForSource(currentSource, material, n, l, 1.0, 1.0, 0.0002);

    // Apply shadows
    rawLighting *= max(0.0, 1.0 - shadowFactor);

    vec3 ambientContribution = 0.1 * material.baseColor * light.ambient * attenuation;

    return max(vec3(0.0), rawLighting) + ambientContribution;
}


vec3 applyDirectionalLight(Light light, Material material
    OCCLUSION_PER_LIGHT_RECV_PARAMETERS ) {

    float distanceToLight = distance(material.position, light.position);   
    float distanceRelative = distanceToLight / light.radius; 
    float attenuation = 1.0;

    vec3  l = light.direction;
    vec3  v = normalize(cameraPosition - material.position);
    vec3  n = normalize(material.normal);
    vec3  h = normalize(l + v);

    APPLY_OCCLUSION();


    vec3 ambientContribution = 0.1 * material.baseColor * light.ambient * attenuation;
    return computeLightModel(light, material, l,v, n, h, attenuation) + ambientContribution;
}

vec3 applyDirectionalLightWithShadow(Light light, Material material, vec3 shAmbient
    OCCLUSION_PER_LIGHT_RECV_PARAMETERS ) {

    float distanceToLight = distance(material.position, light.position);   
    float distanceRelative = distanceToLight / light.radius; 
    float attenuation = 1.0;

    vec3  l = light.direction;
    vec3  v = normalize(cameraPosition - material.position);
    vec3  n = normalize(material.normal);
    vec3  h = normalize(l + v);

    APPLY_OCCLUSION();

    int shadowSourceIndex = light.sourceIndexes[0];
    ShadowSource currentSource = shadowSources[shadowSourceIndex]; 

    float shadowFactor = computeShadowsForSource(currentSource, material, n, l, 0.0, 0.0, 0.0004);

    vec3 rawLighting = computeLightModel(light, material, l,v, n, h, attenuation);
    // Apply shadows
    rawLighting *= max(0.0, 1.0 - shadowFactor);

    // vec3 ambientContribution = 0.1 * material.baseColor * light.ambient * attenuation;
    vec3 ambientContribution = 0.1 * material.baseColor * mix(shAmbient, light.ambient, 0.7) * attenuation;
    return rawLighting + ambientContribution;
}

