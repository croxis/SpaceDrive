#pragma once

#pragma include "Includes/Configuration.include"
#pragma include "Includes/TransparentMaterial.include"


void saveMaterialNextPointer(uint pointer, uint position) {
    uvec4 data = imageLoad(materialDataBuffer, int(position)*2 );
    data.w = pointer;
    imageStore(materialDataBuffer, int(position)*2, data);
}


vec3 encodeNormal(vec3 n)
{
    vec2 enc = normalize(n.xy) * (sqrt(n.z*0.5+0.5));
    enc = enc*0.5+0.5;
    return vec3(enc, 0);
}
void renderTransparentMaterial(TransparentMaterial tm) {

    #if !defined(DEBUG_DISABLE_TRANSPARENCY)

    if (tm.depth > 1.0) discard;

    ivec2 coord = ivec2(gl_FragCoord.xy);

    tm.texcoord = gl_FragCoord.xy / vec2(WINDOW_WIDTH, WINDOW_HEIGHT);
    tm.color = saturate(tm.color);
    tm.alpha = saturate(tm.alpha);
    tm.nextEntry = 0u;
    tm.normal = normalize(tm.normal);
    tm.depth = saturate(gl_FragCoord.z);    
    tm.roughness = saturate(tm.roughness);
    tm.specular = saturate(tm.specular);
    tm.metallic = saturate(tm.metallic);

    // tm.depth = 4.0;


    // Spinlock while editing the linked list
    bool done = false;

    uint locked = 0;
    int max_iter = 12;

    // Allocate buffer position
    uint position = imageAtomicAdd(pixelCountBuffer, ivec2(0, 0), 1) + 1;

    // Store material
    while(!done && max_iter --> 0)
    {
        locked = imageAtomicExchange(spinLockBuffer, coord, 1);
        if (locked == 0)
        {

            // Insert the material to the per pixel list
            uint listHead = imageLoad(listHeadBuffer, coord).x;

            // We are the first fragment
            if (listHead == 0u) {
                imageStore(listHeadBuffer, coord, uvec4(position) );
                tm.nextEntry = 0u;
            } else {
                tm.nextEntry = listHead;
                imageStore(listHeadBuffer, coord, uvec4(position));
            }


            memoryBarrier();
            imageAtomicExchange(spinLockBuffer, coord, 0);
            done = true;
        }
    }

    // Store material
    uvec4 data1, data2;
    packTransparentMaterial(tm, data1, data2);

    imageStore(materialDataBuffer, int(position)*2, data1);
    imageStore(materialDataBuffer, int(position)*2+1, data2);

    #endif

    discard;

}
