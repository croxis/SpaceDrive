#version 430


#pragma include "Includes/Configuration.include"
#pragma include "Includes/Structures/GIData.struct"
#pragma include "Includes/PoissonDisk.include"

out vec4 color;



uniform GIData giData;


uniform int photonOffset;
uniform samplerBuffer sourcePhotonBufferTex;
uniform isampler2D sourcePhotonCounterTex;
uniform sampler2D noiseTex;
uniform vec3 baseVoxelGridPos;

layout(r32ui) uniform uimage3D gatherGridBuffer;


vec3 convertToGrid(vec3 worldPos) {
    vec3 gridStart = baseVoxelGridPos - giData.gridHalfSize;
    vec3 gridEnd = baseVoxelGridPos + giData.gridHalfSize;
    vec3 localCoord = (worldPos-gridStart) / (2 * giData.gridHalfSize);
    return localCoord;
}

vec3 convertFromGrid(vec3 gridPos) {
    vec3 gridStart = baseVoxelGridPos - giData.gridHalfSize;
    return gridPos*2*giData.gridHalfSize + gridStart;
}


vec3 snapToGrid(vec3 gridPos) {
    return gridPos - mod(gridPos, 1.0 / float(giData.gridResolution.x));
    // return gridPos;
}

ivec3 getVoxelID(vec3 gridPos) {
    return ivec3(gridPos * giData.gridResolution + 0.5);
}

// Start pos in voxel space
void raycast(vec3 startPos, vec3 direction, out vec3 voxelColor, out vec3 voxelPos) {

    voxelColor = vec3(0);
    voxelPos = vec3(0);

    const int numSteps = 100;

    direction = normalize(direction);
    float max_comp = max(direction.x, max(direction.y, direction.z));
    // direction /= max_comp;
    // direction *= 2.0;

    vec3 directionStep = direction / numSteps;
    vec3 currentPos = startPos;
    currentPos += 2.5 * normalize(direction) / vec3(giData.gridResolution);

    // ivec3 currentVoxelID = getVoxelID(currentPos);

    for (int i = 0; i < numSteps; i++) {
        currentPos += directionStep;

        // currentPos = snapToGrid(clamp(currentPos, vec3(0), vec3(1)));
        vec4 voxelData = textureLod(giData.voxels, currentPos, 0);
        if (length(voxelData.xyz) > 0.0001) {
            voxelPos = currentPos;
            voxelColor = voxelData.xyz;
            return;
        }

    }

}


uniform int shiftSize;

void spawnPhoton(vec3 pos, vec3 color, float brightness) {
    vec3 voxelSpacePos = convertToGrid(pos);
    ivec3 voxelGridPos = ivec3(voxelSpacePos * giData.gridResolution);

    // uint packedColor = packUnorm4x8(vec4(0, color * 0.05));
    uint packedColorHalf = packUnorm4x8(vec4(0, color * 0.025));

    color = saturate(color) * 0.002;
    uint packedColor = int(color.r * 1024) | int(color.g * 1024) << 10 | int(color.b * 1024.0) << 20;


    // uint packedColor = uint(length(color) * 400.0);
    // uint packedColorHalf = uint(length(color) * 150.0);
    imageAtomicAdd(gatherGridBuffer, voxelGridPos, packedColor);

    #if 0

    imageAtomicAdd(gatherGridBuffer, voxelGridPos + ivec3(0,0,1), packedColorHalf);
    imageAtomicAdd(gatherGridBuffer, voxelGridPos + ivec3(0,1,0), packedColorHalf);
    imageAtomicAdd(gatherGridBuffer, voxelGridPos + ivec3(1,0,0), packedColorHalf);

    imageAtomicAdd(gatherGridBuffer, voxelGridPos - ivec3(0,0,1), packedColorHalf);
    imageAtomicAdd(gatherGridBuffer, voxelGridPos - ivec3(0,1,0), packedColorHalf);
    imageAtomicAdd(gatherGridBuffer, voxelGridPos - ivec3(1,0,0), packedColorHalf);

    #endif

}

void main() {

    ivec2 coord = ivec2(gl_FragCoord.xy);
    int photonID = coord.x + coord.y * shiftSize + photonOffset;
    int photonCount = texelFetch(sourcePhotonCounterTex, ivec2(0), 0).x;

    if (photonID >= photonCount) {
        color = vec4(1,0,0,1);
    } else {

        vec4 photonData0 = texelFetch(sourcePhotonBufferTex, photonID*3);
        vec4 photonData1 = texelFetch(sourcePhotonBufferTex, photonID*3 + 1);
        vec4 photonData2 = texelFetch(sourcePhotonBufferTex, photonID*3 + 2);

        vec3 photonPos = photonData1.xyz;
        vec3 photonNormal = photonData0.xyz;
        vec3 photonColor = photonData2.xyz;
        float photonBrightness = photonData0.w;

        float noiseScale = 32.0;
        ivec2 noiseCoord = ivec2(photonPos.x*noiseScale, int(photonPos.y*noiseScale) % 32 + int(photonPos.z*noiseScale)*32 ) % ivec2(32, 1024);
        vec3 perPhotonNoise = texelFetch(noiseTex, noiseCoord, 0).xyz * 2 - 1;

        vec3 gridPhotonPos = convertToGrid(photonPos + photonNormal*0.0);

        const int numSamples = 32;

        for (int i = 0; i < numSamples; i++) {

            vec3 offs = vec3(0);

            if (numSamples > 32) {
                offs = poissonDisk128_3D[i]*2-1;
            } else {
                offs = poisson3D_32[i];
            }

            vec3 firstIntersectionPos;
            vec3 firstIntersectionColor;

            offs += perPhotonNoise * 1.0;
            offs = normalize(offs);
            offs = offs * sign(dot(offs, photonNormal));

            // offs = photonNormal;


            float factor = max(0.5, dot(offs, photonNormal));

            // if (factor < 0.3) continue;
            // factor = sin(factor);
            // factor = 1.0;


            raycast(gridPhotonPos, normalize(offs), firstIntersectionColor, firstIntersectionPos);

            vec3 wsFirstIntersection = convertFromGrid(firstIntersectionPos);

            float rayTravelDist = distance(firstIntersectionPos, gridPhotonPos);
            // factor *= 0.0 + saturate(1.0 - rayTravelDist * 4.0);


            spawnPhoton(wsFirstIntersection, photonColor * factor, photonBrightness);
            // spawnPhoton(wsFirstIntersection, firstIntersectionColor * factor, photonBrightness);



        }

        // spawnPhoton(photonPos, vec3(photonColor), photonBrightness);


        // color = vec4(photonData0.w);
        color = vec4(0,1,0,1);

    }
}