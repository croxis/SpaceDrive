#version 430

// * Unkown algorithm name*
// developed by tobspr

#include "Includes/Configuration.include"
#include "Includes/PositionReconstruction.include"
#include "Includes/Packing.include"

layout (local_size_x = 4, local_size_y = 4, local_size_z=4) in;


uniform sampler2D atlasDepth;
uniform sampler2D atlasColor;
uniform sampler2D atlasNormal;
uniform vec3 gridStart;
uniform vec3 gridEnd;
uniform ivec3 gridSize;
uniform writeonly image2D target;
uniform writeonly image2D targetColor;
uniform vec3 voxelSize;


#define MAX_SOURCE_COUNT 24

uniform int lightCount;
uniform mat4 lightMVPData[MAX_SOURCE_COUNT];
uniform mat4 lightData[MAX_SOURCE_COUNT];


const vec3 texelShift = 1.0 * vec3(0.5, 0.5, 0.5);

void main() {

  // TODO: Optimize

  // Get coords
  ivec3 texelCoords = ivec3(gl_GlobalInvocationID.xyz);
  ivec2 storeCoord = texelCoords.xy + ivec2(texelCoords.z*gridSize.x, 0);

  vec3 localCoords = (vec3(texelCoords)+texelShift) / vec3(gridSize);
  vec3 worldCoords = (localCoords * (gridEnd-gridStart)) + gridStart;

  // In this variables the resulting normals and diffuse is stored
  vec3 resultNormal = vec3(0);
  vec3 resultColor = vec3(0);
  float resultShadowFactor = 0.0;

  float solid = 0.01;

  // Process each shadow source, to get as many accurate normals as possible
  for (int i = 0; i < min(lightCount, MAX_SOURCE_COUNT); i++) {

    mat4 data = lightData[i];
    mat4 mvp = lightMVPData[i];

    // Unpack data
    float impactFactor = data[0].w;
    vec2 sourceAtlasPos = data[0].xy;
    float sourceAtlasScale = data[0].z; 

    float nearPlane = data[1].x;
    float farPlane = data[1].y;

    vec3 lightDir = normalize(data[2].xyz);
    vec3 color = data[3].xyz;

    // Shadow projection
    vec4 projected = mvp * vec4(worldCoords, 1);
    vec3 projCoord = projected.xyz / projected.w;
    projCoord.xyz = projCoord.xyz * 0.5 + 0.5;

    float texSize = (1.0 / SHADOW_MAP_ATLAS_SIZE) / sourceAtlasScale;
    float resolution  = SHADOW_MAP_ATLAS_SIZE * sourceAtlasScale;

    // fov of 90 with aspect ratio of 1:1 => total subtended solid angle of 4Pi / 6 = 2.09439510f
    //float subtendedSolidAnglePerTexel = 2.09439510f / g_RSMResolution / g_RSMResolution;
    float fluxQuota = 1.0 / 6.0 / resolution / resolution;
    fluxQuota = 1.0;

    // Clamp to borders
    if (all(greaterThan(projCoord.xy, vec2(texSize))) &&
        all(lessThan(projCoord.xy, vec2(1.0-texSize))) ) {

      // Convert 0..1 coord to atlas space coord
      vec2 atlasCoord = projCoord.xy*sourceAtlasScale + sourceAtlasPos;

      // Shadowed?
      float sampledZ = texture(atlasDepth, atlasCoord.xy).x;

      float sampledLinear = getCustomLinearZFromZ(sampledZ, nearPlane, farPlane);
      float voxelLinear = getCustomLinearZFromZ(projCoord.z, nearPlane, farPlane);

      float sampleDifferenceLinear = sampledLinear - voxelLinear;
      float shadowFactor = 1.0 - step(sampleDifferenceLinear, -length(voxelSize)*mix(1.0, 0.05, impactFactor));

      // Read RSM
      vec3 diffuse = texture(atlasColor, atlasCoord).rgb;

      // Normal is stored packed
      vec3 normal = normalize(texture(atlasNormal, atlasCoord).rgb*4.0 - 2.0);
      
      if ( abs(sampleDifferenceLinear) < length(voxelSize)*mix(0.3, 0.002, impactFactor) &&  impactFactor > -0.5 && shadowFactor >= 0.5 ) {

        // resultNormal += reflect(-lightDir, normal);

        // if (impactFactor < 0.5) {
            // This is a light which only helps creating the voxels. It does not
            // emit VPLS
            resultNormal += normal * (1.0 - impactFactor);
            solid += 1.0 - impactFactor;
        // } else {

            // This is a light which emits VPLS. It does not create voxels, yet
            // Material diffuse is premultiplied
            vec3 flux = fluxQuota * saturate(dot(normal, lightDir)) * vec3(diffuse);
            // flux = vec3(1);
   

            resultColor += flux;
            
        // }
        // resultNormal = normalize(resultNormal);

        // resultShadowFactor += shadowFactor;
        // resultNormal = vec3(shadowFactor*0.5);
      }
   
    }
  }

  solid = saturate(solid);

  // resultColor *= 0.2;

  imageStore(target, storeCoord, vec4(resultNormal, solid) );
  imageStore(targetColor, storeCoord, vec4(resultColor, solid) );
}