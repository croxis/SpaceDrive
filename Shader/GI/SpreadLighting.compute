#version 430

// * Unkown algorithm name*
// developed by tobspr


#include "Includes/Packing.include"

layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

uniform sampler2D source;
uniform sampler2D sourceColor;
uniform writeonly image2D target;
uniform writeonly image2D targetColor;
uniform ivec3 gridSize; 


ivec2 convertCoords(ivec3 src) {
  return clamp(src.xy, ivec2(0), gridSize.xy-1) + ivec2(clamp(src.z, 0, gridSize.z-1)*gridSize.x, 0);
}


const float bounceFactor = 1.0;
const float rangeMultiplier = 2520.0;
const float transport = 0.08;
const float colorTransport = 0.0008;
const float normalBias = 1.0;

void main() {

  ivec3 texelCoords = ivec3(gl_GlobalInvocationID.xyz);
  ivec2 storeCoord = convertCoords(texelCoords);

  vec4 sampleCenter      = texelFetch(source, storeCoord, 0);
  vec4 sampleCenterColor = texelFetch(sourceColor, storeCoord, 0);

  vec4 colorResult = sampleCenterColor;
  vec4 normalResult = sampleCenter;

  // if (length(normalResult.xyx) < 0.1) {
  //   normalResult.xyz = vec3(0,0,1);
  // }

  const int numDirections = 6; 

  ivec3 directions[numDirections] = ivec3[numDirections](
      
      // Along the axis
      ivec3(0,0,1),
      ivec3(0,0,-1),
      ivec3(0,1,0),
      ivec3(0,-1,0),
      ivec3(1,0,0),
      ivec3(-1,0,0)

      // Diagonal
      // ivec3(1,1,1),
      // ivec3(-1,1,1),
      // ivec3(1,-1,1),
      // ivec3(-1,-1,1),

      // ivec3(1,1,-1),
      // ivec3(-1,1,-1),
      // ivec3(1,-1,-1),
      // ivec3(-1,-1,-1)
    );


  for (int i = 0; i < numDirections; i++) {
    ivec3 dir = directions[i];
    ivec2 coords = convertCoords(texelCoords + dir);
    vec4 sampleNormal = texelFetch(source, coords, 0);
    vec4 sampleColor = texelFetch(sourceColor, coords, 0);

    // no solid voxel
    if (sampleColor.w < 0.0001) {
      continue;
    }

    float localFactor = max(normalBias, dot(sampleNormal.xyz, -dir )) * rangeMultiplier;
    // localFactor = 0.5;
    colorResult += sampleColor * bounceFactor * transport * localFactor * vec4(colorTransport,colorTransport,colorTransport,1.0);
    normalResult.xyz += sampleNormal.xyz * bounceFactor * localFactor * transport;
    // colorResult.w += localFactor * 0.05;

  }

  // Normalize, but only if length(normal) > 1.0
  float normalLength = max(1.0, length(normalResult.xyz));
  normalResult.xyz /= normalLength;


  colorResult.w = clamp(colorResult.w, 0.001, 1.0);

  colorResult.xyz = 1.0 - exp(-0.5 * colorResult.xyz);

  // colorResult.xyz = normalResult.xyz;

  imageStore(target, storeCoord, normalResult);
  imageStore(targetColor, storeCoord, colorResult);
}