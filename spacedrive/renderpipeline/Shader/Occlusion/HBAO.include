#pragma once



// https://gist.github.com/fisch0920/6770346

// number of directions to sample in UV space
#define HBAO_NUM_SAMPLE_DIRECTIONS OCCLUSION_SAMPLES
#define HBAO_TANGENT_BIAS 0.1
#define HBAO_NUM_SAMPLING_STEPS 4
#define HBAO_SAMPLING_STEP 0.01 * OCCLUSION_RADIUS

#define HBAO_SCALE 2.6 * OCCLUSION_STRENGTH
#define HBAO_SAMPLING_RADIUS 2.5 * OCCLUSION_RADIUS

uniform sampler2D viewSpaceNormals;
uniform sampler2D viewSpacePosition;

uniform mat4 currentProjMatInv;
uniform sampler2D depthTex;
uniform sampler2D noiseTex;

const float TWO_PI = 2.0 * M_PI;

float computeOcclusion(vec2 coord, ivec2 coordInt, float distanceToCamera) {

  vec3 viewPos = texture(viewSpacePosition, coord).xyz;
  vec3 viewNorm = texture(viewSpaceNormals, coord).xyz;

  float total = 0.0f;
  float sample_direction_increment = TWO_PI / HBAO_NUM_SAMPLE_DIRECTIONS;
 
  #if defined(ENHANCE_TEMPORAL_OCCLUSION)
    float frame_angle_offset = sample_direction_increment * 0.5 * (frameIndex %2);
  #else
    float frame_angle_offset = 0;
  #endif  

  #if defined(USE_OCCLUSION_NOISE)
    float noise = texelFetch(noiseTex, ivec2(gl_FragCoord) % 4, 0).x * 2.0 - 1.0;
  #else
    float noise = 0.0; 
  #endif


  for(uint i = 0; i < HBAO_NUM_SAMPLE_DIRECTIONS; i++)
  {
    // no jittering or randomization of sampling direction just yet
    float sampling_angle = i * sample_direction_increment + frame_angle_offset + noise * sample_direction_increment; // azimuth angle theta in the paper
    vec2 sampleDir = vec2(cos(sampling_angle), sin(sampling_angle));
    // we will now march along sampleDir and calculate the horizon
    // horizon starts with the tangent plane to the surface, whose angle we can get from the normal
    float tangentAngle = acos(dot(vec3(sampleDir, 0), viewNorm)) - (0.5 * M_PI) + HBAO_TANGENT_BIAS;
    float horizonAngle = tangentAngle;
    vec3 lastDiff = vec3(0);
 
    for (uint j = 0; j < HBAO_NUM_SAMPLING_STEPS; j++)
    {
      // march along the sampling direction and see what the horizon is
      vec2 sampleOffset = float(j+1) * HBAO_SAMPLING_STEP * sampleDir;
      vec2 offTex = coord + sampleOffset;
  

      #if 0 
        // Sample precomputed view pos
        vec3 sampleViewPos = textureLod(viewSpacePosition, offTex, 0).xyz;
      #else
        // Compute view pos from depth, faster for small kernels
        float depth = textureLod(depthTex, offTex, 0).x;
        vec3 ndc = vec3(offTex, depth) * 2.0 - 1.0;
        vec4 sampleViewPos = currentProjMatInv * vec4(ndc, 1.0);
        sampleViewPos.xyz = sampleViewPos.xzy / sampleViewPos.w * vec3(1,1,-1);
      #endif

      // we now have the view space position of the offset point
      vec3 diff = sampleViewPos.xyz - viewPos;
      if (length(diff) < HBAO_SAMPLING_RADIUS)
      {
        // skip samples which are outside of our local sampling radius
        lastDiff = diff;
        float elevationAngle = atan(diff.z / length(diff.xy));
        horizonAngle = max(horizonAngle, elevationAngle);
      }
    } // sampling steps
 
    float normDiff = length(lastDiff) / HBAO_SAMPLING_RADIUS;
    // float attenuation = 1 - normDiff*normDiff;
    float attenuation = 1.0 / (1 + length(lastDiff));
    // now compare horizon angle to tangent angle to get ambient occlusion
    float occlusion = clamp(attenuation * (sin(horizonAngle) - sin(tangentAngle)), 0.0, 1.0);
    total += HBAO_SCALE*occlusion;
  } // sampling directions
 
  total /= HBAO_NUM_SAMPLE_DIRECTIONS;
  // total = pow(total, 0.5);
  total = clamp(total, 0.0, 1.0);
  return total;

}