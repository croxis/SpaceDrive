
#include "Includes/Light.include"
#include "Includes/LightingModels.include"
#include "Includes/Material.include"
#include "Includes/ParabolicTransform.include"
#include "Includes/ShadowSource.include"
#include "Includes/PositionReconstruction.include"
#include "Includes/PoissonDisk.include"

uniform vec3 cameraPosition;
uniform samplerCube fallbackCubemap;

const mat4 shadowBiasMatrix = mat4(
    0.5, 0.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 0.0,
    0.0, 0.0, 0.5, 0.0,
    0.5, 0.5, 0.5, 1.0
);


#if USE_HARDWARE_PCF
    uniform sampler2DShadow shadowAtlas;
#else
    uniform sampler2D shadowAtlas;
#endif





vec2 convertAtlasCoord(vec2 rawCoord, ShadowSource source) {

    float factor = float(source.resolution) / SHADOW_MAP_ATLAS_SIZE;
    float factorBy1 = 1.0 / SHADOW_MAP_ATLAS_SIZE;
    return ( clamp(rawCoord * factor, factorBy1, 1.0 - factorBy1) + source.atlasPos);
}



vec3 computeLightModel(Light light, Material material, vec3 l, vec3 v, vec3 n, vec3 h, float attenuation) {

    #if USE_SIMPLE_LIGHTING

        // return max(vec3(0.0), light.color * attenuation * dot(n, l));
        return light.color * attenuation;

    #else
        float roughness = clamp(material.roughness, 0.005, 1.0);
        float specular = material.specular;
        float refractiveFactor = material.metallic * 0.5 + 0.5;

        vec3 diffuseColor = material.baseColor * (1.0 - material.metallic);
        vec3 specularColor = material.baseColor * (material.metallic) + specular * (1.0 - material.metallic);

        // Compute reflection
        vec3 reflectedDir = reflect( v, n);

        float cubemapResolutionParameter = material.roughness;
        vec3 reflection1 = textureLod(fallbackCubemap, reflectedDir.xzy, cubemapResolutionParameter * 10.0).rgb;
        vec3 reflection2 = textureLod(fallbackCubemap, reflectedDir.xzy, cubemapResolutionParameter * 10.0 - 1.0).rgb;
        vec3 reflectedColor = reflection1*0.5 + reflection2*0.5;

        // Compute specular BRDF
        float specG = clamp(specularBrdfG(l, v, h, n, roughness), 0, 1);
        vec3  specF = clamp(specularBrdfFresnel(specularColor, safeDot(v, n)  ) , 0, 1);

        // D is not clamped, highlights can get very bright
        float specD = specularBrdfD(n, h, roughness); 

        // Compute diffuse BRDF
        // vec3 diffuseBrdf = diffuseBrdfOrenNayar(l, v, n) * safeDot(n, l);
        vec3 diffuseBrdf = vec3(diffuseBrdfSimpleOrenNayar(l, v, n, 1.5));

        // Combine specular
        vec3 specularTerm = (specF * specG * specD) * max(0.0, 4.0 * dot(n, l) * dot(n, v));

        // Compute total contributions
        vec3 diffuseContribution = diffuseColor * diffuseBrdf * attenuation * light.color;
        vec3 specularContribution = specularTerm * attenuation * light.color * specular; 
        vec3 refractiveContribution = reflectedColor * refractiveFactor * specularColor * specF * attenuation * light.color * safeDot(n, l);


        vec3 combinedContribution = refractiveContribution + diffuseContribution + specularContribution;
        return max(vec3(0.0), combinedContribution);

    #endif


}


float getRandom(vec2 seed) {
    float dot_product = dot(seed, vec2(12.9898,78.233));
    return fract(sin(dot_product) * 43758.5453);
}


float computePointLightAttenuation(Light light, float distanceToLight) {
    float attenuation = pow(1.0 + (distanceToLight / light.radius) , -2.0) * 1.2;

    // Cut light transition starting at 80%. Otherwise it's exponential and never gets really 0
    float cutoff = light.radius * 0.8;
    attenuation *= 1.0 - smoothstep(0.0, 1.0, ( (distanceToLight / cutoff) - 1.0) * 4.0 );   
    attenuation = max(0.0, attenuation);

    return attenuation;
}

vec3 applyPointLight(Light light, Material material) {

    float distanceToLight = distance(material.position, light.position);   
    float distanceRelative = distanceToLight / light.radius; 
    float attenuation = computePointLightAttenuation(light, distanceToLight);

    vec3  l = normalize(light.position - material.position);
    vec3  v = normalize(cameraPosition - material.position);
    vec3  n = normalize(material.normal);
    vec3  h = normalize(l + v);

    return computeLightModel(light, material, l,v, n, h, attenuation);
}


vec3 applyPointLightWithShadow(Light light, Material material) {

    float distanceToLight = distance(material.position, light.position);   
    float distanceRelative = distanceToLight / light.radius; 
    float attenuation = computePointLightAttenuation(light, distanceToLight);

    vec3  l = normalize(light.position - material.position);
    vec3  v = normalize(cameraPosition - material.position);
    vec3  n = normalize(material.normal);
    vec3  h = normalize(l + v);


    vec3 rawLighting = computeLightModel(light, material, l,v, n, h, attenuation);

    // apply point light shadows
    float shadowFactor = 0.0;

    // For point lights we can decide by position which shadow map to use
    int shadowIndex = int(step(light.position.y, material.position.y));
    int shadowSourceIndex = light.sourceIndexes[shadowIndex];

    ShadowSource currentSource = shadowSources[shadowSourceIndex]; 

    float resolutionFactor = SHADOW_MAP_ATLAS_SIZE / float(currentSource.resolution);
    float sampleFactor = 1.0 / SHADOW_MAP_ATLAS_SIZE;




    vec4 projected = currentSource.mvp * vec4(material.position, 1);
    projected = transformParabol(projected, currentSource.nearPlane, currentSource.farPlane);            
    projected = projected * 0.5 + 0.5;    
    vec3 projCoord = projected.xyz / projected.w;
    vec2 centerCoord = convertAtlasCoord(projCoord.xy, currentSource);

    float pixOffset = 1.0 / SHADOW_MAP_ATLAS_SIZE;



    float cosTheta = clamp( dot(n, l), 0.0, 1.0 );
    float bias = 0.0013*(0.0+distanceRelative*1.0)*tan(acos(cosTheta)) / resolutionFactor; 
    bias = 0.002;
    bias = clamp(bias, -0.0, 0.04);

    // http://homepage.cs.uiowa.edu/~dou/Paper/Adaptive_Depth_Bias_for_Shadow_Maps.pdf
    float l_f = currentSource.farPlane;
    float l_n = currentSource.nearPlane;

    float sceneScale = 1.0;
    float K = 0.0001;

    // (lf − depth × (lf − ln))²
    float epsilon = pow(l_f - distanceRelative * (l_f - l_n), 2.0);

    // lf × ln × (lf − ln)
    epsilon /= l_f * l_n * (l_f - l_n);

    // × sceneScale × K
    epsilon = distanceRelative * sceneScale * K;

    // bias = 0;

    // bias = 0.0 * tan(acos(dot(n,l)));


    for (int i = 0; i < SHADOWS_NUM_SAMPLES; i++) {

        vec2 offset = poissonDisk16[i] * pixOffset;
        // offset *= 0.0;r

        #if USE_HARDWARE_PCF
            float sampled = texture(shadowAtlas, vec3(centerCoord + offset, projCoord.z - bias) ).r;
            // sampled = sampled*sampled;
            shadowFactor += (1.0 - sampled) / SHADOWS_NUM_SAMPLES;
        #else
            float sampled = textureLod(shadowAtlas, centerCoord + offset , 0).r;
            shadowFactor += step(sampled, projCoord.z - bias) / SHADOWS_NUM_SAMPLES;
            // shadowFactor = sampled - projCoord.z;

        #endif
    }

    // shadowFactor *= 16.0;

    // return vec3( abs(nearestBlocker-centerCoord) * 24.0, 0);
    // shadowFactor = nearestPointDepth * 100000.0;

    // Apply shadows
    rawLighting *= max(0.001, 1.0 - shadowFactor);

    // return vec3(1.0 - shadowFactor) * attenuation;

    // return vec3( 1.0 - shadowFactor );

    // return 1.0 - vec3(pow(shadowFactor, 20.0) * 1000.0) * attenuation;

    return max(vec3(0.0), rawLighting);
}




#if 0


#endif