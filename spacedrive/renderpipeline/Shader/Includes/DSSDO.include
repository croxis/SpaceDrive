


#include "Includes/Configuration.include"
#include "Includes/PoissonDisk.include"
#include "Includes/Random.include"
#include "Includes/Material.include"



#ifdef DSSDO_ENABLED

    // Store configuration variables in const variables
    // const int   dssdoSampleCount = DSSDO_NUM_SAMPLES;
    // const float dssdoRadius      = DSSDO_RADIUS;
    // const float dssdoMaxDistance = DSSDO_MAX_DISTANCE;
    // const float dssdoMaxAngle    = DSSDO_MAX_ANGLE;
    // const float dssdoFactor      = DSSDO_STRENGTH;
    const int   dssdoSampleCount = 32;
    const float dssdoRadius      = 1.0;
    const float dssdoMaxDistance = 5.0;
    const float dssdoMaxAngle    = 0.3;
    const float dssdoFactor      = 1.0;


    const int   dssdoPoissonFactor = 32 / dssdoSampleCount;
    const float fudgeFactorL0      = 2.0;
    const float fudgeFactorL1      = 10.0;
    const float sh2WeightL0        = fudgeFactorL0 * 0.28209; //0.5*sqrt(1.0/pi);
    const vec3  sh2WeightL1        = vec3(fudgeFactorL1 * 0.48860); //0.5*sqrt(3.0/pi);
    const vec4  sh2Weight          = vec4(sh2WeightL1, sh2WeightL0) / dssdoSampleCount;


    uniform sampler2D dssdoNoiseTex;

    float computeDSSDO(vec2 texcoord, ivec2 screenCoord, Material material, float dist, sampler2D normalTex, sampler2D positionTex) {
        
        #ifdef DEBUG_DISABLE_SSDO
            return 1.0;
        #endif

        float radius = clamp( (1.0 / dist) * 1000.0 * dssdoRadius, 0.0, 80.0);
        // radius *= 0.4;
        // radius = 20.0;

        ivec2 screenSize = textureSize(normalTex, 0) - 1;
        vec3 noise = texelFetch(dssdoNoiseTex, screenCoord % 4, 0).rgb*2.0 - 1.0;
        noise *= 0.5;

        float occlusionResult = 0.0;

        for (int i = 1; i < 32; i++) {

            vec3 offset = poisson3D_32[i * dssdoPoissonFactor];

            ivec2 offsetCoord = screenCoord + 
                ivec2(reflect(poisson3D_32[i].xy, noise.xy) * radius);

            offsetCoord = clamp(offsetCoord, ivec2(0), screenSize);

            vec3 position = texelFetch(positionTex, offsetCoord, 0).rgb;
            
            vec3 difference = (position - material.position);
            
            float differenceLength = length(difference);
            
            vec3 differenceNormalized = difference / max(1.0, differenceLength);
            
            float attenuation = 1.0 - saturate( 
                differenceLength / dssdoMaxDistance );

            float dotProduct = max(0.0, dot(material.normal, differenceNormalized) );

            attenuation = attenuation * attenuation * step(dssdoMaxAngle, dotProduct);
            // attenuation = attenuation * attenuation;

            // attenuation = pow(differenceNormalized.x * 2.0, 10.0);

            occlusionResult += attenuation / float(dssdoSampleCount);
            // occlusionResult += attenuation / 1.0;

            // occlusionResult += abs(material.normal.y);

        }

        occlusionResult = 1.0 - max(0.0, occlusionResult * dssdoFactor);
        return saturate(occlusionResult);
    }

#else

    float computeDSSDO(vec2 texcoord, ivec2 screenCoord, Material material, float dist, sampler2D normalTex, sampler2D positionTex) {
        return 1.0;
    }


#endif