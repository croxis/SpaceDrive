#version 150


// FILE: 'Shader/Includes/VertexOutput.include' 
struct VertexOutput {
    vec3 positionWorld;
    vec3 normalWorld;
    vec2 texcoord;

    vec4 materialDiffuse;
    vec4 lastProjectedPos;
};

// Input from the vertex shader
in VertexOutput vOutput;

// Textures Samplers
uniform sampler2D p3d_Texture0;
uniform sampler2D p3d_Texture1;
uniform sampler2D p3d_Texture2;
uniform sampler2D p3d_Texture3;
// uniform sampler2D p3d_Texture4;

// This is required for the materials

// FILE: 'Shader/Includes/MaterialPacking.include' 
// FILE: 'Shader/Includes/Configuration.include' 
// This is the main configuration file, included by almost all shaders

// Max values for the light culling
// If you change anything regarding this in LightManager,
// change it here, too
#define MAX_VISIBLE_LIGHTS 25
#define MAX_LIGHTS_PER_PATCH 63

// Same as in LightManager.py
#define MAX_POINT_LIGHTS 16
#define MAX_SHADOW_POINT_LIGHTS 16

// Max shadow maps. Has to be the same as in LightManager.py
#define SHADOW_MAX_TOTAL_MAPS 24


// Wheter to clear the lighting buffer each frame to be
// able to see changes in lighting - only recommended for debugging
#define LIGHTING_CLEAR_BUFFER_EACH_FRAME


// GLSL really needs this as a builtin!
#define saturate(v) clamp(v, 0, 1)

// Needed for light culling
const float sqrt_of_2 = 1.4142135623;

// Load Auto-Config

// FILE: 'Shader/Includes/AutoGeneratedConfig.include' 
// Autogenerated by RenderPipeline.py
// Do not edit! Your changes will be lost.

#define SMAA_PRESET_ULTRA
#define LIGHTING_COMPUTE_PATCH_SIZE_X 32
#define LIGHTING_COMPUTE_PATCH_SIZE_Y 32
#define LIGHTING_MIN_MAX_DEPTH_ACCURACY 1
#define LIGHTING_ANY_BOUND_CHECK 1
#define LIGHTING_ACCURATE_BOUND_CHECK 1
#define USE_SHADOWS 1
#define SHADOW_MAP_ATLAS_SIZE 8192
#define SHADOW_MAX_UPDATES_PER_FRAME 4
#define SHAODOW_GEOMETRY_MAX_VERTICES 12
#define SHADOWS_NUM_SAMPLES 16
#define USE_HARDWARE_PCF 1
#define WINDOW_WIDTH 1600
#define WINDOW_HEIGHT 900
#define USE_MOTION_BLUR 1
#define MOTION_BLUR_SAMPLES 12
#define DSSDO_ENABLED 1
#define DSSDO_NUM_SAMPLES 8
#define DSSDO_RADIUS 1.0
#define DSSDO_MAX_DISTANCE 4.0
#define DSSDO_MAX_ANGLE 0.4
#define DSSDO_STRENGTH 1.3
#define DEBUGGER_ACTIVE 1
#define DEBUG_RM_DEFAULT 1

// Performance functions

// FILE: 'Shader/Includes/Performance.include' 
vec4 FAST_mul(mat4 m, vec3 v) {
    return m * vec4(v, 1);
    // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] + m[3] ));
}

vec4 FAST_mul_no_w(mat4 m, vec3 v) {
    return m * vec4(v, 0);
     // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] ));
}


vec4 FAST_normalize_prefactor(vec4 v) {
    // todo
    return normalize(v);
}

// Wheter to use post-processing blur, this affects DSSDO
#define USE_OCCLUSION_BLUR



#define M_PI 3.14159265



// #pragma optionNV (unroll all)


#define USE_BINDLESS_TEXTURES 0

#if USE_BINDLESS_TEXTURES
    #define BINDLESS layout(bindless_sampler)
#else
    #define BINDLESS
#endif

// FILE: 'Shader/Includes/Material.include' 
// FILE: 'Shader/Includes/Packing.include' 
// http://aras-p.info/texts/CompactNormalStorage.html
// Packs a normal to a vec2
vec2 encodeNormal(vec3 n)
{
    // Prevents artifacts at surfaces which point to the bottom??
    n *= 0.999;

    float p = inversesqrt(n.z*8+8);
    return vec2(n.xy*p + 0.5);
}

// Unpacks a normal from a vec2
vec3 decodeNormal(vec2 encoded)
{
    vec2 fenc = encoded * 4.0 - 2.0;
    float f = dot(fenc,fenc);
    float g = sqrt(1.0 - f/4.0);
    vec3 n;
    n.xy = fenc * g;
    n.z = 1.0 - f/2.0;
    return n;
}

// // Packs float to 2 floats for more precision

// vec2 packDepth(float d) {
//     // return vec2(d, d);
//     return vec2(floor(d*1024), fract(d*1024));
// }

// // Unpacks 2 floats to one high precision float
// float unpackDepth(vec2 d) {
//     // return d.x;
//     return (d.x + d.y) / 1024.0;
// }

const float colorPackingFactor = 1.0 - (1.0 / 255.0);

vec2 packColor(vec3 color) {
    return vec2(color.x,
            saturate(color.y) * colorPackingFactor +
            ceil(color.z * 255.0)
        );
}

vec3 unpackColor(vec2 pack) {
    return vec3(pack.x, fract(pack.y), floor(pack.y) / 256.0 );
}


struct Material {
    vec3 baseColor;
    float roughness;
    float metallic;
    float specular;
    float transluency;
    vec3 position;
    vec3 normal;
};


Material unpackMaterial(vec4 data0, vec4 data1, vec4 data2) {
    Material m;

    m.position = data0.xyz;
    m.roughness = data0.w;
    m.normal = decodeNormal(data1.xy);
    m.baseColor = unpackColor(data1.zw);
    m.metallic = data2.w;
    m.specular = data2.z;
    // m.transluency = data2.z;

    m.transluency = 0.0;

    return m;
}

uniform mat4 lastMVP;

out vec4 color0;
out vec4 color1;
out vec4 color2;


void renderMaterial(Material m) {

    // Pack values
    vec2 normal = encodeNormal(m.normal);
    vec2 color = packColor( clamp(m.baseColor, 0.0, 100.0) );

    // Compute velocity
    vec4 lastProj = vOutput.lastProjectedPos;

    // Usually it would be lastProj.xy / lastProj.w * 0.5 + 0.5
    // But the vertex shader already does the * 0.5
    vec2 lastTexcoord = lastProj.xy / lastProj.w + 0.5;
    vec2 fragCoord = gl_FragCoord.xy / vec2(WINDOW_WIDTH, WINDOW_HEIGHT);

    // * 255 prevents precision errors
    vec2 velocity = (lastTexcoord - fragCoord) * 255.0;

    // Saturate
    m.roughness = saturate(m.roughness);
    m.metallic = saturate(m.metallic);
    m.specular = saturate(m.specular);

    // Output
    color0 = vec4(m.position.x, m.position.y, m.position.z, m.roughness);
    color1 = vec4(normal.x,normal.y,color.x,color.y);
    color2 = vec4(velocity.x, velocity.y, m.specular, m.metallic);
}


void main() {



    // Create a material to store the properties on
    Material m;

    vec3 normal = normalize(vOutput.normalWorld);
    // vec3 diffuse = vec3(1.0);

    vec3 bump = texture(p3d_Texture1, vOutput.texcoord).rgb*2.0 - 1.0;

    normal = normalize(normal + bump * 0.05);
    // normal = normalize(normal);

    vec4 diffuse = texture(p3d_Texture0, vOutput.texcoord);
    vec4 rawSpecular = texture(p3d_Texture2, vOutput.texcoord);

    diffuse.rgb = vec3(1.0);

    float specular = 0.0;

    // if (diffuse.a < 0.5) discard;

    // specular = 0;

    // vec3 diffuse = vec3(1);

    m.metallic = 0.0;
    m.roughness = 0.0;
    // m.specular = rawSpecular.x;
    m.specular = 0.0;
    m.baseColor = diffuse.rgb;
    m.position = vOutput.positionWorld;
    m.normal = normal;

    // Pack material and output to the render targets
    renderMaterial(m);
}
