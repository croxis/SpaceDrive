#version 150

#extension GL_ARB_shader_image_load_store : enable

// TODO: Make some benchmarks to see wheter unrolling
// is faster or slower ..

// #pragma optionNV (unroll all)


// Includes

// FILE: 'Shader/Includes/Configuration.include' 
// This is the main configuration file, included by almost all shaders

// Max values for the light culling
// If you change anything regarding this in LightManager,
// change it here, too
#define MAX_VISIBLE_LIGHTS 25
#define MAX_LIGHTS_PER_PATCH 63

// Same as in LightManager.py
#define MAX_POINT_LIGHTS 16
#define MAX_SHADOW_POINT_LIGHTS 16

// Max shadow maps. Has to be the same as in LightManager.py
#define SHADOW_MAX_TOTAL_MAPS 24


// Wheter to clear the lighting buffer each frame to be
// able to see changes in lighting - only recommended for debugging
#define LIGHTING_CLEAR_BUFFER_EACH_FRAME


// GLSL really needs this as a builtin!
#define saturate(v) clamp(v, 0, 1)

// Needed for light culling
const float sqrt_of_2 = 1.4142135623;

// Load Auto-Config

// FILE: 'Shader/Includes/AutoGeneratedConfig.include' 
// Autogenerated by RenderPipeline.py
// Do not edit! Your changes will be lost.

#define SMAA_PRESET_ULTRA
#define LIGHTING_COMPUTE_PATCH_SIZE_X 32
#define LIGHTING_COMPUTE_PATCH_SIZE_Y 32
#define LIGHTING_MIN_MAX_DEPTH_ACCURACY 1
#define LIGHTING_ANY_BOUND_CHECK 1
#define LIGHTING_ACCURATE_BOUND_CHECK 1
#define USE_SHADOWS 1
#define SHADOW_MAP_ATLAS_SIZE 8192
#define SHADOW_MAX_UPDATES_PER_FRAME 4
#define SHAODOW_GEOMETRY_MAX_VERTICES 12
#define SHADOWS_NUM_SAMPLES 16
#define USE_HARDWARE_PCF 1
#define WINDOW_WIDTH 1600
#define WINDOW_HEIGHT 900
#define USE_MOTION_BLUR 1
#define MOTION_BLUR_SAMPLES 12
#define DSSDO_ENABLED 1
#define DSSDO_NUM_SAMPLES 8
#define DSSDO_RADIUS 1.0
#define DSSDO_MAX_DISTANCE 4.0
#define DSSDO_MAX_ANGLE 0.4
#define DSSDO_STRENGTH 1.3
#define DEBUGGER_ACTIVE 1
#define DEBUG_RM_DEFAULT 1

// Performance functions

// FILE: 'Shader/Includes/Performance.include' 
vec4 FAST_mul(mat4 m, vec3 v) {
    return m * vec4(v, 1);
    // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] + m[3] ));
}

vec4 FAST_mul_no_w(mat4 m, vec3 v) {
    return m * vec4(v, 0);
     // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] ));
}


vec4 FAST_normalize_prefactor(vec4 v) {
    // todo
    return normalize(v);
}

// Wheter to use post-processing blur, this affects DSSDO
#define USE_OCCLUSION_BLUR



#define M_PI 3.14159265



// #pragma optionNV (unroll all)


#define USE_BINDLESS_TEXTURES 0

#if USE_BINDLESS_TEXTURES
    #define BINDLESS layout(bindless_sampler)
#else
    #define BINDLESS
#endif

// FILE: 'Shader/Includes/Light.include' 
struct Light {
    vec3 position;
    vec3 color;
    vec3 direction;
    int posterIndex;
    int lightType;
    float radius;
    int sourceIndexes[6];
};

// FILE: 'Shader/Includes/Packing.include' 
// http://aras-p.info/texts/CompactNormalStorage.html
// Packs a normal to a vec2
vec2 encodeNormal(vec3 n)
{
    // Prevents artifacts at surfaces which point to the bottom??
    n *= 0.999;

    float p = inversesqrt(n.z*8+8);
    return vec2(n.xy*p + 0.5);
}

// Unpacks a normal from a vec2
vec3 decodeNormal(vec2 encoded)
{
    vec2 fenc = encoded * 4.0 - 2.0;
    float f = dot(fenc,fenc);
    float g = sqrt(1.0 - f/4.0);
    vec3 n;
    n.xy = fenc * g;
    n.z = 1.0 - f/2.0;
    return n;
}

// // Packs float to 2 floats for more precision

// vec2 packDepth(float d) {
//     // return vec2(d, d);
//     return vec2(floor(d*1024), fract(d*1024));
// }

// // Unpacks 2 floats to one high precision float
// float unpackDepth(vec2 d) {
//     // return d.x;
//     return (d.x + d.y) / 1024.0;
// }

const float colorPackingFactor = 1.0 - (1.0 / 255.0);

vec2 packColor(vec3 color) {
    return vec2(color.x,
            saturate(color.y) * colorPackingFactor +
            ceil(color.z * 255.0)
        );
}

vec3 unpackColor(vec2 pack) {
    return vec3(pack.x, fract(pack.y), floor(pack.y) / 256.0 );
}

// FILE: 'Shader/Includes/PositionReconstruction.include' 
uniform mat4 trans_clip_of_mainCam_to_mainRender;


const float ndcNear = 0.1;
const float ndcFar = 30000.0;
const float ndcA = ndcNear + ndcFar;
const float ndcB = ndcNear - ndcFar;
const float ndcC = 2.0 * ndcNear * ndcFar;
const float ndcD = ndcFar - ndcNear;

float getZFromNdc(vec3 ndcPos) {
  float d = ndcPos.z * ndcB;
  return (ndcC / (ndcA+d));
}


// z has to be in range 0..MAIN_CAMERA_FAR
float getZFromLinearZ(float z) {

    //((((1.0 / (z / ndcC)) - ndcA) / ndcB) / 2.0) + 0.5;

  z /= ndcC;
  z = 1.0 / z;
  z -= ndcA;
  z /= ndcB;
  z /= 2.0;
  z += 0.5;
  return z;
}

float getLinearZFromZ(float z) {
    float z_n = z * 2.0 - 1.0;
    float z_e = ndcC / (ndcA - z_n * ndcD);
    return z_e;
}

float getCustomLinearZFromZ(float z, float near, float far) {
    float z_n = z * 2.0 - 1.0;
    float z_e = 2.0 * near * far / (far + near - z_n * (far - near));
    return z_e;
}

float normalizeZ(float z, float near, float far) {
  return getCustomLinearZFromZ(z, near, far) / far;
}




vec3 calculateSurfacePos(float z, vec2 tcoord) {

  vec3 ndcPos = vec3(tcoord.xy, z)*2.0 - 1.0;
  // ndcPos.xyz -= 0.5;
  // ndcPos.xyz *= 2.0;

  vec4 clipPos = vec4(0);
  clipPos.w = getZFromNdc(ndcPos);

  clipPos.xyz = ndcPos * clipPos.w;

  vec3 surfacePosition = (trans_clip_of_mainCam_to_mainRender * clipPos).xyz;
  return surfacePosition;
}

// FILE: 'Shader/Includes/Frustum.include' 
struct Frustum {
    vec4 left;
    vec4 right;
    vec4 top;
    vec4 bottom;
    float near;
    float far;

    mat4 viewMat;
    mat4 mvpMat;
};

// FILE: 'Shader/Includes/LightCulling.include' 
// FILE: 'Shader/Includes/IntersectionTests.include' 
/*
float intersectionHelperSquare(float v) {
    return v * v;
}

bool cubeIntersectsSphere(vec3 aabbMin, vec3 aabbMax, vec3 sphereMid, float sphereRadius)
{
    float dist_squared = sphereRadius * sphereRadius;
    if (sphereMid.x < aabbMin.x) dist_squared -= intersectionHelperSquare(sphereMid.x - aabbMin.x);
    else if (sphereMid.x > aabbMax.x) dist_squared -= intersectionHelperSquare(sphereMid.x - aabbMax.x);
    if (sphereMid.y < aabbMin.y) dist_squared -= intersectionHelperSquare(sphereMid.y - aabbMin.y);
    else if (sphereMid.y > aabbMax.y) dist_squared -= intersectionHelperSquare(sphereMid.y - aabbMax.y);
    if (sphereMid.z < aabbMin.z) dist_squared -= intersectionHelperSquare(sphereMid.z - aabbMin.z);
    else if (sphereMid.z > aabbMax.z) dist_squared -= intersectionHelperSquare(sphereMid.z - aabbMax.z);
    return dist_squared > 0;
}


bool rayIntersectsSphere(vec3 rayStart, vec3 rayEnd, vec3 sphereMid, float sphereRadius)
{
    vec3 d = rayEnd - rayStart;
    float a = dot(d, d);
    float b = 2.0 * dot(d, rayStart - sphereMid);
    float c = dot(sphereMid, sphereMid) + dot(rayStart, rayStart) - 2.0 * dot(sphereMid, rayStart) - sphereRadius*sphereRadius;
    float test = b*b - 4.0*a*c;
    return test >= 0.0;
}
*/

bool sphereInFrustum(Frustum frustum, vec4 pos, float radius) {
    bvec4 result;
    result.x = -radius <= dot(frustum.left, pos);
    result.y = -radius <= dot(frustum.right, pos);
    result.z = -radius <= dot(frustum.top, pos);
    result.w = -radius <= dot(frustum.bottom, pos);
    return all(result);
}


bool isPointLightInFrustum(Light light, Frustum frustum) {

    #ifndef LIGHTING_ANY_BOUND_CHECK
        return true;
    #else

    vec4 projectedPos = frustum.viewMat * vec4(light.position, 1);

    // Top/Left/Bottom/Right frustum check
    if (sphereInFrustum(frustum, projectedPos, light.radius)) {

        #ifndef LIGHTING_ACCURATE_BOUND_CHECK
            return true;
        #else

        // Project to screen to get actual depth value
        vec4 projectedScreen = frustum.mvpMat * vec4(light.position, 1);
        projectedScreen.xyz = (projectedScreen.xyz / projectedScreen.w);

        // Fetch linear z
        // We have to use linear space because the radius of the light
        // is also linear, and otherwise we couldn't compare the values
        // properly.
        float linearProjZ = getLinearZFromZ(projectedScreen.z) * 2.0 - 1.0;

        // Check if the light is < max-depth
        if ( linearProjZ - sqrt_of_2*light.radius < frustum.far ) {

            // Check if the light is > min-depth
            // Maybe this check can be ommitted as it won't happen very often
            if (linearProjZ + sqrt_of_2*light.radius > frustum.near) {
                return true;
            }
        }

        #endif

    }
    return false;

    #endif

}

in vec2 texcoord;
in vec2 pixcoord;

BINDLESS uniform sampler2D depth;

layout (r32i) uniform iimage2D destination;

// Per-Light data and count
uniform Light lights[MAX_VISIBLE_LIGHTS];

uniform int countPointLight;
uniform int arrayPointLight[MAX_POINT_LIGHTS];

uniform int arrayPointLightShadow[MAX_POINT_LIGHTS];
uniform int countPointLightShadow;

uniform vec4 bufferSize;


// Matrices used for the culling
// I defined constants because the names are quite long ..
// But I think that will be fixed by rdb's new input system soon
#define PROJ_MAT trans_apiview_of_mainCam_to_apiclip_of_mainCam
#define VIEW_MAT trans_mainRender_to_apiview_of_mainCam
#define MODEL_VIEW_PROJ_MAT trans_mainRender_to_apiclip_of_mainCam
uniform mat4 PROJ_MAT;
uniform mat4 VIEW_MAT;
uniform mat4 MODEL_VIEW_PROJ_MAT;

const ivec2 patchSize = ivec2(LIGHTING_COMPUTE_PATCH_SIZE_X, LIGHTING_COMPUTE_PATCH_SIZE_Y);


void main() {

    // Common variables
    ivec2 screenSize = textureSize(depth, 0);

    // How many patches there are (e.g. 50x30 for a resolution of 1600x960)
    ivec2 precomputeSize = ivec2(bufferSize.zw);

    // Our patch ID (0 .. precomputeSize)
    ivec2 precomputeCoord = ivec2(texcoord * precomputeSize);

    // Position on screen
    ivec2 virtualScreenSize = (precomputeSize) * patchSize;

    ivec2 screenCoord = ivec2( (pixcoord-0.5) * patchSize);

    // Where to store the data
    ivec2 storageCoord = precomputeCoord * 8;

    // Compute Min and Max depth
    float minDepth = 1.0;
    float maxDepth = 0.0;

    ivec2 clampMax = ivec2(screenSize) - 1;
    ivec2 newCoord;
    float storedDepth;

    // vec2 texelSize = 1.0 / screenSize;
    // vec2 screenCoordTexel = vec2(newCoord) / screenSize;
    // vec2 newCoordTexel;

    // Compute min / max depth per tile
    for (int x = 0; x < LIGHTING_COMPUTE_PATCH_SIZE_X; x+=LIGHTING_MIN_MAX_DEPTH_ACCURACY*2) {
        for (int y = 0; y < LIGHTING_COMPUTE_PATCH_SIZE_X; y+=LIGHTING_MIN_MAX_DEPTH_ACCURACY) {
            newCoord = screenCoord + ivec2(x + y%2,y);
            // newCoordTexel = vec2(x,y) * texelSize + screenCoordTexel;

            // Check if out of screen bounds.
            // This is necessary if the precompute size is bigger than the
            // screen size. Otherwise the outer tiles will have a maxDepth of
            // 0 because they sample values which are outside of the colortex.
            newCoord = min(newCoord, clampMax);
            // newCoordTexel = min(newCoordTexel, vec2(1.0) );

            storedDepth = texelFetch(depth, newCoord, 0).r;

            // storedDepth = texture(depth, newCoordTexel);

            minDepth = min(minDepth, storedDepth);
            maxDepth = max(maxDepth, storedDepth);

        }
    }

    // Also store linear depth to be able to compare
    // light depth and min/max depth easily
    float minDepthLinear = getLinearZFromZ(minDepth);
    float maxDepthLinear = getLinearZFromZ(maxDepth);

    // Init counters
    int processedPointLights = 0;
    int processesShadowPointLights = 0;

    if (false && minDepthLinear > 9000.0) {
        // Only skybox. We can stop here.
        processedPointLights = 0;
        processesShadowPointLights = 0;

    } else {

        // Compute tile bounds, needed for frustum
        vec2 tileScale = vec2(virtualScreenSize) * 0.5f / vec2(patchSize);
        vec2 tileBias = tileScale - vec2(precomputeCoord);

        // Store matrices in local variables as their name
        // can get very long
        mat4 projMat = PROJ_MAT;
        mat4 viewMat = VIEW_MAT;
        mat4 mvpMat = MODEL_VIEW_PROJ_MAT;

        // Build frustum
        // Based on http://gamedev.stackexchange.com/questions/67431/deferred-tiled-shading-tile-frusta-calculation-in-opengl
        // Which is again based on DICE's presentation
        vec4 frustumRL = vec4(-projMat[0][0] * tileScale.x, 0.0f, tileBias.x, 0.0f);
        vec4 frustumTL = vec4(0.0f, -projMat[1][1] * tileScale.y, tileBias.y, 0.0f);

        // The doc said frustumOffset = vec4(0,0,1,0) but panda uses
        // apparently an inverted coordinate system
        const vec4 frustumOffset = vec4(0.0f, 0.0f, -1.0f, 0.0f);

        // Calculate frustum planes
        Frustum frustum;
        frustum.left   = normalize(frustumOffset - frustumRL);
        frustum.right  = normalize(frustumOffset + frustumRL);
        frustum.top    = normalize(frustumOffset - frustumTL);
        frustum.bottom = normalize(frustumOffset + frustumTL);
        frustum.near   = minDepthLinear;
        frustum.far    = maxDepthLinear;

        frustum.viewMat = viewMat;
        frustum.mvpMat  = mvpMat;

        // Reset data buffer (not neccessary, only for debugging)
        #ifdef LIGHTING_CLEAR_BUFFER_EACH_FRAME
            for (int x = 0; x < 8; x++) {
                for (int y = 0; y < 8; y++) {
                    imageStore(destination, storageCoord+ivec2(x, y), ivec4(0) );
                }
            }
        #endif

        // Buffer layout:
        // First 8 pixels store count
        // Second/Third line stores point lights
        // Fourth/Fifth line stores shadow point lights
        // Sixt, seventh, eight are free (yet)


        // Process Point Lights
        ivec2 baseOffset = storageCoord + ivec2(0,1);
        ivec2 currentOffset = ivec2(0);

        for (int i = 0; i < countPointLight; i++) {
            int index = arrayPointLight[i];
            Light light = lights[index];
            if (isPointLightInFrustum(light, frustum)) {
                currentOffset = ivec2(processedPointLights % 8, processedPointLights / 8);
                imageStore(destination, baseOffset + currentOffset, ivec4(index));
                processedPointLights += 1;
            }
        }

        // Process shadowed point lights
        baseOffset = storageCoord + ivec2(0,3);
        currentOffset = ivec2(0);

        for (int i = 0; i < countPointLightShadow; i++) {
            int index = arrayPointLightShadow[i];
            Light light = lights[index];
            if (isPointLightInFrustum(light, frustum)) {
                currentOffset = ivec2(processesShadowPointLights % 8, processesShadowPointLights / 8);
                imageStore(destination, baseOffset + currentOffset, ivec4(index));
                processesShadowPointLights += 1;
            }
        }

    }

    imageStore(destination, storageCoord + ivec2(0, 0), ivec4(processedPointLights));
    imageStore(destination, storageCoord + ivec2(1, 0), ivec4(processesShadowPointLights));

    // float lightsVisibleFloat = float(processedPointLights + processesShadowPointLights) / float(2.0);
    // vec3 lightCountIndicator = vec3(lightsVisibleFloat, 1.0 - lightsVisibleFloat , 0);

}
