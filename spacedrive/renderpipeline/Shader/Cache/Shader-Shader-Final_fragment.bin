#version 400


#extension GL_EXT_shader_image_load_store : enable


// FILE: 'Shader/Includes/Configuration.include' 
// This is the main configuration file, included by almost all shaders

// Max values for the light culling
// If you change anything regarding this in LightManager,
// change it here, too
#define MAX_VISIBLE_LIGHTS 25
#define MAX_LIGHTS_PER_PATCH 63

// Same as in LightManager.py
#define MAX_POINT_LIGHTS 16
#define MAX_SHADOW_POINT_LIGHTS 16

// Max shadow maps. Has to be the same as in LightManager.py
#define SHADOW_MAX_TOTAL_MAPS 24


// Wheter to clear the lighting buffer each frame to be
// able to see changes in lighting - only recommended for debugging
#define LIGHTING_CLEAR_BUFFER_EACH_FRAME


// GLSL really needs this as a builtin!
#define saturate(v) clamp(v, 0, 1)

// Needed for light culling
const float sqrt_of_2 = 1.4142135623;

// Load Auto-Config

// FILE: 'Shader/Includes/AutoGeneratedConfig.include' 
// Autogenerated by RenderPipeline.py
// Do not edit! Your changes will be lost.

#define SMAA_PRESET_ULTRA
#define LIGHTING_COMPUTE_PATCH_SIZE_X 32
#define LIGHTING_COMPUTE_PATCH_SIZE_Y 32
#define LIGHTING_MIN_MAX_DEPTH_ACCURACY 1
#define LIGHTING_ANY_BOUND_CHECK 1
#define LIGHTING_ACCURATE_BOUND_CHECK 1
#define USE_SHADOWS 1
#define SHADOW_MAP_ATLAS_SIZE 8192
#define SHADOW_MAX_UPDATES_PER_FRAME 4
#define SHAODOW_GEOMETRY_MAX_VERTICES 12
#define SHADOWS_NUM_SAMPLES 16
#define USE_HARDWARE_PCF 1
#define WINDOW_WIDTH 1600
#define WINDOW_HEIGHT 900
#define USE_MOTION_BLUR 1
#define MOTION_BLUR_SAMPLES 12
#define DSSDO_ENABLED 1
#define DSSDO_NUM_SAMPLES 8
#define DSSDO_RADIUS 1.0
#define DSSDO_MAX_DISTANCE 4.0
#define DSSDO_MAX_ANGLE 0.4
#define DSSDO_STRENGTH 1.3
#define DEBUGGER_ACTIVE 1
#define DEBUG_RM_DEFAULT 1

// Performance functions

// FILE: 'Shader/Includes/Performance.include' 
vec4 FAST_mul(mat4 m, vec3 v) {
    return m * vec4(v, 1);
    // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] + m[3] ));
}

vec4 FAST_mul_no_w(mat4 m, vec3 v) {
    return m * vec4(v, 0);
     // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] ));
}


vec4 FAST_normalize_prefactor(vec4 v) {
    // todo
    return normalize(v);
}

// Wheter to use post-processing blur, this affects DSSDO
#define USE_OCCLUSION_BLUR



#define M_PI 3.14159265



// #pragma optionNV (unroll all)


#define USE_BINDLESS_TEXTURES 0

#if USE_BINDLESS_TEXTURES
    #define BINDLESS layout(bindless_sampler)
#else
    #define BINDLESS
#endif

// FILE: 'Shader/Includes/PositionReconstruction.include' 
uniform mat4 trans_clip_of_mainCam_to_mainRender;


const float ndcNear = 0.1;
const float ndcFar = 30000.0;
const float ndcA = ndcNear + ndcFar;
const float ndcB = ndcNear - ndcFar;
const float ndcC = 2.0 * ndcNear * ndcFar;
const float ndcD = ndcFar - ndcNear;

float getZFromNdc(vec3 ndcPos) {
  float d = ndcPos.z * ndcB;
  return (ndcC / (ndcA+d));
}


// z has to be in range 0..MAIN_CAMERA_FAR
float getZFromLinearZ(float z) {

    //((((1.0 / (z / ndcC)) - ndcA) / ndcB) / 2.0) + 0.5;

  z /= ndcC;
  z = 1.0 / z;
  z -= ndcA;
  z /= ndcB;
  z /= 2.0;
  z += 0.5;
  return z;
}

float getLinearZFromZ(float z) {
    float z_n = z * 2.0 - 1.0;
    float z_e = ndcC / (ndcA - z_n * ndcD);
    return z_e;
}

float getCustomLinearZFromZ(float z, float near, float far) {
    float z_n = z * 2.0 - 1.0;
    float z_e = 2.0 * near * far / (far + near - z_n * (far - near));
    return z_e;
}

float normalizeZ(float z, float near, float far) {
  return getCustomLinearZFromZ(z, near, far) / far;
}




vec3 calculateSurfacePos(float z, vec2 tcoord) {

  vec3 ndcPos = vec3(tcoord.xy, z)*2.0 - 1.0;
  // ndcPos.xyz -= 0.5;
  // ndcPos.xyz *= 2.0;

  vec4 clipPos = vec4(0);
  clipPos.w = getZFromNdc(ndcPos);

  clipPos.xyz = ndcPos * clipPos.w;

  vec3 surfacePosition = (trans_clip_of_mainCam_to_mainRender * clipPos).xyz;
  return surfacePosition;
}

// FILE: 'Shader/Includes/ColorCorrection.include' 
// Instagram effect, yay! :D
vec3 convertColorSpace(vec3 x1) {
    vec3 x2 = x1 * x1;
    vec3 x3 = x2 * x1;
    vec3 x4 = x3 * x1;
    vec3 x5 = x4 * x1;
    vec3 result;

    result.r = 0.078619672271 +
        (0.95704630331)*x1.r +
        (1.67552722496)*x2.r +
        (-4.43954259306)*x3.r +
        (4.05428794615)*x4.r +
        (-1.37605047802)*x5.r;
    result.g = -0.00167123955185 +
        (0.671997329728)*x1.g +
        (3.09694633717)*x2.g +
        (-5.30948014199)*x3.g +
        (2.8547560319)*x4.g +
        (-0.312785174623)*x5.g;
    result.b = 0.0744127064858 +
        (0.928306646392)*x1.b +
        (0.940123058005)*x2.b +
        (-2.62632861258)*x3.b +
        (2.4523831772)*x4.b +
        (-0.858903293136)*x5.b;

    return saturate(result);
}

// FILE: 'Shader/Includes/TemporalReprojection.include' 
uniform sampler2D newFrame;
uniform sampler2D currentPosition;
layout(rgba16f) uniform image2D lastFrame;
layout(rgba16f) uniform image2D lastPosition;

void storeTemporalReprojection(ivec2 coord) {
    vec4 newFrameVal = texelFetch(newFrame, coord, 0);
    vec4 newPosVal = texelFetch(currentPosition, coord, 0);
    imageStore(lastFrame, coord, newFrameVal);
    imageStore(lastPosition, coord, newPosVal);
}


in vec2 texcoord;

uniform sampler2D velocityTex;
uniform sampler2D colorTex;
// uniform sampler2D depthTex;

uniform float motionBlurFactor;

out vec3 result;

void main() {


    // Fetch screen size, so we don't have to pass it as a shader input
    ivec2 screenSize = textureSize(colorTex, 0);

    // Screen coordinate (as int vec)
    ivec2 screenCoord = ivec2(texcoord * screenSize);

    // Store last frame
    storeTemporalReprojection(screenCoord);

    #if 1

    vec2 pixelVelocity = textureLod(velocityTex, texcoord, 0).xy
            / 255.0 * motionBlurFactor * 1.2;
    // vec2 pixelVelocity = vec2(0.0);


    // vec2 redAbVector = vec2(1.0,0) / screenSize;
    // vec2 greenAbVector = vec2(0);
    // vec2 blueAbVector = vec2(-1.0,0) / screenSize;

    // result.r = textureLod(colorTex, texcoord + redAbVector, 0).r;
    // result.g = textureLod(colorTex, texcoord + greenAbVector, 0).g;
    // result.b = textureLod(colorTex, texcoord + blueAbVector, 0).b;



    #ifdef USE_MOTION_BLUR


        float velStrength = length(pixelVelocity);

        // Motion blur
        vec3 motionResult = vec3(0);

        for (int i = 1; i < MOTION_BLUR_SAMPLES; i++) {
            vec2 offset = pixelVelocity * (float(i) / float(MOTION_BLUR_SAMPLES - 1) - 0.5);
            motionResult += textureLod(colorTex, texcoord + offset, 0).rgb;
        }
        motionResult /= MOTION_BLUR_SAMPLES-1;

        // result = mix(result, motionResult, saturate(velStrength*2.0) );
        result = mix(result, motionResult, 1.0 );


        #ifdef DEBUG_DISABLE_MOTIONBLUR
            result = textureLod(colorTex, texcoord, 0).rgb;
        #endif

    #else
        result = textureLod(colorTex, texcoord, 0).rgb;
    #endif

    // result = textureLod(colorTex, texcoord, 0).rgb;

    #ifndef DEBUG_DISABLE_COLOR_CORRECTION
        vec3 colorCorrected = convertColorSpace(result);
        result = mix( colorCorrected , result, 0.5);
    #endif


    float vignett = smoothstep(0, 1,
        (length( (texcoord - vec2(0.5, 0.5)) * vec2(1.2, 1.0)  ) - 0.32) ) * 1.6;
    result *= 1.0 - vignett;

    // result.rgb = newFrameVal.rgb;


    #else
        result = texture(colorTex, texcoord).rgb;
        // result = vec3(1,0.5, 0.2);

    #endif

    // result = textureLod(colorTex, texcoord, 0).rgb;
    // vec3 colorCorrected = convertColorSpace(result.xyz);
    // result.xyz = mix( colorCorrected , result.xyz, 0.6);

}
