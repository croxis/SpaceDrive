#version 410
#pragma optionNV (unroll all)



// FILE: 'Shader/Includes/Configuration.include' 
// This is the main configuration file, included by almost all shaders

// Max values for the light culling
// If you change anything regarding this in LightManager,
// change it here, too
#define MAX_VISIBLE_LIGHTS 25
#define MAX_LIGHTS_PER_PATCH 63

// Same as in LightManager.py
#define MAX_POINT_LIGHTS 16
#define MAX_SHADOW_POINT_LIGHTS 16

// Max shadow maps. Has to be the same as in LightManager.py
#define SHADOW_MAX_TOTAL_MAPS 24


// Wheter to clear the lighting buffer each frame to be
// able to see changes in lighting - only recommended for debugging
#define LIGHTING_CLEAR_BUFFER_EACH_FRAME


// GLSL really needs this as a builtin!
#define saturate(v) clamp(v, 0, 1)

// Needed for light culling
const float sqrt_of_2 = 1.4142135623;

// Load Auto-Config

// FILE: 'Shader/Includes/AutoGeneratedConfig.include' 
// Autogenerated by RenderPipeline.py
// Do not edit! Your changes will be lost.

#define SMAA_PRESET_ULTRA
#define LIGHTING_COMPUTE_PATCH_SIZE_X 32
#define LIGHTING_COMPUTE_PATCH_SIZE_Y 32
#define LIGHTING_MIN_MAX_DEPTH_ACCURACY 1
#define LIGHTING_ANY_BOUND_CHECK 1
#define LIGHTING_ACCURATE_BOUND_CHECK 1
#define USE_SHADOWS 1
#define SHADOW_MAP_ATLAS_SIZE 8192
#define SHADOW_MAX_UPDATES_PER_FRAME 4
#define SHAODOW_GEOMETRY_MAX_VERTICES 12
#define SHADOWS_NUM_SAMPLES 16
#define USE_HARDWARE_PCF 1
#define WINDOW_WIDTH 1600
#define WINDOW_HEIGHT 900
#define USE_MOTION_BLUR 1
#define MOTION_BLUR_SAMPLES 12
#define DSSDO_ENABLED 1
#define DSSDO_NUM_SAMPLES 8
#define DSSDO_RADIUS 1.0
#define DSSDO_MAX_DISTANCE 4.0
#define DSSDO_MAX_ANGLE 0.4
#define DSSDO_STRENGTH 1.3
#define DEBUGGER_ACTIVE 1
#define DEBUG_RM_DEFAULT 1

// Performance functions

// FILE: 'Shader/Includes/Performance.include' 
vec4 FAST_mul(mat4 m, vec3 v) {
    return m * vec4(v, 1);
    // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] + m[3] ));
}

vec4 FAST_mul_no_w(mat4 m, vec3 v) {
    return m * vec4(v, 0);
     // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] ));
}


vec4 FAST_normalize_prefactor(vec4 v) {
    // todo
    return normalize(v);
}

// Wheter to use post-processing blur, this affects DSSDO
#define USE_OCCLUSION_BLUR



#define M_PI 3.14159265



// #pragma optionNV (unroll all)


#define USE_BINDLESS_TEXTURES 0

#if USE_BINDLESS_TEXTURES
    #define BINDLESS layout(bindless_sampler)
#else
    #define BINDLESS
#endif

// FILE: 'Shader/Includes/ShadowSource.include' 
struct ShadowSource {
    int resolution;
    vec2 atlasPos;
    mat4 mvp;
    float nearPlane;
    float farPlane;
};

// FILE: 'Shader/Includes/ParabolicTransform.include' 
vec4 transformParabol(vec4 transformed, float near, float far) {
    // return transformed;

    if (transformed.w < 0.0) return vec4(0,0,0,-1000);

    // float l = length(transformed.xyz);
    float l = length(transformed.xyz);
    // float l = transformed.z;
    // transformed = length(trans);

    transformed /= l;


    transformed.z += 1;
    transformed.xy /= transformed.z;

    transformed.z = (l - near) / (far - near);
    // transformed = normalize(transformed);
    transformed.w = 1;


    // float l = length(transformed.xyz);
    // transformed = transformed/l;
    // // transformed = normalize(transformed);

    // transformed.z = transformed.z + 1;
    // transformed.z = (l - near)/(far-near);
    // transformed.w = 1;
    return transformed;
}

uniform mat4 p3d_ModelViewProjectionMatrix;

layout(triangles) in;
layout(triangle_strip, max_vertices=SHAODOW_GEOMETRY_MAX_VERTICES) out;

uniform int numUpdates;
uniform ShadowSource updateSources[SHADOW_MAX_UPDATES_PER_FRAME];

void main() {
  for (int pass = 0; pass < numUpdates; pass ++) {
    ShadowSource currentSource = updateSources[pass];
    mat4 mvp = currentSource.mvp;

    gl_ViewportIndex = pass + 1;


    for(int i=0; i<3; i++)
    {
      gl_Position = mvp * gl_in[i].gl_Position;

      gl_Position = transformParabol(gl_Position, currentSource.nearPlane, currentSource.farPlane);
      if (gl_Position.w >= 0.0) {
        EmitVertex();
      }
      // gl_Position = transformParabol(gl_Position, currentSource.nearPlane, currentSource.farPlane);

    }
    EndPrimitive();
  }
}
