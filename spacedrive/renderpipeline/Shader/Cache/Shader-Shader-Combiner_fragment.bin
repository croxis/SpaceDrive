#version 420



// FILE: 'Shader/Includes/Configuration.include' 
// This is the main configuration file, included by almost all shaders

// Max values for the light culling
// If you change anything regarding this in LightManager,
// change it here, too
#define MAX_VISIBLE_LIGHTS 25
#define MAX_LIGHTS_PER_PATCH 63

// Same as in LightManager.py
#define MAX_POINT_LIGHTS 16
#define MAX_SHADOW_POINT_LIGHTS 16

// Max shadow maps. Has to be the same as in LightManager.py
#define SHADOW_MAX_TOTAL_MAPS 24


// Wheter to clear the lighting buffer each frame to be
// able to see changes in lighting - only recommended for debugging
#define LIGHTING_CLEAR_BUFFER_EACH_FRAME


// GLSL really needs this as a builtin!
#define saturate(v) clamp(v, 0, 1)

// Needed for light culling
const float sqrt_of_2 = 1.4142135623;

// Load Auto-Config

// FILE: 'Shader/Includes/AutoGeneratedConfig.include' 
// Autogenerated by RenderPipeline.py
// Do not edit! Your changes will be lost.

#define SMAA_PRESET_ULTRA
#define LIGHTING_COMPUTE_PATCH_SIZE_X 32
#define LIGHTING_COMPUTE_PATCH_SIZE_Y 32
#define LIGHTING_MIN_MAX_DEPTH_ACCURACY 1
#define LIGHTING_ANY_BOUND_CHECK 1
#define LIGHTING_ACCURATE_BOUND_CHECK 1
#define USE_SHADOWS 1
#define SHADOW_MAP_ATLAS_SIZE 8192
#define SHADOW_MAX_UPDATES_PER_FRAME 4
#define SHAODOW_GEOMETRY_MAX_VERTICES 12
#define SHADOWS_NUM_SAMPLES 16
#define USE_HARDWARE_PCF 1
#define WINDOW_WIDTH 1600
#define WINDOW_HEIGHT 900
#define USE_MOTION_BLUR 1
#define MOTION_BLUR_SAMPLES 12
#define DSSDO_ENABLED 1
#define DSSDO_NUM_SAMPLES 8
#define DSSDO_RADIUS 1.0
#define DSSDO_MAX_DISTANCE 4.0
#define DSSDO_MAX_ANGLE 0.4
#define DSSDO_STRENGTH 1.3
#define DEBUGGER_ACTIVE 1
#define DEBUG_RM_DEFAULT 1

// Performance functions

// FILE: 'Shader/Includes/Performance.include' 
vec4 FAST_mul(mat4 m, vec3 v) {
    return m * vec4(v, 1);
    // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] + m[3] ));
}

vec4 FAST_mul_no_w(mat4 m, vec3 v) {
    return m * vec4(v, 0);
     // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] ));
}


vec4 FAST_normalize_prefactor(vec4 v) {
    // todo
    return normalize(v);
}

// Wheter to use post-processing blur, this affects DSSDO
#define USE_OCCLUSION_BLUR



#define M_PI 3.14159265



// #pragma optionNV (unroll all)


#define USE_BINDLESS_TEXTURES 0

#if USE_BINDLESS_TEXTURES
    #define BINDLESS layout(bindless_sampler)
#else
    #define BINDLESS
#endif

// FILE: 'Shader/Includes/PositionReconstruction.include' 
uniform mat4 trans_clip_of_mainCam_to_mainRender;


const float ndcNear = 0.1;
const float ndcFar = 30000.0;
const float ndcA = ndcNear + ndcFar;
const float ndcB = ndcNear - ndcFar;
const float ndcC = 2.0 * ndcNear * ndcFar;
const float ndcD = ndcFar - ndcNear;

float getZFromNdc(vec3 ndcPos) {
  float d = ndcPos.z * ndcB;
  return (ndcC / (ndcA+d));
}


// z has to be in range 0..MAIN_CAMERA_FAR
float getZFromLinearZ(float z) {

    //((((1.0 / (z / ndcC)) - ndcA) / ndcB) / 2.0) + 0.5;

  z /= ndcC;
  z = 1.0 / z;
  z -= ndcA;
  z /= ndcB;
  z /= 2.0;
  z += 0.5;
  return z;
}

float getLinearZFromZ(float z) {
    float z_n = z * 2.0 - 1.0;
    float z_e = ndcC / (ndcA - z_n * ndcD);
    return z_e;
}

float getCustomLinearZFromZ(float z, float near, float far) {
    float z_n = z * 2.0 - 1.0;
    float z_e = 2.0 * near * far / (far + near - z_n * (far - near));
    return z_e;
}

float normalizeZ(float z, float near, float far) {
  return getCustomLinearZFromZ(z, near, far) / far;
}




vec3 calculateSurfacePos(float z, vec2 tcoord) {

  vec3 ndcPos = vec3(tcoord.xy, z)*2.0 - 1.0;
  // ndcPos.xyz -= 0.5;
  // ndcPos.xyz *= 2.0;

  vec4 clipPos = vec4(0);
  clipPos.w = getZFromNdc(ndcPos);

  clipPos.xyz = ndcPos * clipPos.w;

  vec3 surfacePosition = (trans_clip_of_mainCam_to_mainRender * clipPos).xyz;
  return surfacePosition;
}

in vec2 texcoord;

uniform sampler2D currentComputation;
// uniform sampler2D lastFrame;
// uniform sampler2D lastPosition;

layout(rgba16f) uniform image2D lastFrame;
layout(rgba16f) uniform image2D lastPosition;

uniform sampler2D positionBuffer;
uniform sampler2D velocityBuffer;
uniform sampler2D depthTex;

// layout(r16f) writeonly uniform image2D dofStorage;

uniform int temporalProjXOffs;

uniform mat4 lastMVP;
uniform mat4 currentMVP;
uniform vec3 cameraPosition;

out vec4 result;

void main() {

    // Fetch screen size, so we don't have to pass it as a shader input
    ivec2 screenSize = textureSize(positionBuffer, 0);

    // Screen coordinate (as int vec)
    ivec2 screenCoord = ivec2(texcoord * vec2(screenSize.x, screenSize.y));

    // Screen coordinate (half resolution only)
    ivec2 computationCoord = ivec2( screenCoord.x/2, screenCoord.y);


    // Compute dof factors
    // float bufferZ = texture(depthTex, texcoord).x;
    // float linearZ = getLinearZFromZ(bufferZ);
    // float dofFactor = (linearZ-4.0)/1.0;
    // dofFactor = 0.0;

    // Store dof in the storage
    // imageStore(dofStorage, screenCoord, vec4(saturate(dofFactor)) );

    vec3 position = texelFetch(positionBuffer, screenCoord, 0).rgb;

    // The last computed value (half resolution only, but up-to-date)
    vec4 lastComputedValue = texelFetch(currentComputation, computationCoord, 0);

    vec2 velocity = -texture(velocityBuffer, texcoord).rg / 255.0;


    vec4 lastProj = lastMVP * vec4(position, 1);
    vec2 lastTexcoord = (lastProj.xy / lastProj.w) * 0.5 + 0.5;
    vec2 newVelocity = (texcoord - lastTexcoord);
    // velocity = newVelocity;


    vec2 lastFrameTexcoord = texcoord - velocity;
    ivec2 lastFrameTexcoordInt = ivec2(lastFrameTexcoord * (screenSize)) ;
    ivec2 lastFrameTexcoordInt2 = ivec2((lastTexcoord * (screenSize))) ;


    // vec4 oldProjectedColor = texture(lastFrame, lastFrameTexcoord);
    vec4 oldProjectedColor = imageLoad(lastFrame, lastFrameTexcoordInt);

    // vec3 oldProjectedPos = texture(lastPosition, lastFrameTexcoord).rgb;
    vec3 oldProjectedPos = imageLoad(lastPosition, lastFrameTexcoordInt).rgb;


    float distanceToCamera = distance(cameraPosition, position);

    float reliability = 1.0 - saturate( (distance(oldProjectedPos, position) / distanceToCamera) * 300.0);

    // reliability = 0.0;

    // reliability = 1.0 - saturate(distance(lastFrameTexcoord, texcoord) * 30.0);
    // reliability = 0.0;

    // Fetch the up-to-date position from the buffer
    // vec4 position = vec4(texelFetch(positionBuffer, screenCoord, 0).rgb, 1);



    // if (distance(finalValue, vec3(1,0,0)) < 0.0001) {
    //     finalValue = lastComputedValue.rgb;
    //     // finalValue = lastFrameValue.rgb;
    // }

    // result.xyz = vec3(d);

    result = mix(lastComputedValue, oldProjectedColor, saturate(reliability));

    // result = vec4(reliability);

    // result = oldProjectedColor;
    // result = vec4(0,0,0,1);

    // If we have a newer value, use this
    // if ( (screenCoord.x) % 2 == 1-temporalProjXOffs) {
    if ( (screenCoord.x+screenCoord.y) % 2 == 1-temporalProjXOffs) {
        result = lastComputedValue;

        // result = vec4(1);

        // And also store this

        // result = result.x == ((screenCoord.x+screenCoord.y)%2) ? vec4(0,1,0,1) : vec4(1,0,0,1);
        // result = vec4(0,1,0,1);
    // imageStore(lastFrame, screenCoord, result);
    // imageStore(lastPosition, screenCoord, vec4(position, 0) );
    }
    // imageStore(lastFrame, screenCoord, result);


    // result = vec4( abs(oldProjectedPos.rgb - position.rgb) * 100.0, 1.0);
    // result = vec4( reliability > 0.9999 ? 1.0 : 0.0, 0,0 , 1);

    // result.xyz *= 4.0;
    // result = vec4(abs(lastFrameTexcoordInt - lastFrameTexcoordInt2), 0 ,1);
    // result = texture(currentComputation, texcoord);
    // result = vec4(dFdx(texcoord)*1000.0,0,1);


}
