#version 130


// FILE: 'Shader/Includes/Configuration.include' 
// This is the main configuration file, included by almost all shaders

// Max values for the light culling
// If you change anything regarding this in LightManager,
// change it here, too
#define MAX_VISIBLE_LIGHTS 25
#define MAX_LIGHTS_PER_PATCH 63

// Same as in LightManager.py
#define MAX_POINT_LIGHTS 16
#define MAX_SHADOW_POINT_LIGHTS 16

// Max shadow maps. Has to be the same as in LightManager.py
#define SHADOW_MAX_TOTAL_MAPS 24


// Wheter to clear the lighting buffer each frame to be
// able to see changes in lighting - only recommended for debugging
#define LIGHTING_CLEAR_BUFFER_EACH_FRAME


// GLSL really needs this as a builtin!
#define saturate(v) clamp(v, 0, 1)

// Needed for light culling
const float sqrt_of_2 = 1.4142135623;

// Load Auto-Config

// FILE: 'Shader/Includes/AutoGeneratedConfig.include' 
// Autogenerated by RenderPipeline.py
// Do not edit! Your changes will be lost.

#define SMAA_PRESET_ULTRA
#define LIGHTING_COMPUTE_PATCH_SIZE_X 32
#define LIGHTING_COMPUTE_PATCH_SIZE_Y 32
#define LIGHTING_MIN_MAX_DEPTH_ACCURACY 1
#define LIGHTING_ANY_BOUND_CHECK 1
#define LIGHTING_ACCURATE_BOUND_CHECK 1
#define USE_SHADOWS 1
#define SHADOW_MAP_ATLAS_SIZE 8192
#define SHADOW_MAX_UPDATES_PER_FRAME 4
#define SHAODOW_GEOMETRY_MAX_VERTICES 12
#define SHADOWS_NUM_SAMPLES 16
#define USE_HARDWARE_PCF 1
#define WINDOW_WIDTH 1600
#define WINDOW_HEIGHT 900
#define USE_MOTION_BLUR 1
#define MOTION_BLUR_SAMPLES 12
#define DSSDO_ENABLED 1
#define DSSDO_NUM_SAMPLES 8
#define DSSDO_RADIUS 1.0
#define DSSDO_MAX_DISTANCE 4.0
#define DSSDO_MAX_ANGLE 0.4
#define DSSDO_STRENGTH 1.3
#define DEBUGGER_ACTIVE 1
#define DEBUG_RM_DEFAULT 1

// Performance functions

// FILE: 'Shader/Includes/Performance.include' 
vec4 FAST_mul(mat4 m, vec3 v) {
    return m * vec4(v, 1);
    // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] + m[3] ));
}

vec4 FAST_mul_no_w(mat4 m, vec3 v) {
    return m * vec4(v, 0);
     // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] ));
}


vec4 FAST_normalize_prefactor(vec4 v) {
    // todo
    return normalize(v);
}

// Wheter to use post-processing blur, this affects DSSDO
#define USE_OCCLUSION_BLUR



#define M_PI 3.14159265



// #pragma optionNV (unroll all)


#define USE_BINDLESS_TEXTURES 0

#if USE_BINDLESS_TEXTURES
    #define BINDLESS layout(bindless_sampler)
#else
    #define BINDLESS
#endif

// FILE: 'Shader/Includes/PostProcessBlur.include' 
// FILE: 'Shader/Includes/Packing.include' 
// http://aras-p.info/texts/CompactNormalStorage.html
// Packs a normal to a vec2
vec2 encodeNormal(vec3 n)
{
    // Prevents artifacts at surfaces which point to the bottom??
    n *= 0.999;

    float p = inversesqrt(n.z*8+8);
    return vec2(n.xy*p + 0.5);
}

// Unpacks a normal from a vec2
vec3 decodeNormal(vec2 encoded)
{
    vec2 fenc = encoded * 4.0 - 2.0;
    float f = dot(fenc,fenc);
    float g = sqrt(1.0 - f/4.0);
    vec3 n;
    n.xy = fenc * g;
    n.z = 1.0 - f/2.0;
    return n;
}

// // Packs float to 2 floats for more precision

// vec2 packDepth(float d) {
//     // return vec2(d, d);
//     return vec2(floor(d*1024), fract(d*1024));
// }

// // Unpacks 2 floats to one high precision float
// float unpackDepth(vec2 d) {
//     // return d.x;
//     return (d.x + d.y) / 1024.0;
// }

const float colorPackingFactor = 1.0 - (1.0 / 255.0);

vec2 packColor(vec3 color) {
    return vec2(color.x,
            saturate(color.y) * colorPackingFactor +
            ceil(color.z * 255.0)
        );
}

vec3 unpackColor(vec2 pack) {
    return vec3(pack.x, fract(pack.y), floor(pack.y) / 256.0 );
}


const float normalsDiscardThreshold = 0.999;


#pragma optionNV (unroll all)


vec4 mipmapBasedBlur(vec2 texcoord, vec2 direction, sampler2D colorTex, sampler2D blurFactors) {

    // return texture(colorTex, texcoord);

    float blurFactor = texture(blurFactors, texcoord).r;

    if (blurFactor < 0.02) {
        return texture(colorTex, texcoord);
    } else {

        float blurWeights[9] = float[9]
        (
            0.013519569015984728,
            0.047662179108871855,
            0.11723004402070096,
            0.20116755999375591,
            0.240841295721373,
            0.20116755999375591,
            0.11723004402070096,
            0.047662179108871855,
            0.013519569015984728
        );

        float offsets[9] = float[9] (-4,-3,-2,-1,0,+1,+2,+3,+4);

        float mipmap = blurFactor * 2.2;
        mipmap = 0.0;
        vec2 texelSize = 7.2 / vec2(textureSize(colorTex, 0));
        texelSize *= direction * blurFactor;
        vec4 result = vec4(0);
        float weights;
        for (int i = 0; i < 9; i++) {
            vec2 offsetCoord = texcoord + offsets[i]*texelSize;
            float dofFactorOffset = textureLod(blurFactors, offsetCoord, 0).r;
            float weight = max(0.0, dofFactorOffset - blurFactor) *  blurWeights[i];
            weight = 1.0;

            result += textureLod(colorTex, offsetCoord , mipmap) *weight;
            weights += weight;
        }
        return result / weights;
    }
}


float edgePreservingAlphaBlur(vec2 texcoord, ivec2 screenCoord, ivec2 direction, sampler2D colorTex, sampler2D normalTex) {

    #ifndef USE_OCCLUSION_BLUR
        return texture(colorTex, texcoord).a;
    #endif

    #ifdef DSSDO_ENABLED

        float blurWeights[9] = float[9]
        (
            0.013519569015984728,
            0.047662179108871855,
            0.11723004402070096,
            0.20116755999375591,
            0.240841295721373,
            0.20116755999375591,
            0.11723004402070096,
            0.047662179108871855,
            0.013519569015984728
        );

        vec3 normals[9];
        float occlusion[9];

        // First, fetch all required values
        for (int i = 0; i < 9; i++) {
            normals[i] = decodeNormal(texelFetchOffset(normalTex, screenCoord, 0, ivec2(i-4)*direction).xy);
            occlusion[i] = texelFetchOffset(colorTex, screenCoord, 0, ivec2(i-4)*direction).a;
        }

        // pixel normal is the mid normal
        vec3 normal = normals[4];

        float alphaResult = 0.0;
        float alphaWeights = 0.0;

        // Check for edges, as we are performing an edge preserving blur
        for (int i = 0; i < 9; i++) {
            float weight = blurWeights[i];
            float normalInfluenceFactor = step(normalsDiscardThreshold, dot(normals[i], normal));
            alphaResult += occlusion[i]*weight*normalInfluenceFactor;
            alphaWeights += weight*normalInfluenceFactor;
        }

        return alphaResult / alphaWeights;


    #else
        return texelFetch(colorTex, screenCoord, 0).a;
    #endif
}

uniform sampler2D colorTex;
uniform sampler2D normalTex;

in vec2 texcoord;

out vec4 result;

void main() {
    ivec2 screenCoord = ivec2(texcoord * textureSize(colorTex, 0) );
    float alpha = edgePreservingAlphaBlur(texcoord, screenCoord, ivec2(0, 1), colorTex, normalTex);
    result = vec4(texture(colorTex, texcoord).rgb, alpha);

    // result = vec4(texture(colorTex, texcoord).a);
    // result = vec4(0,1,0,1);
}
