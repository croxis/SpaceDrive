


define WATER_DISPLACE vec3(8.5, 8.5, 6.5) * 0.4
define WATER_COORD_FACTOR 20.0
define WATER_LOWRES_FACTOR 0.23
define WATER_DISPLACE_DIST 800.0


pass Default:

    vertex:
        template default
        include "Includes/PositionReconstruction.include"
        uniform vec3 cameraPosition;
        uniform sampler2D waterHeightfield;
        uniform float waterHeight;

        insert @WS_POSITION:
            vec2 coord = vec2( (p3d_Vertex.xz * 1.2)  * 0.5 + 0.5);

            // Compute ray start and direction
            vec3 rayStart = cameraPosition;
            vec3 rayDir = normalize(rayStart - calculateSurfacePos(1.0, coord));

            // Intersect the ray with the water
            float dist = (-rayStart.z+waterHeight) / rayDir.z;
            vec3 intersectedPos = vec3(0);
            float maxWaterDist = 3000.0;

            // If plane is hit
            if (dist < 0.0) {
                intersectedPos = rayStart + rayDir * dist;
            } else {
                intersectedPos = vec3(rayStart.xy + rayDir.xy * -maxWaterDist, 0.0);
            }  

            vOutput.positionWorld = vec3(intersectedPos);
            vOutput.texcoord = vec2(vOutput.positionWorld.xy / WATER_COORD_FACTOR);

            // Fade displacement at borders
            float fade = 1.0;
            float fadeArea = 0.2;

            fade *= saturate(coord.x / fadeArea);
            fade *= saturate( (1.0 - coord.y) / fadeArea);

            fade *= saturate(coord.y / fadeArea);
            fade *= saturate( (1.0 - coord.y) / fadeArea);

            vec3 displace = texture(waterHeightfield, vOutput.texcoord).xyz + texture(waterHeightfield, vOutput.texcoord * WATER_LOWRES_FACTOR).xyz * 2.0 - 1.0;
            float displaceFactor = 1.0 - saturate(distance(cameraPosition, intersectedPos) / WATER_DISPLACE_DIST);

            vOutput.positionWorld += displace * WATER_DISPLACE * fade * displaceFactor;

        insert @VERTEX_PROJECTION:
            vOutput.lastProjectedPos = lastMVP * vec4(vOutput.positionWorld.xyz, 1.0) * vec4(1,1,1,2);
            gl_Position = currentMVP * vec4(vOutput.positionWorld.xyz, 1);

    tesscontrol:
        template default

        insert @TESS_LEVEL:
            TessLevelInner = 1.0;
            TessLevelOuter = 1.0;

    tesseval:
        template default

    fragment:
        template default

        uniform sampler2D waterHeightfield;
        uniform sampler2D waterNormal;
        uniform sampler2D waterFoam;
        uniform vec3 cameraPosition;

        insert @MATERIAL:

            vec3 normalDetail = texture(waterNormal, vOutput.texcoord).xyz;
            vec3 normal = (normalDetail + texture(waterNormal, vOutput.texcoord * WATER_LOWRES_FACTOR).xyz) * 0.5;
            vec3 disp = (texture(waterHeightfield, vOutput.texcoord).xyz +  texture(waterHeightfield, vOutput.texcoord * WATER_LOWRES_FACTOR).xyz) * 0.5;
            vec3 foam = texture(waterFoam, vOutput.texcoord * 2.0).xyz;

            float displaceFactor = 1.0 - saturate(distance(vOutput.positionWorld, cameraPosition) / WATER_DISPLACE_DIST);
            normal = mix(vec3(0, 0, 1), normal, displaceFactor);
            normalDetail = mix(vec3(0, 0, 1), normalDetail, displaceFactor);


            float fold = saturate(pow(normalDetail.z, 3.0) * 2.0);

            normal = normalize(vec3(normal.x, normal.y, 16.0 / 512.0));


            vec3 groundCol = vec3(0.12, 0.39, 0.5) * 0.2;

            m.baseColor = groundCol;
            m.baseColor += saturate(pow(disp.z, 2.0)) * vec3(0.18, 0.5, 0.6) * 0.1;

            m.baseColor *= 2.0;

            // m.baseColor = vec3(0.1,0.2, 0.25) * 0.1;
            // m.baseColor = vec3(0.0, 0.1, 0.02) * 0.1;
            m.baseColor += fold * vec3(1.0,1.0,1.4) * displaceFactor;
            // m.baseColor += vec3(0.0, 0.1, 0.02) * pow(1.0-disp.z, 2.0) * 1.9;
            // m.baseColor += vec3(0.05,0.1,0.5) * (0.1 + pow(disp.z, 1.6)) * 12.9;
            // m.baseColor = vec3(fold);

            m.baseColor = pow(m.baseColor, vec3(2.0));


            m.normal = normal;
            m.metallic = 1.0;
            m.specular = 1.0;
            m.roughness = 0.074;


            #if defined(IS_TRANSPARENT)
            m.alpha = 0.995;
            #endif


pass Shadows:

    vertex:
        template default
        include "Includes/PositionReconstruction.include"
        uniform vec3 cameraPosition;
        uniform sampler2D waterHeightfield;
        uniform mat4 p3d_ViewProjectionMatrix;
        uniform mat4 p3d_ViewProjectionMatrixInverse;
        uniform mat4 trans_apiclip_to_world;
        uniform float waterHeight;
        

        insert @FUNCTIONS:

            vec3 reprojectCoord(vec2 coord, float depth) {
                vec4 proj = p3d_ViewProjectionMatrixInverse * vec4(coord, depth*2.0-1.0, 1.0);
                proj.xyz /= proj.w;
                return proj.xyz;
            }

        insert @WS_POSITION:

            vec2 coord = p3d_Vertex.xz * 1.2;

            // Compute ray start and direction
            vec3 rayStart = reprojectCoord(coord, 0.0);
            vec3 rayDir = normalize(rayStart - reprojectCoord(coord, 1.0));

            // Intersect the ray with the water
            float distance = (-rayStart.z+waterHeight) / rayDir.z;
            vec3 intersectedPos = vec3(0);
            float maxWaterDist = 3000.0;

            // If plane is hit
            if (distance < 0.0) {
                intersectedPos = rayStart + rayDir * distance;
            } else {
                intersectedPos = vec3(rayStart.xy + rayDir.xy * -maxWaterDist, 0.0);
            }  

            worldPos.xyz = vec3(intersectedPos);
            texcoord = vec2(worldPos.xy / WATER_COORD_FACTOR);

            // vec3 displace = texture(waterHeightfield, texcoord).xyz;
            // worldPos.xyz += displace * vec3(0.6, 0.6, 1.5) * 1.7;

        insert @VERTEX_PROJECTION:

            gl_Position = p3d_ViewProjectionMatrix * worldPos;   



    tesscontrol:
        template default

    tesseval:
        template default


    fragment:
        template default