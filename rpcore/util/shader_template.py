"""

RenderPipeline

Copyright (c) 2014-2016 tobspr <tobias.springer1@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 	 	    	 	
"""

from direct.stdpy.file import open

from rpcore.rp_object import RPObject

class ShaderTemplate(RPObject):

    """ This class manages the loading of shader templates, including the
    replacement of template parameters. """

    def __init__(self, template_file, template_name="template"):
        RPObject.__init__(self)
        self._file_source = template_file
        self._template_values = {}
        self._template_name = template_name

    def register_template_value(self, key, val):
        """ Registers a new template value. The value may either be a list of
        strings or just a single string """
        if not isinstance(val, (list, tuple)):
            val = [val]
        key = key.lower()

        if key in self._template_values:
            self._template_values[key] += val
        else:
            self._template_values[key] = val

    def create(self):
        """ Constructs a shader object from the template and returns the path
        to the compiled shader """

        with open(self._file_source, "r") as handle:
            shader_lines = handle.readlines()

        # Parse all shader lines
        parsed_lines = []

        # Add header
        parsed_lines.append("/* Compiled Shader Template ")
        parsed_lines.append(" * generated from: '" + self._file_source + "'")
        parsed_lines.append(" * template name: '" + self._template_name + "'")
        parsed_lines.append(" * lines starting with T are from the template")
        parsed_lines.append(" * lines starting with E are inserted")
        parsed_lines.append(" *")
        parsed_lines.append(" * !!! Autogenerated, do not edit! Your changes "
                            "will be lost. !!!")
        parsed_lines.append(" */")

        prefix = lambda src, lnr: "/* " + src + " " + str(lnr).zfill(4) + " */ "
        in_main = False

        for src_index, line in enumerate(shader_lines):
            stripped_line = line.strip().lower()

            # Check if we are already in the main function
            if "void main()" in stripped_line:
                in_main = True

            # Check if the current line is a hook
            if stripped_line.startswith("%") and stripped_line.endswith("%"):

                # If the line is a hook, get the hook name and save the
                # indent so we can indent all injected lines properly.
                hook_name = stripped_line[1:-1]
                indent = " " * (len(line) - len(line.lstrip()))

                # Inject all registered template values into the hook
                if hook_name in self._template_values:

                    # Directly remove the value from the list so we can check which
                    # hooks were not found in the template
                    insertions = self._template_values.pop(hook_name)

                    if len(insertions) > 0:

                        # When we are in the main function, we have to make sure we
                        # use a seperate scope, so there are no conflicts with variable
                        # declarations
                        parsed_lines.append("/* Hook " + hook_name + " */" + " {" if in_main else "")

                        for linenr, line_i in enumerate(insertions):

                            if line_i is None:
                                self.warn("Empty insertion '" + hook_name + "'")
                                continue

                            if not isinstance(line_i, str):
                                self.warn("Invalid line type: ", line_i)
                                continue

                            # Dont indent defines and pragmas
                            if line_i.startswith("#"):
                                parsed_lines.append(line_i)
                            else:
                                parsed_lines.append(prefix("E", linenr) + indent + line_i)

                        if in_main:
                            parsed_lines.append("}")

                # parsed_lines.append(indent + "// End of hook '" + hook_name + "'");
            else:
                # If the line is a pragma or a comment, dont add a line comment
                if line.startswith("#") or "//" in line or len(line.strip()) < 1:
                    parsed_lines.append(line.rstrip())

                # Otherwise add a comment showing the line in the template
                else:
                    parsed_lines.append(prefix("T", src_index) + line.rstrip())

        # Add a closing newline to the file
        parsed_lines.append("")

        # Warn the user about all unused hooks
        for key in self._template_values:
            self.warn("Hook '" + key + "' not found in template '" +\
                      self._file_source + "'!")

        # Write the constructed shader and load it back
        shader_content = '\n'.join(parsed_lines)
        temp_path = "$$pipeline_temp/$$Effect-" + self._template_name + ".glsl"

        with open(temp_path, "w") as handle:
            handle.write(shader_content)

        return temp_path
