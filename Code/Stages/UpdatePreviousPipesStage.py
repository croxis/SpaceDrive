
from direct.stdpy.file import open

from ..RenderStage import RenderStage
from ..Globals import Globals


class UpdatePreviousPipesStage(RenderStage):

    """ This stage is constructed by the StageManager and stores all the
    current pipes in the previous pipe storage. 

    This stage is a bit special, and not like the other stages, it does not
    specify inputs, since the StageManager passes all required inputs on demand.
    Also this stage does not load any shaders, but creates them on the fly.
    """

    def __init__(self, pipeline):
        RenderStage.__init__(self, "UpdatePreviousPipesStage", pipeline)
        self._transfers = []

    def add_transfer(self, from_tex, to_tex):
        """ Adds a new texture which should be copied from "from_tex" to
        "to_tex". This should be called before the stage gets constructed """
        if from_tex.get_x_size() != Globals.base.win.get_x_size() or \
            from_tex.get_y_size() != Globals.base.win.get_y_size():
            self.error("Storing of previous frame data which does not have window size"
                " is not supported yet: " + to_tex.get_name())
            return

        self._transfers.append((from_tex, to_tex))

    def create(self):
        self.debug("Creating previous pipes stage ..")
        self._target = self._create_target("StorePreviousPipes")
        # self._target.add_color_texture()
        self._target.prepare_offscreen_buffer()

        # Set inputs
        for i, (from_tex, to_tex) in enumerate(self._transfers):
            self._target.set_shader_input("SrcTex" + str(i), from_tex)
            self._target.set_shader_input("DestTex" + str(i), to_tex)

    def set_shaders(self):
        """ This method augo-generates a shader which copies all textures specified
        as "from-tex" to the textures specified as "to-tex". """
        uniforms = []
        copy_lines = []

        # Collect all samplers and generate the required uniforms and copy code
        for i, (from_tex, to_tex) in enumerate(self._transfers):
            index = str(i)
            uniforms.append(self.get_sampler_type(from_tex) + " SrcTex" + index)
            uniforms.append(self.get_sampler_type(to_tex, True) + " DestTex" + index)

            copy_lines.append("\n\t// Copying of " + from_tex.get_name() + " -> " + to_tex.get_name())
            copy_lines.append("\t"+\
                self.get_sampler_lookup(from_tex, "data" + index, "SrcTex" + index, "coord_2d_int"))
            copy_lines.append("\t"+\
                self.get_store_code(to_tex, "DestTex" + index, "coord_2d_int",  "data" + index))
            copy_lines.append("\n")

        # Actually create the shader
        fragment = "#version 430\n"
        fragment+= "\n// Autogenerated, do not edit! Your changes will be lost.\n\n"

        for uniform in uniforms:
            fragment += "uniform " + uniform + ";\n"

        fragment += "out vec4 result_color;\n"
        fragment += "\nvoid main() {\n"
        fragment += "\tivec2 coord_2d_int = ivec2(gl_FragCoord.xy);\n"
        for line in copy_lines:
            fragment += line + "\n"
        fragment += "result_color = vec4(0.2, 0.6, 1.0, 1.0);\n"
        fragment += "}\n"

        # Write the shader
        shader_dest = "$$PipelineTemp/$$UpdatePreviousPipes.frag.glsl"
        with open(shader_dest, "w") as handle:
            handle.write(fragment)

        # Load it back again
        shader = self._load_shader(shader_dest)
        self._target.set_shader(shader)

    def get_sampler_type(self, tex, can_write=False):
        """ Returns the matching GLSL sampler type for a Texture, or image type
        in case write access is required """
        # TODO: Add more sampler types based on texture type
        if not can_write:
            return "sampler2D"
        else:
            return "writeonly image2D"

    def get_sampler_lookup(self, tex, dest_name, sampler_name, coord_var):
        """ Returns the matching GLSL sampler lookup for a texture, storing the
        result in the given glsl variable """
        # TODO: Add more lookups based on texture type
        return "vec4 " + dest_name + " = texelFetch(" + sampler_name + ", " + coord_var + ", 0);"

    def get_store_code(self, tex, sampler_name, coord_var, data_var):
        """ Returns the matching GLSL code to store the given data in a given
        texture """
        # TODO: Add more stores based on texture type
        return "imageStore(" + sampler_name + ", " + coord_var + ", vec4(" + data_var + "));"

    def resize(self):
        RenderStage.resize(self)
        self.debug("Resizing pass")

    def cleanup(self):
        RenderStage.cleanup(self)
        self.debug("Cleanup pass")
