
from panda3d.core import PTAFloat, PTALVecBase3f

from .DebugObject import DebugObject

class ShaderUBO(DebugObject):

    """ Interface to shader uniform blocks """

    def __init__(self, name):
        DebugObject.__init__(self)
        self._ptas = {}
        self._name = name

    def register_pta(self, name, type):
        """ Registers a new input, type should be a glsl type """
        pta_handle = self._glsl_type_to_pta(type).empty_array(1)
        self._ptas[name] = pta_handle

    def get_name(self):
        """ Returns the name of the UBO """
        return self._name

    def _pta_to_glsl_type(self, pta_handle):
        """ Converts a PtaXXX to a glsl type """
        if isinstance(pta_handle, PTAFloat):
            return "float"
        elif isinstance(pta_handle, PTALVecBase3f):
            return "vec3"

        self.warn("Unrecognized PTA type:" , handle)
        return ""

    def _glsl_type_to_pta(self, glsl_type):
        """ Converts a glsl type to a PtaXXX type """
        if glsl_type == "float":
            return PTAFloat
        elif glsl_type == "vec3":
            return PTALVecBase3f
        self.warn("Unrecognized glsl type:", glsl_type)
        return None

    def bind_to(self, target):
        """ Binds all inputs of this UBO to the given target, which may be
        either a RenderTarget or a NodePath """

        for pta_name, pta_handle in self._ptas.items():
            target.set_shader_input(self._name + "." + pta_name, pta_handle)

    def generate_shader_code(self):
        """ Generates the GLSL shader code to use the UBO """

        content = "#pragma once\n\n"
        content += "// Autogenerated by RenderingPipeline\n"
        content += "// Do not edit! Your changes will be lost.\n\n"

        structs = {}
        inputs = []

        for input_name, handle in self._ptas.items():
            parts = input_name.split(".")

            # Single input, simply add it to the input list
            if len(parts) == 1:
                inputs.append(self._pta_to_glsl_type(handle) + " " + input_name + ";")

            # Nested input, like Scattering.sun_color
            elif len(parts) == 2:

                struct_name = parts[0]
                actual_input_name = parts[1]
                if struct_name in structs:
                    # Struct is already defined, add member definition
                    structs[struct_name].append(self._pta_to_glsl_type(handle) + " " + actual_input_name + ";")

                else:

                    # Construct a new struct and add it to the list of inputs
                    inputs.append(struct_name + "_UBOSTRUCT " + struct_name + ";")
                    structs[struct_name] = [self._pta_to_glsl_type(handle) + " " + actual_input_name + ";"]

            # Nested input, like Scattering.some_setting.sun_color, not supported yet
            else:
                self.warn("Structure definition too nested, not supported (yet):", input_name)

        # Add structures
        for struct_name, members in structs.items():
            content += "struct " + struct_name + "_UBOSTRUCT {\n"

            for member in members:
                content += " " * 4 + member + "\n"

            content += "};\n\n"

        # Add actual inputs
        if len(inputs) < 1:
            self.warn("No UBO inputs")
        else:

            content += "uniform struct {\n"

            for ipt in inputs:
                content += " " * 4 + ipt + "\n"

            content += "} TimeOfDay;\n"

        content += "\n"
        return content