
from direct.stdpy.file import open

from .DebugObject import DebugObject

class ShaderTemplate(DebugObject):

    """ This class manages the loading of shader templates, including the
    replacement of template parameters. """

    def __init__(self, template_file, template_name="template"):
        DebugObject.__init__(self)
        self._file_source = template_file
        self._template_values = {}
        self._template_name = template_name

    def register_template_value(self, key, val):
        """ Registers a new template value. The value may either be a list of
        strings or just a single string """
        if not isinstance(val, (list, tuple)):
            val = [val]
        key = key.lower()

        if key in self._template_values:
            self._template_values[key] += val
        else:
            self._template_values[key] = val

    def create(self):
        """ Constructs a shader object from the template and returns the path
        to the compiled shader """

        with open(self._file_source, "r") as handle:
            shader_lines = handle.readlines()

        # Parse all shader lines
        parsed_lines = []

        # Add header
        parsed_lines.append("/* Compiled Shader Template ")
        parsed_lines.append(" * generated from: '" + self._file_source + "'")
        parsed_lines.append(" * template name: '" + self._template_name + "'")
        parsed_lines.append(" * lines starting with T are from the template")
        parsed_lines.append(" * lines starting with E are inserted")
        parsed_lines.append(" *")
        parsed_lines.append(" * !!! Autogenerated, do not edit! Your changes "
                            "will be lost. !!!")
        parsed_lines.append(" */")

        prefix = lambda src, lnr: "/* " + src + " " + str(lnr).zfill(4) + " */ "

        for src_index, line in enumerate(shader_lines):
            stripped_line = line.strip().lower()

            # Check if the current line is a hook
            if stripped_line.startswith("%") and stripped_line.endswith("%"):

                # If the line is a hook, get the hook name and save the
                # indent so we can indent all injected lines properly.
                hook_name = stripped_line[1:-1]
                indent = " " * (len(line) - len(line.lstrip()))

                # Inject all registered template values into the hook
                if hook_name in self._template_values:
                    
                    # Directly remove the value from the list so we can check which
                    # hooks were not found in the template
                    insertions = self._template_values.pop(hook_name)
                    if len(insertions) > 0:
                        parsed_lines.append("/* Hook " + hook_name + " */")
                    for linenr, line_i in enumerate(insertions):

                        if line_i is None:
                            self.warn("Empty insertion '" + hook_name + "'")
                            continue

                        # Dont indent defines and pragmas
                        if line_i.startswith("#"):
                            parsed_lines.append(line_i)
                        else:
                            parsed_lines.append(prefix("E", linenr) + indent + line_i)

                # parsed_lines.append(indent + "// End of hook '" + hook_name + "'");
            else:
                # If the line is a pragma or a comment, dont add a line comment
                if line.startswith("#") or "//" in line or len(line.strip()) < 1:
                    parsed_lines.append(line.rstrip())

                # Otherwise add a comment showing the line in the template
                else:
                    parsed_lines.append(prefix("T", src_index) + line.rstrip())

        # Add a closing newline to the file
        parsed_lines.append("")

        # Warn the user about all unused hooks
        for key in self._template_values:
            self.warn("Hook '" + key + "' not found in template '" +\
                      self._file_source + "'!")

        # Write the constructed shader and load it back
        shader_content = '\n'.join(parsed_lines)
        temp_path = "$$PipelineTemp/$$Effect-" + self._template_name + ".glsl"

        with open(temp_path, "w") as handle:
            handle.write(shader_content)

        return temp_path
