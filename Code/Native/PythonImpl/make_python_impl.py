"""

Generates a (dummy) python implementation from the c++ classes

"""

from __future__ import print_function

import os
import sys
import re

os.chdir(os.path.dirname(os.path.realpath(__file__)))

sys.path.insert(0, "../../")

from External.CPPHeaderParser import CppHeader, CppParseError

# Path of the .cpp files
SOURCE_DIR = "../Source/"
OUTPUT = """
\n\n\n\n\n
""" + "#" * 70 + """
#
#                    -- Autogenerated, do not edit! --
#
""" + "#" * 70 + """
\n\n\n\n\n

from __future__ import print_function

# Common imports
from panda3d.core import Vec3, PNMImage


class NotTemplatedError(Exception):
    def __init__(self, func_name):
        Exception.__int__(self, "Function " + func_name + " is not templated in python yet! "
                                "Please use the C++ Module to use this functionality.")

\n\n
"""

# Skip certain methods which are just there for panda, we don't need them in
# python
SKIP_METHODS = [
    "get_class_type",
    "init_type",
    "get_type",
    "force_init_type",
]

# Regexp to replace PT(xxx)
PTA_REGEXP = re.compile(r"PT\(([^\)]+)\)")

# Regexp to match ClassName::FunctionName(params)
REGEXP_METHODDEF = re.compile(r"def ([a-zA-Z0-9_]+)\(([^\)]+)\)")

# Whether to write a docstring above each method
WRITE_DOCSTRING = False

def load_templates(fname, prefix):
    """ Loads the function templates from a file """
    with open(fname, "r") as handle:
        lines = handle.readlines()

    # Make sure the last line is a newline
    lines.append("")

    methods = {}
    indent = " " * 4
    method = None
    method_data = {"code": []}
    for line in lines:

        # Start of a function definition
        if line.startswith("def"):
            if method:
                methods[method] = method_data
                method = None
                method_data = {"code": []}

            match = REGEXP_METHODDEF.match(line)
            if not match:
                print("Malformed template line:", line)
                continue

            method_data["class"] = prefix
            method_data["name"] = match.group(1)
            method_data["args"] = match.group(2)
            method = method_data["class"] + "::" + method_data["name"]

        # Inline functino code
        elif line.startswith(indent):
            if method is None:
                print("Code out of method! Was:", line)
                continue
            else:
                method_data["code"].append(line.rstrip()[4:])

    if method is not None:
        methods[method] = method_data

    return methods

def resolve_return_type(rtype):
    """ Converts a c++ return type to python """
    if "void" in rtype:
        return "None"
    elif "bool" in rtype:
        return "bool"
    elif "int" in rtype:
        return "int"
    elif "float" or "double" in rtype:
        return "float"
    return "??" + rtype


def process_header(header, templates):
    """ Processes a header file """
    global OUTPUT

    with open(header, "r") as handle:
        content = handle.read()

    # Replace the published declarator, which is used by panda, to be public
    content = content.replace("PUBLISHED", "public")

    # Seems the cpp header parser can't handle PT(xxx), so replace it by a template
    content = PTA_REGEXP.sub(r"PointerTo<\1>", content)

    # Try reading the file
    try:
        parsed = CppHeader(content, "string")
    except CppParseError as msg:
        print("Error parsing header",header)
        print("Reason:", msg)
        return

    # Each .h file should exactly define 1 class, if not, most likely something 
    # went wrong
    if len(parsed.classes) != 1:
        # print("Invalid amount of classes:",header," (Found", len(parsed.classes), "-> expected 1)")
        return

    current_cls = parsed.classes_order[0]

    # Parse inheritance
    inherits = current_cls["inherits"]
    inherit_flat = []
    for dt in inherits:
        # Don't use panda classes
        if dt["class"] not in "CallbackObject ReferenceCount PandaNode TypedReferenceCount".split():
            inherit_flat.append(dt["class"])

    if not inherit_flat:
        inherit_flat = ["object"]

    indent = " " * 4

    # Generate class definition
    OUTPUT += "# Source: " + header + "\n" 
    OUTPUT += "class {}({}):\n\n".format(current_cls["name"], ', '.join(inherit_flat))

    # Write enums
    for enum in current_cls["enums"]["public"]:
        OUTPUT += indent * 1 + "# Enum: " + enum["name"] + "\n"
        for val in enum["values"]:
            OUTPUT += indent * 1 + val["name"] + " = " + str(val["value"]) + "\n"
        OUTPUT += "\n"


    # Write methods
    methods = current_cls["methods"]["public"]
    method_names = [method["name"] for method in methods]
    methods_written = set()

    for method in methods:

        method_name = method["name"]
        
        # Name the constructor to fit to python
        if method["constructor"]:
            method_name = "__init__"

        # Skip destructors
        if method["destructor"]:
            continue

        # Skip certain methods
        if method_name in SKIP_METHODS:
            continue

        # Skip already defined methods
        if method_name in methods_written:
            continue
        methods_written.add(method_name)

        # While generating the method, we also generate a docstring
        doc = ["Method " + current_cls["name"] + "::" + method_name, ""]
        params = ["self"]
        method_str = ""

        if method["static"]:
            print("Skipping static method", method_name)
            continue

        # Check for a predefined template
        template_key = current_cls["name"] + "::" + method_name

        if template_key in templates:
            print("Found template:", template_key)

            template = templates[template_key]
            method_str = indent * 1 + "def " + template["name"] + "(" + template["args"] + "):\n"
            if not template["code"]:
                print("Skipping empty template", template_key)
                continue

            for line in template["code"]:
                method_str += indent * 2 + line + "\n"

        else:

            # Parse parameters, but only if there are no overloads
            if method_names.count(method_name) <= 1:
                for arg in method["parameters"]:
                    doc += ["@param " + arg["name"] + " Parameter of type " + arg["type"]]
                    params.append(arg["name"])

                method_str += indent * 1 + "def " + method_name + "(" + ', '.join(params) + "):\n"

            # Overloaded methods have to determine the parameters themselfes
            else:            
                method_str += indent * 1 + "def " + method_name + "(self, *args, **kwargs):\n"
            
                doc.append(str(method_names.count(method_name)) + " overloads for this function")

            method_str += indent * 2 + "raise NotTemplatedError('" + template_key + "')\n"
            # Write dummy return statement
            return_type = resolve_return_type(method["rtnType"])
            doc += ["@return " + return_type]

        # Write docstring
        if WRITE_DOCSTRING:
            OUTPUT += indent * 1 + '"""\n'
            for line in doc:
                OUTPUT += indent * 1 + line + "\n"
            OUTPUT += indent * 1 + '"""\n'
        OUTPUT += method_str + "\n"

    OUTPUT += "\n\n"


if __name__ == "__main__":


    # Load templates
    templates = {}
    # templates = load_templates("methods.template")
    files = os.listdir("Templates/")
    for fname in files:
        template_name = fname.split(".")[0]
        templates.update(load_templates("Templates/" + fname, template_name))

    # Collect headers
    headers = []
    for pth, attr, files in os.walk(SOURCE_DIR):
        headers += [os.path.join(pth, i) for i in files if i.endswith(".h")]

    for header in headers:
        process_header(header, templates)

    with open("autogenerated_wrapper.py", "w") as handle:
        handle.write(OUTPUT)
